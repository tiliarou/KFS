initSidebarItems({"fn":[["accept_session","Waits for an incoming connection on the given ServerPort handle, and create a new ServerSession for it."],["close_handle","Closed the passed handle."],["connect_to_named_port","Connects to the given named port. The name should be a 12-byte array containing a null-terminated string."],["connect_to_port","Connects to the given ClientPort."],["create_interrupt_event","Create an event handle for the given IRQ number. Waiting on this handle will wait until the IRQ is triggered. The flags argument configures the triggering. If it is false, the IRQ is active HIGH level sensitive, if it is true it is rising-edge sensitive."],["create_port","Create a new Port pair. Those ports are linked to each-other: The server will receive connections from the client."],["create_session","Create a new Session pair. Those sessions are linked to each-other: The server will receive requests sent through the client."],["create_shared_memory","Allocate a new SharedMemory region. This is a memory region backed by DRAM allocated from the current process' pool partition, that can be mapped in different processes."],["create_thread","Creates a thread in the current process. The thread can then be started with the svcStartThread."],["exit_process","Kills our own process."],["exit_thread","Kills our own thread."],["manage_named_port","Creates a new ServerPort for the given named port. The name should be a 12-byte array containing a null-terminated string. This ServerPort can be connected to with `connect_to_named_port`."],["map_framebuffer","Maps the vga frame buffer mmio in userspace memory"],["map_mmio_region","Maps a physical region in the address space of the process."],["map_shared_memory","Maps the block supplied by the handle. The required permissions are different for the process that created the handle and all other processes."],["output_debug_string","Print the passed string to the serial port."],["query_memory","Query information about an address. Will always fetch the lowest page-aligned mapping that contains the provided address. Writes the output to the given userspace pointer to a MemoryInfo structure."],["query_physical_address","Gets the physical region a given virtual address maps."],["reply_and_receive_with_user_buffer","If ReplyTarget is not zero, a reply from the given buffer will be sent to that session. Then it will wait until either of the passed sessions has an incoming message, is closed, a passed port has an incoming connection, or the timeout expires. If there is an incoming message, it is copied to the TLS."],["send_sync_request_with_user_buffer","Send an IPC request through the ClientSession, and blocks until a response is received. This variant takes a userspace buffer and size. Those must be page-aligned."],["set_heap_size","Resize the heap of a process, just like a brk. It can both expand, and shrink the heap."],["sleep_thread","Sleep for a specified amount of time, or yield thread."],["start_thread","Starts a previously created thread."],["syscall_handler_inner","Syscall dispatcher. Dispatches to the various syscall handling functions based on registers.eax, and updates the registers struct with the correct return values."],["unmap_shared_memory","Unmaps this shared memory region. This cannot be used to partially unmap a region: the address must be the start of the shared mapping, and the size must be the full size of the mapping."],["wait_synchronization","Waits for one of the handles to signal an event."]],"struct":[["Registers","Represents a register backup. The syscall wrapper constructs this structure before calling syscall_handler_inner, and then pops it before returning to userspace, allowing precise control over register state."]]});