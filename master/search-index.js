var N = null;var searchIndex = {};
searchIndex["kfs_bootstrap"]={"doc":"Bootstrap stage","items":[[3,"AlignedStack","kfs_bootstrap","4 pages, PAGE_SIZE aligned.",N,N],[12,"0","","",0,N],[3,"EndTag","","",N,N],[12,"tag","","",1,N],[12,"flag","","",1,N],[12,"size","","",1,N],[3,"FramebufferTag","","",N,N],[12,"tag","","",2,N],[12,"flags","","",2,N],[12,"size","","",2,N],[12,"width","","",2,N],[12,"height","","",2,N],[12,"depth","","",2,N],[3,"ModuleAlignmentTag","","",N,N],[12,"tag","","",3,N],[12,"flags","","",3,N],[12,"size","","",3,N],[3,"MultiBootHeader","","The multiboot header structure of our binary.",N,N],[12,"magic","","",4,N],[12,"architecture","","",4,N],[12,"header_length","","",4,N],[12,"checksum","","",4,N],[12,"framebuffer","","",4,N],[12,"end","","",4,N],[5,"print_stack","","Prints raw hexdump of the stack. Use this if everything…",N,[[]]],[5,"bootstrap_start","","The very start.",N,N],[5,"do_bootstrap","","bootstrap stage and call kernel",N,N],[5,"eh_personality","","The exception handling personality function for use in the…",N,[[]]],[5,"panic_fmt","","The bootstrap panic function.",N,N],[0,"bootstrap_logging","","bootstrap logging on rs232",N,N],[3,"Serial","kfs_bootstrap::bootstrap_logging","A logger that sends its output to COM1.",N,N],[5,"init_bootstrap_log","","Init the rs232 COM1. Must be called before logging anything.",N,[[]]],[5,"bootstrap_log","","Sends a string to COM1.",N,[[["str"]]]],[5,"bootstrap_inb","","",N,[[["u16"]],["u8"]]],[5,"bootstrap_outb","","",N,[[["u16"],["u8"]]]],[17,"COM1","","",N,N],[0,"gdt","kfs_bootstrap","GDT Handler",N,N],[3,"MAIN_TASK","kfs_bootstrap::gdt","",N,N],[12,"__private_field","","",5,N],[3,"FAULT_TASK","","",N,N],[12,"__private_field","","",6,N],[3,"DescriptorTable","","A structure containing our GDT. We can have at most 16…",N,N],[12,"table","","",7,N],[3,"DescriptorTableEntry","","",N,N],[12,"0","","",8,N],[4,"SystemDescriptorTypes","","",N,N],[13,"AvailableTss16","","",9,N],[13,"Ldt","","",9,N],[13,"BusyTss16","","",9,N],[13,"CallGate16","","",9,N],[13,"TaskGate","","",9,N],[13,"InterruptGate16","","",9,N],[13,"TrapGate16","","",9,N],[13,"AvailableTss32","","",9,N],[13,"BusyTss32","","",9,N],[13,"CallGate32","","",9,N],[13,"InterruptGate32","","",9,N],[13,"TrapGate32","","",9,N],[5,"init_gdt","","",N,[[]]],[0,"segment_selector","","Types for the Global Descriptor Table and segment selectors.",N,N],[3,"SegmentSelector","kfs_bootstrap::gdt::segment_selector","Specifies which element to load into a segment from…",N,N],[12,"0","","",10,N],[11,"new","","Creates a new SegmentSelector",10,[[["u16"],["privilegelevel"]],["segmentselector"]]],[11,"index","","Returns the GDT index.",10,[[["self"]],["u16"]]],[11,"rpl","","Returns the requested privilege level.",10,[[["self"]],["privilegelevel"]]],[0,"i386","kfs_bootstrap::gdt","This crate is x86_64's little brother. It provides i386…",N,N],[3,"TssStruct","kfs_bootstrap::gdt::i386","The Task State Segment (TSS) is a special data structure…",N,N],[12,"_reserved1","","",11,N],[12,"link","","",11,N],[12,"esp0","","",11,N],[12,"_reserved2","","",11,N],[12,"ss0","","",11,N],[12,"esp1","","",11,N],[12,"_reserved3","","",11,N],[12,"ss1","","",11,N],[12,"esp2","","",11,N],[12,"_reserved4","","",11,N],[12,"ss2","","",11,N],[12,"cr3","","",11,N],[12,"eip","","",11,N],[12,"eflags","","",11,N],[12,"eax","","",11,N],[12,"ecx","","",11,N],[12,"edx","","",11,N],[12,"ebx","","",11,N],[12,"esp","","",11,N],[12,"ebp","","",11,N],[12,"esi","","",11,N],[12,"edi","","",11,N],[12,"_reserved5","","",11,N],[12,"es","","",11,N],[12,"_reserved6","","",11,N],[12,"cs","","",11,N],[12,"_reserved7","","",11,N],[12,"ss","","",11,N],[12,"_reserved8","","",11,N],[12,"ds","","",11,N],[12,"_reserved9","","",11,N],[12,"fs","","",11,N],[12,"_reserveda","","",11,N],[12,"gs","","",11,N],[12,"_reservedb","","",11,N],[12,"ldt_selector","","",11,N],[12,"iopboffset","","",11,N],[12,"_reservedc","","",11,N],[4,"PrivilegeLevel","","Represents a protection ring level.",N,N],[13,"Ring0","","Privilege-level 0 (most privilege): This level is used by…",12,N],[13,"Ring1","","Privilege-level 1 (moderate privilege): This level is used…",12,N],[13,"Ring2","","Privilege-level 2 (moderate privilege): Like level 1, this…",12,N],[13,"Ring3","","Privilege-level 3 (least privilege): This level is used by…",12,N],[0,"instructions","","Low level functions for special i386 instructions.",N,N],[0,"tables","kfs_bootstrap::gdt::i386::instructions","Instructions for loading descriptor tables (GDT, IDT, etc.).",N,N],[3,"DescriptorTablePointer","kfs_bootstrap::gdt::i386::instructions::tables","A struct describing a pointer to a descriptor table (GDT /…",N,N],[12,"limit","","Size of the DT.",13,N],[12,"base","","Pointer to the memory region containing the DT.",13,N],[5,"lgdt","","Load GDT table.",N,[[["descriptortablepointer"]]]],[5,"lldt","","Load LDT table.",N,[[["segmentselector"]]]],[5,"ltr","","Sets the task register to the given TSS segment.",N,[[["segmentselector"]]]],[5,"lidt","","Load IDT table.",N,[[["descriptortablepointer"]]]],[0,"segmentation","kfs_bootstrap::gdt::i386::instructions","Provides functions to read and write segment registers.",N,N],[5,"set_cs","kfs_bootstrap::gdt::i386::instructions::segmentation","Reload code segment register. Note this is special since…",N,[[["segmentselector"]]]],[5,"load_ss","","Reload stack segment register.",N,[[["segmentselector"]]]],[5,"load_ds","","Reload data segment register.",N,[[["segmentselector"]]]],[5,"load_es","","Reload es segment register.",N,[[["segmentselector"]]]],[5,"load_fs","","Reload fs segment register.",N,[[["segmentselector"]]]],[5,"load_gs","","Reload gs segment register.",N,[[["segmentselector"]]]],[5,"cs","","Returns the current value of the code segment register.",N,[[],["segmentselector"]]],[0,"interrupts","kfs_bootstrap::gdt::i386::instructions","Interrupt disabling functionality.",N,N],[5,"sti","kfs_bootstrap::gdt::i386::instructions::interrupts","Enable interrupts",N,[[]]],[5,"cli","","Disable interrupts",N,[[]]],[11,"from_u16","kfs_bootstrap::gdt::i386","Creates a `PrivilegeLevel` from a numeric value. The value…",12,[[["u16"]],["privilegelevel"]]],[11,"new","","",11,N],[7,"GDT","kfs_bootstrap::gdt","",N,N],[7,"GLOBAL_LDT","","The global LDT used by all the processes.",N,N],[7,"MAIN_TASK","","",N,N],[7,"FAULT_TASK","","",N,N],[11,"new","","",7,[[],["descriptortable"]]],[11,"push","","",7,[[["self"],["descriptortableentry"]]]],[11,"load_global","","",7,[[["self"],["u16"],["u16"],["u16"]]]],[11,"null_descriptor","","",8,[[],["descriptortableentry"]]],[11,"new","","Creates an empty GDT descriptor, but with some flags set…",8,[[["u32"],["u32"],["bool"],["privilegelevel"]],["descriptortableentry"]]],[11,"new_system","","Creates an empty GDT descriptor, but with some flags set…",8,[[["systemdescriptortypes"],["u32"],["u32"],["privilegelevel"]],["descriptortableentry"]]],[11,"new_ldt","","Creates a new LDT descriptor.",8,[[["descriptortable"],["privilegelevel"]],["descriptortableentry"]]],[11,"new_tss","","Creates a GDT descriptor pointing to a TSS segment",8,[[["tssstruct"],["privilegelevel"]],["descriptortableentry"]]],[11,"get_limit","","",8,[[["self"]],["u32"]]],[11,"set_limit","","",8,[[["self"],["u32"]]]],[11,"get_base","","",8,[[["self"]],["u32"]]],[11,"set_base","","",8,[[["self"],["u32"]]]],[11,"get_accessed","","",8,[[["self"]],["bool"]]],[11,"is_readwrite_allowed","","",8,[[["self"]],["bool"]]],[11,"is_comformant","","",8,[[["self"]],["bool"]]],[11,"is_executable","","",8,[[["self"]],["bool"]]],[11,"get_ring_level","","",8,[[["self"]],["privilegelevel"]]],[11,"get_present","","",8,[[["self"]],["bool"]]],[11,"is_4k_granularity","","",8,[[["self"]],["bool"]]],[11,"set_4k_granularity","","",8,[[["self"],["bool"]]]],[11,"is_32bit","","",8,[[["self"]],["bool"]]],[0,"address","kfs_bootstrap","Physical and Virtual address wrappers",N,N],[3,"PhysicalAddress","kfs_bootstrap::address","Represents a Physical address",N,N],[12,"0","","",14,N],[3,"VirtualAddress","","Represents a Virtual address",N,N],[12,"0","","",15,N],[11,"addr","","Gets the address as a `usize`.",15,[[["self"]],["usize"]]],[11,"addr","","Gets the address as a `usize`.",14,[[["self"]],["usize"]]],[11,"floor","","Rounds down to PAGE_SIZE.",14,[[["self"]],["physicaladdress"]]],[11,"ceil","","Rounds up PAGE_SIZE.",14,[[["self"]],["physicaladdress"]]],[11,"floor","","Rounds down to PAGE_SIZE.",15,[[["self"]],["virtualaddress"]]],[11,"ceil","","Rounds up PAGE_SIZE.",15,[[["self"]],["virtualaddress"]]],[0,"paging","kfs_bootstrap","Paging on i386",N,N],[3,"ActivePageTables","kfs_bootstrap::paging","The page tables set currently in use.",N,N],[3,"InactivePageTables","","A set of PageTables that are not the ones currently in…",N,N],[12,"directory_physical_address","","",16,N],[3,"PagingOffPageSet","","Used at startup when paging is off to create and…",N,N],[12,"directory_physical_address","","",17,N],[3,"EntryFlags","","The flags of a table entry",N,N],[12,"bits","","",18,N],[3,"KernelLand","","The virtual memory belonging to kernel.",N,N],[3,"UserLand","","The virtual memory belonging to user.",N,N],[4,"MappingType","","The type of a Virtual Memory mapping. Can either be…",N,N],[13,"Present","","",19,N],[13,"Guard","","",19,N],[5,"is_paging_on","","Check if the paging is currently active.",N,[[],["bool"]]],[5,"enable_paging","","",N,[[["physicaladdress"]]]],[5,"flush_tlb","","Flush the Translation Lookaside Buffer…",N,[[]]],[5,"swap_cr3","","Changes the content of the cr3 register, and returns the…",N,[[["physicaladdress"]],["physicaladdress"]]],[5,"map_bootstrap","","Creates a set of page tables identity mapping the Bootstrap.",N,[[["bootinformation"]],["pagingoffpageset"]]],[5,"__land_assertions","","",N,[[]]],[5,"get_page","","Creates a mapping in the page tables with the given flags.…",N,[[],["virtualaddress"]]],[0,"entry","","i386 page table entry",N,N],[3,"EntryFlags","kfs_bootstrap::paging::entry","The flags of a table entry",N,N],[12,"bits","","",20,N],[3,"Entry","","An entry in a page table or page directory. An unused…",N,N],[12,"0","","",21,N],[4,"PageState","","Represent the current state of this Page Table Entry: It…",N,N],[13,"Available","","",22,N],[13,"Guarded","","",22,N],[13,"Present","","",22,N],[17,"ENTRY_PHYS_ADDRESS_MASK","","",N,N],[18,"PRESENT","","",20,N],[18,"WRITABLE","","",20,N],[18,"USER_ACCESSIBLE","","",20,N],[18,"WRITE_THROUGH","","",20,N],[18,"NO_CACHE","","",20,N],[18,"ACCESSED","","",20,N],[18,"DIRTY","","",20,N],[18,"HUGE_PAGE","","",20,N],[18,"GLOBAL","","",20,N],[18,"GUARD_PAGE","","",20,N],[18,"IS_FRAME_ALLOC","","",20,N],[18,"USER_DEFINED_3","","",20,N],[11,"empty","","Returns an empty set of flags.",20,[[],["entryflags"]]],[11,"all","","Returns the set containing all flags.",20,[[],["entryflags"]]],[11,"bits","","Returns the raw value of the flags currently stored.",20,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",20,[[["u32"]],["option",["entryflags"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",20,[[["u32"]],["entryflags"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",20,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",20,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",20,[[["self"],["entryflags"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",20,[[["self"],["entryflags"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",20,[[["self"],["entryflags"]]]],[11,"remove","","Removes the specified flags in-place.",20,[[["self"],["entryflags"]]]],[11,"toggle","","Toggles the specified flags in-place.",20,[[["self"],["entryflags"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",20,[[["self"],["entryflags"],["bool"]]]],[11,"is_unused","","Is the entry unused ?",21,[[["self"]],["bool"]]],[11,"set_unused","","Clear the entry",21,[[["self"]],["pagestate",["frame"]]]],[11,"is_guard","","Is the entry a page guard ?",21,[[["self"]],["bool"]]],[11,"flags","","Get the current entry flags",21,[[["self"]],["entryflags"]]],[11,"pointed_frame","","Get the associated physical address, if available",21,[[["self"]],["pagestate",["physicaladdress"]]]],[11,"set","","Sets the entry",21,[[["self"],["frame"],["entryflags"]]]],[11,"set_guard","","Make this entry a page guard",21,[[["self"]]]],[11,"unwrap","","Move the value T out of the PageState if it is Present(T).",22,[[["self"]],["t"]]],[11,"map","","Maps a PageState to PageState by applying a function to a…",22,[[["self"],["f"]],["pagestate"]]],[11,"as_option","","Turns the PageState into an Option, setting both Guarded…",22,[[["self"]],["option"]]],[0,"table","kfs_bootstrap::paging","i386 page table / directory",N,N],[3,"PageTable","kfs_bootstrap::paging::table","A page table",N,N],[12,"entries","","",23,N],[3,"PageDirectory","","A page directory",N,N],[12,"0","","",24,N],[3,"EntryFlags","","The flags of a table entry",N,N],[12,"bits","","",18,N],[3,"ActivePageTables","","The page tables set currently in use.",N,N],[3,"ActivePageDirectory","","The page directory currently in use.",N,N],[12,"0","","",25,N],[3,"ActivePageTable","","A page table currently in use.",N,N],[12,"0","","",26,N],[3,"SmartHierarchicalTable","","This is just a wrapper for a pointer to a Table or a…",N,N],[12,"0","","",27,N],[12,"1","","",27,N],[3,"InactivePageTables","","A set of PageTables that are not the ones currently in…",N,N],[12,"directory_physical_address","","",16,N],[3,"InactivePageDirectory","","A temporary mapped page directory.",N,N],[12,"0","","",28,N],[3,"InactivePageTable","","A temporary mapped page table.",N,N],[12,"0","","",29,N],[3,"PagingOffPageSet","","Used at startup when paging is off to create and…",N,N],[12,"directory_physical_address","","",17,N],[3,"PagingOffDirectory","","A directory we can modify by directly accessing physical…",N,N],[12,"0","","",30,N],[3,"PagingOffTable","","A table we can modify by directly accessing physical…",N,N],[12,"0","","",31,N],[3,"TlbFlush","","When passing this struct the TLB will be flushed. Used by…",N,N],[3,"NoFlush","","When passing this struct the TLB will not be flushed. Used…",N,N],[4,"MappingType","","The type of a Virtual Memory mapping. Can either be…",N,N],[13,"Present","","",19,N],[13,"Guard","","",19,N],[5,"__assertions","","",N,[[]]],[0,"entry","","i386 page table entry",N,N],[3,"EntryFlags","kfs_bootstrap::paging::table::entry","The flags of a table entry",N,N],[12,"bits","","",32,N],[3,"Entry","","An entry in a page table or page directory. An unused…",N,N],[12,"0","","",33,N],[4,"PageState","","Represent the current state of this Page Table Entry: It…",N,N],[13,"Available","","",34,N],[13,"Guarded","","",34,N],[13,"Present","","",34,N],[17,"ENTRY_PHYS_ADDRESS_MASK","","",N,N],[18,"PRESENT","","",32,N],[18,"WRITABLE","","",32,N],[18,"USER_ACCESSIBLE","","",32,N],[18,"WRITE_THROUGH","","",32,N],[18,"NO_CACHE","","",32,N],[18,"ACCESSED","","",32,N],[18,"DIRTY","","",32,N],[18,"HUGE_PAGE","","",32,N],[18,"GLOBAL","","",32,N],[18,"GUARD_PAGE","","",32,N],[18,"IS_FRAME_ALLOC","","",32,N],[18,"USER_DEFINED_3","","",32,N],[11,"empty","","Returns an empty set of flags.",32,[[],["entryflags"]]],[11,"all","","Returns the set containing all flags.",32,[[],["entryflags"]]],[11,"bits","","Returns the raw value of the flags currently stored.",32,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",32,[[["u32"]],["option",["entryflags"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",32,[[["u32"]],["entryflags"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",32,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",32,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",32,[[["self"],["entryflags"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",32,[[["self"],["entryflags"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",32,[[["self"],["entryflags"]]]],[11,"remove","","Removes the specified flags in-place.",32,[[["self"],["entryflags"]]]],[11,"toggle","","Toggles the specified flags in-place.",32,[[["self"],["entryflags"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",32,[[["self"],["entryflags"],["bool"]]]],[11,"is_unused","","Is the entry unused ?",33,[[["self"]],["bool"]]],[11,"set_unused","","Clear the entry",33,[[["self"]],["pagestate",["frame"]]]],[11,"is_guard","","Is the entry a page guard ?",33,[[["self"]],["bool"]]],[11,"flags","","Get the current entry flags",33,[[["self"]],["entryflags"]]],[11,"pointed_frame","","Get the associated physical address, if available",33,[[["self"]],["pagestate",["physicaladdress"]]]],[11,"set","","Sets the entry",33,[[["self"],["frame"],["entryflags"]]]],[11,"set_guard","","Make this entry a page guard",33,[[["self"]]]],[11,"unwrap","","Move the value T out of the PageState if it is Present(T).",34,[[["self"]],["t"]]],[11,"map","","Maps a PageState to PageState by applying a function to a…",34,[[["self"],["f"]],["pagestate"]]],[11,"as_option","","Turns the PageState into an Option, setting both Guarded…",34,[[["self"]],["option"]]],[0,"detail","kfs_bootstrap::paging::table","",N,N],[8,"I386PageTablesSet","kfs_bootstrap::paging::table::detail","A trait describing the interface of a PageTable hierarchy.",N,N],[16,"PageDirectoryType","","",35,N],[10,"get_directory","","Gets a reference to the directory",35,[[["self"]],["smarthierarchicaltable"]]],[17,"DIRECTORY_RECURSIVE_ADDRESS","kfs_bootstrap::paging::table","When paging is on, accessing this address loops back to…",N,N],[8,"HierarchicalTable","","A table of entries, either the directory or one of the…",N,N],[10,"entries","","",36,N],[10,"entries_mut","","",36,N],[11,"zero","","zero out the whole table",36,[[["self"]]]],[11,"map_nth_entry","","Creates a mapping on the nth entry of a table T is a…",36,[[["self"],["usize"],["frame"],["i386entryflags"]]]],[11,"guard_nth_entry","","Marks the nth entry as guard page T is a flusher…",36,[[["self"],["usize"]]]],[11,"flush_cache","","",36,[[]]],[8,"PageTableTrait","","",N,N],[16,"FlusherType","","",37,N],[11,"map_whole_table","","Used at startup when creating the first page tables.",37,[[["self"],["physicaladdress"],["i386entryflags"]]]],[11,"map_guard_whole_table","","Used at startup when creating the first page tables.",37,[[["self"]]]],[8,"PageDirectoryTrait","","A trait describing all the things that a PageDirectory can…",N,N],[16,"PageTableType","","",38,N],[16,"FlusherType","","",38,N],[10,"get_table","","Gets a reference to a page table",38,[[["self"],["usize"]],["pagestate",["smarthierarchicaltable"]]]],[10,"create_table","","Allocates a page table, zero it and add an entry to the…",38,[[["self"],["usize"]],["smarthierarchicaltable"]]],[11,"get_table_or_create","","Gets the page table at given index, or creates it if it…",38,[[["self"],["usize"]],["smarthierarchicaltable"]]],[11,"map_to","","Creates a mapping in the page tables with the given flags",38,[[["self"],["frame"],["virtualaddress"],["i386entryflags"]]]],[11,"guard","","Creates a guard page",38,[[["self"],["virtualaddress"]]]],[11,"__unmap","","Deletes a mapping in the page tables, returning the frame…",38,[[["self"],["virtualaddress"]],["pagestate",["frame"]]]],[11,"find_available_virtual_space_aligned","","Finds a virtual space hole that can contain page_nb…",38,[[["self"],["usize"],["usize"]],["option",["virtualaddress"]]]],[8,"PageTablesSet","","",N,N],[10,"map_to","","Creates a mapping in the page tables with the given flags",39,[[["self"],["mappingtype"],["virtualaddress"]]]],[10,"get_phys","","Gets the current mapping state of this Virtual Address.",39,[[["self"],["virtualaddress"]],["pagestate",["physicaladdress"]]]],[10,"find_available_virtual_space_aligned","","Finds a virtual space hole that can contain page_nb…",39,[[["self"],["usize"],["usize"]],["option",["virtualaddress"]]]],[11,"print_mapping","","Prints the current mapping.",39,[[["self"]]]],[10,"unmap","","Deletes a mapping in the page tables, returning the Frame…",39,[[["self"],["virtualaddress"]],["pagestate",["frame"]]]],[11,"map_allocate_to","","Creates a mapping in the page tables with the given flags.…",39,[[["self"],["virtualaddress"],["entryflags"]]]],[11,"map_frame","","Maps a given frame in the page tables. Takes care of…",39,[[["self"],["frame"],["entryflags"]],["virtualaddress"]]],[11,"get_page","","Creates a mapping in the page tables with the given flags.…",39,[[["self"]],["virtualaddress"]]],[11,"map_page_guard","","Reserves a given page as guard page. This affects only…",39,[[["self"],["virtualaddress"]]]],[11,"map_range_page_guard","","Reserve a given region as guard pages. If the region spans…",39,[[["self"],["virtualaddress"],["usize"]]]],[11,"map_range","","Maps the given physical address range to the given virtual…",39,[[["self"],["physicaladdress"],["virtualaddress"],["usize"],["entryflags"]]]],[11,"map_range_allocate","","Maps a given number of consecutive pages at a given…",39,[[["self"],["virtualaddress"],["usize"],["entryflags"]]]],[11,"identity_map","","Maps a memory frame to the same virtual address",39,[[["self"],["frame"],["entryflags"]]]],[11,"identity_map_region","","Identity maps a range of frames",39,[[["self"],["physicaladdress"],["usize"],["entryflags"]]]],[11,"find_available_virtual_space","","Finds a virtual space hole that can contain page_nb…",39,[[["self"],["usize"]],["option",["virtualaddress"]]]],[11,"set_page_readonly","","Sets a previously mapped page as readonly",39,[[["self"],["virtualaddress"]]]],[11,"set_region_readonly","","Sets a previously mapped range of pages readonly",39,[[["self"],["virtualaddress"],["usize"]]]],[8,"Flusher","","A trait used to decide if the TLB cache should be flushed…",N,N],[11,"flush_cache","","",40,[[]]],[18,"WRITABLE","kfs_bootstrap::paging","",18,N],[18,"USER_ACCESSIBLE","","",18,N],[11,"empty","","Returns an empty set of flags.",18,[[],["entryflags"]]],[11,"all","","Returns the set containing all flags.",18,[[],["entryflags"]]],[11,"bits","","Returns the raw value of the flags currently stored.",18,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",18,[[["u32"]],["option",["entryflags"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",18,[[["u32"]],["entryflags"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",18,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",18,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",18,[[["self"],["entryflags"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",18,[[["self"],["entryflags"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",18,[[["self"],["entryflags"]]]],[11,"remove","","Removes the specified flags in-place.",18,[[["self"],["entryflags"]]]],[11,"toggle","","Toggles the specified flags in-place.",18,[[["self"],["entryflags"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",18,[[["self"],["entryflags"],["bool"]]]],[11,"get_table_address","kfs_bootstrap::paging::table","reduce recursive mapping by one time to get further down…",25,[[["self"],["usize"]],["pagestate",["usize"]]]],[11,"new","","",27,N],[11,"new","kfs_bootstrap::paging","Creates a new set of inactive page tables",16,[[],["inactivepagetables"]]],[11,"switch_to","","Switch to this page tables set. Returns the old active…",16,[[["self"]],["inactivepagetables"]]],[11,"delete","","",16,[[["self"]]]],[11,"delete_userspace","kfs_bootstrap::paging::table","",28,[[["self"]]]],[11,"copy_active_kernelspace","","Copies all the entries in the directory mapping tables…",28,[[["self"]]]],[11,"free_all_frames","","Frees all pages mapped by this table, and mark the frames…",29,[[["self"]]]],[11,"paging_off_create_page_set","kfs_bootstrap::paging","Used at startup when the paging is disabled and creating…",17,[[],["self"]]],[11,"enable_paging","","Enables paging with this tables as active tables",17,[[["self"]]]],[11,"init_directory","kfs_bootstrap::paging::table","Initializes the directory. This function does two things:",30,[[["self"]]]],[7,"ACTIVE_PAGE_TABLES","kfs_bootstrap::paging","Currently active page tables.",N,N],[17,"PAGE_SIZE","","The size of a single page.",N,N],[17,"ENTRY_COUNT","","",N,N],[8,"PageTablesSet","","",N,N],[10,"map_to","","Creates a mapping in the page tables with the given flags",39,[[["self"],["mappingtype"],["virtualaddress"]]]],[10,"get_phys","","Gets the current mapping state of this Virtual Address.",39,[[["self"],["virtualaddress"]],["pagestate",["physicaladdress"]]]],[10,"find_available_virtual_space_aligned","","Finds a virtual space hole that can contain page_nb…",39,[[["self"],["usize"],["usize"]],["option",["virtualaddress"]]]],[11,"print_mapping","kfs_bootstrap::paging::table","Prints the current mapping.",39,[[["self"]]]],[10,"unmap","kfs_bootstrap::paging","Deletes a mapping in the page tables, returning the Frame…",39,[[["self"],["virtualaddress"]],["pagestate",["frame"]]]],[11,"map_allocate_to","kfs_bootstrap::paging::table","Creates a mapping in the page tables with the given flags.…",39,[[["self"],["virtualaddress"],["entryflags"]]]],[11,"map_frame","","Maps a given frame in the page tables. Takes care of…",39,[[["self"],["frame"],["entryflags"]],["virtualaddress"]]],[11,"get_page","","Creates a mapping in the page tables with the given flags.…",39,[[["self"]],["virtualaddress"]]],[11,"map_page_guard","","Reserves a given page as guard page. This affects only…",39,[[["self"],["virtualaddress"]]]],[11,"map_range_page_guard","","Reserve a given region as guard pages. If the region spans…",39,[[["self"],["virtualaddress"],["usize"]]]],[11,"map_range","","Maps the given physical address range to the given virtual…",39,[[["self"],["physicaladdress"],["virtualaddress"],["usize"],["entryflags"]]]],[11,"map_range_allocate","","Maps a given number of consecutive pages at a given…",39,[[["self"],["virtualaddress"],["usize"],["entryflags"]]]],[11,"identity_map","","Maps a memory frame to the same virtual address",39,[[["self"],["frame"],["entryflags"]]]],[11,"identity_map_region","","Identity maps a range of frames",39,[[["self"],["physicaladdress"],["usize"],["entryflags"]]]],[11,"find_available_virtual_space","","Finds a virtual space hole that can contain page_nb…",39,[[["self"],["usize"]],["option",["virtualaddress"]]]],[11,"set_page_readonly","","Sets a previously mapped page as readonly",39,[[["self"],["virtualaddress"]]]],[11,"set_region_readonly","","Sets a previously mapped range of pages readonly",39,[[["self"],["virtualaddress"],["usize"]]]],[8,"VirtualSpaceLand","kfs_bootstrap::paging","A trait describing the splitting of virtual memory between…",N,N],[10,"start_addr","","The first address in this land.",41,[[],["virtualaddress"]]],[10,"end_addr","","The last address in this land.",41,[[],["virtualaddress"]]],[11,"start_table","","The index in page directory of the first table of this land",41,[[],["usize"]]],[11,"end_table","","The index in page directory of the last table of this land",41,[[],["usize"]]],[11,"start_addr","","",42,[[],["virtualaddress"]]],[11,"end_addr","","",42,[[],["virtualaddress"]]],[11,"start_addr","","",43,[[],["virtualaddress"]]],[11,"end_addr","","",43,[[],["virtualaddress"]]],[0,"frame_alloc","kfs_bootstrap","A module implementing a physical memory manager that…",N,N],[3,"AllocatorBitmap","kfs_bootstrap::frame_alloc","A big bitmap denoting for every frame if it is free or not",N,N],[12,"memory_bitmap","","",44,N],[12,"initialized","","",44,N],[3,"Frame","","A pointer to a physical frame",N,N],[12,"physical_addr","","",45,N],[12,"is_allocated","","",45,N],[3,"FrameAllocator","","A physical memory manger to allocate and free memory frames",N,N],[5,"addr_to_frame","","Gets the frame number from a physical address",N,[[["usize"]],["usize"]]],[5,"frame_to_addr","","Gets the physical address from a frame number",N,[[["usize"]],["usize"]]],[5,"round_to_page","","Rounds an address to its page address",N,[[["usize"]],["usize"]]],[5,"round_to_page_upper","","Rounds an address to the next page address except if its…",N,[[["usize"]],["usize"]]],[7,"FRAMES_BITMAP","","A big bitmap denoting for every frame if it is free or not",N,N],[17,"MEMORY_FRAME_SIZE","","A memory frame is the same size as a page",N,N],[17,"FRAME_OFFSET_MASK","","",N,N],[17,"FRAME_BASE_MASK","","",N,N],[17,"FRAME_BASE_LOG","","",N,N],[17,"FRAMES_BITMAP_SIZE","","The size of the frames_bitmap (~128ko)",N,N],[17,"FRAME_FREE","","",N,N],[17,"FRAME_OCCUPIED","","",N,N],[11,"address","","Get the physical address of this Frame",45,[[["self"]],["physicaladdress"]]],[11,"is_allocated","","Gets the current allocation state",45,[[["self"]],["bool"]]],[11,"from_physical_addr","","Constructs a frame structure from a physical address",45,[[["physicaladdress"]],["frame"]]],[11,"from_allocated_addr","","Constructs a frame structure from a physical address",45,[[["physicaladdress"]],["frame"]]],[11,"init","","Initialize the FrameAllocator by parsing the multiboot…",46,[[["bootinformation"]]]],[11,"check_initialized","","Panics if the frames bitmap was not initialized",46,[[["allocatorbitmap"]]]],[11,"mark_area_reserved","","Marks a physical memory area as reserved and will never…",46,N],[11,"mark_area_free","","Marks a physical memory area as free for frame allocation",46,N],[11,"alloc_frame","","Allocates a free frame",46,[[],["frame"]]],[11,"alloc_contiguous_frames","","Allocates count contiguous frames.",46,[[["usize"]],["physicaladdress"]]],[11,"free_frame","","Frees an allocated frame.",46,[[["frame"]]]],[0,"elf_loader","kfs_bootstrap","Loads the kernel in high memory",N,N],[5,"load_kernel","kfs_bootstrap::elf_loader","Loads the kernel in high memory Returns address of entry…",N,[[["pagingoffpageset"],["bootinformation"]],["usize"]]],[5,"load_segment","","Loads an elf segment by coping file_size bytes to the…",N,[[["pagingoffpageset"],["programheader"],["elffile"]]]],[0,"bootstrap_stack","kfs_bootstrap","Bootstrap stack",N,N],[3,"BootstrapStack","kfs_bootstrap::bootstrap_stack","A structure representing a kernel stack",N,N],[12,"stack_address","","",47,N],[17,"STACK_SIZE","","The size of a kernel stack, not accounting for the page…",N,N],[17,"STACK_SIZE_WITH_GUARD","","The size of the kernel stack, with the page guard.",N,N],[17,"STACK_ALIGNEMENT","","The alignment of the stack.…",N,N],[11,"allocate_stack","","Allocates the bootstrap stack",47,[[],["option",["bootstrapstack"]]]],[18,"STACK_POISON_SIZE","","We keep 2 poison pointers for fake saved ebp and saved esp…",47,N],[11,"create_poison_pointers","","Puts two poisons pointers at the base of the stack for the…",47,[[["self"]]]],[11,"get_stack_start","","Get the address of the beginning of usable stack. Used for…",47,[[["self"]],["usize"]]],[7,"STACK","kfs_bootstrap","The stack we start on.",N,N],[7,"MULTIBOOT_HEADER","","The multiboot header of our binary.",N,N],[11,"default","","",1,[[],["endtag"]]],[11,"new","","",2,[[["u32"],["u32"],["u32"]],["framebuffertag"]]],[11,"new","","",3,[[],["modulealignmenttag"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"from","kfs_bootstrap::bootstrap_logging","",48,[[["t"]],["t"]]],[11,"try_from","","",48,[[["u"]],["result"]]],[11,"try_into","","",48,[[["self"]],["result"]]],[11,"into","","",48,[[["self"]],["u"]]],[11,"borrow","","",48,[[["self"]],["t"]]],[11,"borrow_mut","","",48,[[["self"]],["t"]]],[11,"get_type_id","","",48,[[["self"]],["typeid"]]],[11,"from","kfs_bootstrap::gdt","",5,[[["t"]],["t"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"from","","",8,[[["t"]],["t"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"from","","",9,[[["t"]],["t"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"from","kfs_bootstrap::gdt::segment_selector","",10,[[["t"]],["t"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"from","kfs_bootstrap::gdt::i386","",11,[[["t"]],["t"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"from","","",12,[[["t"]],["t"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"from","kfs_bootstrap::gdt::i386::instructions::tables","",13,[[["t"]],["t"]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"into","","",13,[[["self"]],["u"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"from","kfs_bootstrap::address","",14,[[["t"]],["t"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"try_into","","",14,[[["self"]],["result"]]],[11,"into","","",14,[[["self"]],["u"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"get_type_id","","",14,[[["self"]],["typeid"]]],[11,"from","","",15,[[["t"]],["t"]]],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"try_into","","",15,[[["self"]],["result"]]],[11,"into","","",15,[[["self"]],["u"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"get_type_id","","",15,[[["self"]],["typeid"]]],[11,"from","kfs_bootstrap::paging","",49,[[["t"]],["t"]]],[11,"try_from","","",49,[[["u"]],["result"]]],[11,"try_into","","",49,[[["self"]],["result"]]],[11,"into","","",49,[[["self"]],["u"]]],[11,"borrow","","",49,[[["self"]],["t"]]],[11,"borrow_mut","","",49,[[["self"]],["t"]]],[11,"get_type_id","","",49,[[["self"]],["typeid"]]],[11,"from","","",16,[[["t"]],["t"]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"into","","",16,[[["self"]],["u"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"from","","",17,[[["t"]],["t"]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"into","","",17,[[["self"]],["u"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"get_type_id","","",17,[[["self"]],["typeid"]]],[11,"from","","",18,[[["t"]],["t"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"into","","",18,[[["self"]],["u"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"get_type_id","","",18,[[["self"]],["typeid"]]],[11,"from","","",42,[[["t"]],["t"]]],[11,"try_from","","",42,[[["u"]],["result"]]],[11,"try_into","","",42,[[["self"]],["result"]]],[11,"into","","",42,[[["self"]],["u"]]],[11,"borrow","","",42,[[["self"]],["t"]]],[11,"borrow_mut","","",42,[[["self"]],["t"]]],[11,"get_type_id","","",42,[[["self"]],["typeid"]]],[11,"from","","",43,[[["t"]],["t"]]],[11,"try_from","","",43,[[["u"]],["result"]]],[11,"try_into","","",43,[[["self"]],["result"]]],[11,"into","","",43,[[["self"]],["u"]]],[11,"borrow","","",43,[[["self"]],["t"]]],[11,"borrow_mut","","",43,[[["self"]],["t"]]],[11,"get_type_id","","",43,[[["self"]],["typeid"]]],[11,"from","","",19,[[["t"]],["t"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"try_into","","",19,[[["self"]],["result"]]],[11,"into","","",19,[[["self"]],["u"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"get_type_id","","",19,[[["self"]],["typeid"]]],[11,"from","kfs_bootstrap::paging::entry","",20,[[["t"]],["t"]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"try_into","","",20,[[["self"]],["result"]]],[11,"into","","",20,[[["self"]],["u"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"get_type_id","","",20,[[["self"]],["typeid"]]],[11,"from","","",21,[[["t"]],["t"]]],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"try_into","","",21,[[["self"]],["result"]]],[11,"into","","",21,[[["self"]],["u"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"get_type_id","","",21,[[["self"]],["typeid"]]],[11,"from","","",22,[[["t"]],["t"]]],[11,"try_from","","",22,[[["u"]],["result"]]],[11,"try_into","","",22,[[["self"]],["result"]]],[11,"into","","",22,[[["self"]],["u"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"get_type_id","","",22,[[["self"]],["typeid"]]],[11,"from","kfs_bootstrap::paging::table","",23,[[["t"]],["t"]]],[11,"try_from","","",23,[[["u"]],["result"]]],[11,"try_into","","",23,[[["self"]],["result"]]],[11,"into","","",23,[[["self"]],["u"]]],[11,"borrow","","",23,[[["self"]],["t"]]],[11,"borrow_mut","","",23,[[["self"]],["t"]]],[11,"get_type_id","","",23,[[["self"]],["typeid"]]],[11,"from","","",24,[[["t"]],["t"]]],[11,"try_from","","",24,[[["u"]],["result"]]],[11,"try_into","","",24,[[["self"]],["result"]]],[11,"into","","",24,[[["self"]],["u"]]],[11,"borrow","","",24,[[["self"]],["t"]]],[11,"borrow_mut","","",24,[[["self"]],["t"]]],[11,"get_type_id","","",24,[[["self"]],["typeid"]]],[11,"from","","",25,[[["t"]],["t"]]],[11,"try_from","","",25,[[["u"]],["result"]]],[11,"try_into","","",25,[[["self"]],["result"]]],[11,"into","","",25,[[["self"]],["u"]]],[11,"borrow","","",25,[[["self"]],["t"]]],[11,"borrow_mut","","",25,[[["self"]],["t"]]],[11,"get_type_id","","",25,[[["self"]],["typeid"]]],[11,"from","","",26,[[["t"]],["t"]]],[11,"try_from","","",26,[[["u"]],["result"]]],[11,"try_into","","",26,[[["self"]],["result"]]],[11,"into","","",26,[[["self"]],["u"]]],[11,"borrow","","",26,[[["self"]],["t"]]],[11,"borrow_mut","","",26,[[["self"]],["t"]]],[11,"get_type_id","","",26,[[["self"]],["typeid"]]],[11,"from","","",27,[[["t"]],["t"]]],[11,"try_from","","",27,[[["u"]],["result"]]],[11,"try_into","","",27,[[["self"]],["result"]]],[11,"into","","",27,[[["self"]],["u"]]],[11,"borrow","","",27,[[["self"]],["t"]]],[11,"borrow_mut","","",27,[[["self"]],["t"]]],[11,"get_type_id","","",27,[[["self"]],["typeid"]]],[11,"from","","",28,[[["t"]],["t"]]],[11,"try_from","","",28,[[["u"]],["result"]]],[11,"try_into","","",28,[[["self"]],["result"]]],[11,"into","","",28,[[["self"]],["u"]]],[11,"borrow","","",28,[[["self"]],["t"]]],[11,"borrow_mut","","",28,[[["self"]],["t"]]],[11,"get_type_id","","",28,[[["self"]],["typeid"]]],[11,"from","","",29,[[["t"]],["t"]]],[11,"try_from","","",29,[[["u"]],["result"]]],[11,"try_into","","",29,[[["self"]],["result"]]],[11,"into","","",29,[[["self"]],["u"]]],[11,"borrow","","",29,[[["self"]],["t"]]],[11,"borrow_mut","","",29,[[["self"]],["t"]]],[11,"get_type_id","","",29,[[["self"]],["typeid"]]],[11,"from","","",30,[[["t"]],["t"]]],[11,"try_from","","",30,[[["u"]],["result"]]],[11,"try_into","","",30,[[["self"]],["result"]]],[11,"into","","",30,[[["self"]],["u"]]],[11,"borrow","","",30,[[["self"]],["t"]]],[11,"borrow_mut","","",30,[[["self"]],["t"]]],[11,"get_type_id","","",30,[[["self"]],["typeid"]]],[11,"from","","",31,[[["t"]],["t"]]],[11,"try_from","","",31,[[["u"]],["result"]]],[11,"try_into","","",31,[[["self"]],["result"]]],[11,"into","","",31,[[["self"]],["u"]]],[11,"borrow","","",31,[[["self"]],["t"]]],[11,"borrow_mut","","",31,[[["self"]],["t"]]],[11,"get_type_id","","",31,[[["self"]],["typeid"]]],[11,"from","","",50,[[["t"]],["t"]]],[11,"try_from","","",50,[[["u"]],["result"]]],[11,"try_into","","",50,[[["self"]],["result"]]],[11,"into","","",50,[[["self"]],["u"]]],[11,"borrow","","",50,[[["self"]],["t"]]],[11,"borrow_mut","","",50,[[["self"]],["t"]]],[11,"get_type_id","","",50,[[["self"]],["typeid"]]],[11,"from","","",51,[[["t"]],["t"]]],[11,"try_from","","",51,[[["u"]],["result"]]],[11,"try_into","","",51,[[["self"]],["result"]]],[11,"into","","",51,[[["self"]],["u"]]],[11,"borrow","","",51,[[["self"]],["t"]]],[11,"borrow_mut","","",51,[[["self"]],["t"]]],[11,"get_type_id","","",51,[[["self"]],["typeid"]]],[11,"from","kfs_bootstrap::paging::table::entry","",32,[[["t"]],["t"]]],[11,"try_from","","",32,[[["u"]],["result"]]],[11,"try_into","","",32,[[["self"]],["result"]]],[11,"into","","",32,[[["self"]],["u"]]],[11,"borrow","","",32,[[["self"]],["t"]]],[11,"borrow_mut","","",32,[[["self"]],["t"]]],[11,"get_type_id","","",32,[[["self"]],["typeid"]]],[11,"from","","",33,[[["t"]],["t"]]],[11,"try_from","","",33,[[["u"]],["result"]]],[11,"try_into","","",33,[[["self"]],["result"]]],[11,"into","","",33,[[["self"]],["u"]]],[11,"borrow","","",33,[[["self"]],["t"]]],[11,"borrow_mut","","",33,[[["self"]],["t"]]],[11,"get_type_id","","",33,[[["self"]],["typeid"]]],[11,"from","","",34,[[["t"]],["t"]]],[11,"try_from","","",34,[[["u"]],["result"]]],[11,"try_into","","",34,[[["self"]],["result"]]],[11,"into","","",34,[[["self"]],["u"]]],[11,"borrow","","",34,[[["self"]],["t"]]],[11,"borrow_mut","","",34,[[["self"]],["t"]]],[11,"get_type_id","","",34,[[["self"]],["typeid"]]],[11,"from","kfs_bootstrap::frame_alloc","",44,[[["t"]],["t"]]],[11,"try_from","","",44,[[["u"]],["result"]]],[11,"try_into","","",44,[[["self"]],["result"]]],[11,"into","","",44,[[["self"]],["u"]]],[11,"borrow","","",44,[[["self"]],["t"]]],[11,"borrow_mut","","",44,[[["self"]],["t"]]],[11,"get_type_id","","",44,[[["self"]],["typeid"]]],[11,"from","","",45,[[["t"]],["t"]]],[11,"try_from","","",45,[[["u"]],["result"]]],[11,"try_into","","",45,[[["self"]],["result"]]],[11,"into","","",45,[[["self"]],["u"]]],[11,"borrow","","",45,[[["self"]],["t"]]],[11,"borrow_mut","","",45,[[["self"]],["t"]]],[11,"get_type_id","","",45,[[["self"]],["typeid"]]],[11,"from","","",46,[[["t"]],["t"]]],[11,"try_from","","",46,[[["u"]],["result"]]],[11,"try_into","","",46,[[["self"]],["result"]]],[11,"into","","",46,[[["self"]],["u"]]],[11,"borrow","","",46,[[["self"]],["t"]]],[11,"borrow_mut","","",46,[[["self"]],["t"]]],[11,"get_type_id","","",46,[[["self"]],["typeid"]]],[11,"from","kfs_bootstrap::bootstrap_stack","",47,[[["t"]],["t"]]],[11,"try_from","","",47,[[["u"]],["result"]]],[11,"try_into","","",47,[[["self"]],["result"]]],[11,"into","","",47,[[["self"]],["u"]]],[11,"borrow","","",47,[[["self"]],["t"]]],[11,"borrow_mut","","",47,[[["self"]],["t"]]],[11,"get_type_id","","",47,[[["self"]],["typeid"]]],[11,"entries","kfs_bootstrap::paging::table","",23,N],[11,"entries_mut","","",23,N],[11,"entries","","",24,N],[11,"entries_mut","","",24,N],[11,"entries","","",25,N],[11,"entries_mut","","",25,N],[11,"entries","","",26,N],[11,"entries_mut","","",26,N],[11,"entries","","",28,N],[11,"entries_mut","","",28,N],[11,"entries","","",29,N],[11,"entries_mut","","",29,N],[11,"entries","","",30,N],[11,"entries_mut","","",30,N],[11,"entries","","",31,N],[11,"entries_mut","","",31,N],[11,"get_table","","Gets a reference to a page table through recursive mapping",25,[[["self"],["usize"]],["pagestate",["smarthierarchicaltable"]]]],[11,"create_table","","Allocates a page table, zero it and add an entry to the…",25,[[["self"],["usize"]],["smarthierarchicaltable"]]],[11,"get_table","","Temporary map the table",28,[[["self"],["usize"]],["pagestate",["smarthierarchicaltable"]]]],[11,"create_table","","Allocates a page table, temporarily map it, zero it and…",28,[[["self"],["usize"]],["smarthierarchicaltable"]]],[11,"get_table","","Simply cast pointed frame as PageTable",30,[[["self"],["usize"]],["pagestate",["smarthierarchicaltable"]]]],[11,"create_table","","Allocates a page table, zero it and add an entry to the…",30,[[["self"],["usize"]],["smarthierarchicaltable"]]],[11,"get_directory","kfs_bootstrap::paging","",49,[[["self"]],["smarthierarchicaltable",["activepagedirectory"]]]],[11,"get_directory","","Temporary map the directory",16,[[["self"]],["smarthierarchicaltable",["inactivepagedirectory"]]]],[11,"get_directory","","",17,[[["self"]],["smarthierarchicaltable"]]],[11,"flush_cache","kfs_bootstrap::paging::table","",50,[[]]],[11,"flush_cache","","",51,[[]]],[11,"start_addr","kfs_bootstrap::paging","",42,[[],["virtualaddress"]]],[11,"end_addr","","",42,[[],["virtualaddress"]]],[11,"start_addr","","",43,[[],["virtualaddress"]]],[11,"end_addr","","",43,[[],["virtualaddress"]]],[11,"PRESENT","kfs_bootstrap::paging::entry","",20,[[["self"]],["bool"]]],[11,"WRITABLE","","",20,[[["self"]],["bool"]]],[11,"USER_ACCESSIBLE","","",20,[[["self"]],["bool"]]],[11,"WRITE_THROUGH","","",20,[[["self"]],["bool"]]],[11,"NO_CACHE","","",20,[[["self"]],["bool"]]],[11,"ACCESSED","","",20,[[["self"]],["bool"]]],[11,"DIRTY","","",20,[[["self"]],["bool"]]],[11,"HUGE_PAGE","","",20,[[["self"]],["bool"]]],[11,"GLOBAL","","",20,[[["self"]],["bool"]]],[11,"GUARD_PAGE","","",20,[[["self"]],["bool"]]],[11,"IS_FRAME_ALLOC","","",20,[[["self"]],["bool"]]],[11,"USER_DEFINED_3","","",20,[[["self"]],["bool"]]],[11,"PRESENT","","",20,[[],["u32"]]],[11,"WRITABLE","","",20,[[],["u32"]]],[11,"USER_ACCESSIBLE","","",20,[[],["u32"]]],[11,"WRITE_THROUGH","","",20,[[],["u32"]]],[11,"NO_CACHE","","",20,[[],["u32"]]],[11,"ACCESSED","","",20,[[],["u32"]]],[11,"DIRTY","","",20,[[],["u32"]]],[11,"HUGE_PAGE","","",20,[[],["u32"]]],[11,"GLOBAL","","",20,[[],["u32"]]],[11,"GUARD_PAGE","","",20,[[],["u32"]]],[11,"IS_FRAME_ALLOC","","",20,[[],["u32"]]],[11,"USER_DEFINED_3","","",20,[[],["u32"]]],[11,"PRESENT","kfs_bootstrap::paging::table::entry","",32,[[["self"]],["bool"]]],[11,"WRITABLE","","",32,[[["self"]],["bool"]]],[11,"USER_ACCESSIBLE","","",32,[[["self"]],["bool"]]],[11,"WRITE_THROUGH","","",32,[[["self"]],["bool"]]],[11,"NO_CACHE","","",32,[[["self"]],["bool"]]],[11,"ACCESSED","","",32,[[["self"]],["bool"]]],[11,"DIRTY","","",32,[[["self"]],["bool"]]],[11,"HUGE_PAGE","","",32,[[["self"]],["bool"]]],[11,"GLOBAL","","",32,[[["self"]],["bool"]]],[11,"GUARD_PAGE","","",32,[[["self"]],["bool"]]],[11,"IS_FRAME_ALLOC","","",32,[[["self"]],["bool"]]],[11,"USER_DEFINED_3","","",32,[[["self"]],["bool"]]],[11,"PRESENT","","",32,[[],["u32"]]],[11,"WRITABLE","","",32,[[],["u32"]]],[11,"USER_ACCESSIBLE","","",32,[[],["u32"]]],[11,"WRITE_THROUGH","","",32,[[],["u32"]]],[11,"NO_CACHE","","",32,[[],["u32"]]],[11,"ACCESSED","","",32,[[],["u32"]]],[11,"DIRTY","","",32,[[],["u32"]]],[11,"HUGE_PAGE","","",32,[[],["u32"]]],[11,"GLOBAL","","",32,[[],["u32"]]],[11,"GUARD_PAGE","","",32,[[],["u32"]]],[11,"IS_FRAME_ALLOC","","",32,[[],["u32"]]],[11,"USER_DEFINED_3","","",32,[[],["u32"]]],[11,"WRITABLE","kfs_bootstrap::paging","",18,[[["self"]],["bool"]]],[11,"USER_ACCESSIBLE","","",18,[[["self"]],["bool"]]],[11,"WRITABLE","","",18,[[],["u32"]]],[11,"USER_ACCESSIBLE","","",18,[[],["u32"]]],[11,"fmt","kfs_bootstrap::address","",14,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","kfs_bootstrap::gdt::segment_selector","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::gdt::i386","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::gdt","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::address","",14,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","kfs_bootstrap::paging::entry","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",21,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",22,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::paging::table::entry","",32,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",33,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",34,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::paging","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::frame_alloc","",45,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::bootstrap_stack","",47,[[["self"],["formatter"]],["result"]]],[11,"eq","kfs_bootstrap::gdt::i386","",12,[[["self"],["privilegelevel"]],["bool"]]],[11,"eq","kfs_bootstrap::address","",14,[[["self"],["physicaladdress"]],["bool"]]],[11,"ne","","",14,[[["self"],["physicaladdress"]],["bool"]]],[11,"eq","","",15,[[["self"],["virtualaddress"]],["bool"]]],[11,"ne","","",15,[[["self"],["virtualaddress"]],["bool"]]],[11,"eq","kfs_bootstrap::paging::entry","",20,[[["self"],["entryflags"]],["bool"]]],[11,"ne","","",20,[[["self"],["entryflags"]],["bool"]]],[11,"eq","kfs_bootstrap::paging::table::entry","",32,[[["self"],["entryflags"]],["bool"]]],[11,"ne","","",32,[[["self"],["entryflags"]],["bool"]]],[11,"eq","kfs_bootstrap::paging","",18,[[["self"],["entryflags"]],["bool"]]],[11,"ne","","",18,[[["self"],["entryflags"]],["bool"]]],[11,"assert_receiver_is_total_eq","kfs_bootstrap::gdt::i386","",12,N],[11,"assert_receiver_is_total_eq","kfs_bootstrap::address","",14,N],[11,"assert_receiver_is_total_eq","","",15,N],[11,"assert_receiver_is_total_eq","kfs_bootstrap::paging::entry","",20,N],[11,"assert_receiver_is_total_eq","kfs_bootstrap::paging::table::entry","",32,N],[11,"assert_receiver_is_total_eq","kfs_bootstrap::paging","",18,N],[11,"cmp","kfs_bootstrap::address","",14,[[["self"],["physicaladdress"]],["ordering"]]],[11,"cmp","","",15,[[["self"],["virtualaddress"]],["ordering"]]],[11,"cmp","kfs_bootstrap::paging::entry","",20,[[["self"],["entryflags"]],["ordering"]]],[11,"cmp","kfs_bootstrap::paging::table::entry","",32,[[["self"],["entryflags"]],["ordering"]]],[11,"cmp","kfs_bootstrap::paging","",18,[[["self"],["entryflags"]],["ordering"]]],[11,"partial_cmp","kfs_bootstrap::address","",14,[[["self"],["physicaladdress"]],["option",["ordering"]]]],[11,"lt","","",14,[[["self"],["physicaladdress"]],["bool"]]],[11,"le","","",14,[[["self"],["physicaladdress"]],["bool"]]],[11,"gt","","",14,[[["self"],["physicaladdress"]],["bool"]]],[11,"ge","","",14,[[["self"],["physicaladdress"]],["bool"]]],[11,"partial_cmp","","",15,[[["self"],["virtualaddress"]],["option",["ordering"]]]],[11,"lt","","",15,[[["self"],["virtualaddress"]],["bool"]]],[11,"le","","",15,[[["self"],["virtualaddress"]],["bool"]]],[11,"gt","","",15,[[["self"],["virtualaddress"]],["bool"]]],[11,"ge","","",15,[[["self"],["virtualaddress"]],["bool"]]],[11,"partial_cmp","kfs_bootstrap::paging::entry","",20,[[["self"],["entryflags"]],["option",["ordering"]]]],[11,"lt","","",20,[[["self"],["entryflags"]],["bool"]]],[11,"le","","",20,[[["self"],["entryflags"]],["bool"]]],[11,"gt","","",20,[[["self"],["entryflags"]],["bool"]]],[11,"ge","","",20,[[["self"],["entryflags"]],["bool"]]],[11,"partial_cmp","kfs_bootstrap::paging::table::entry","",32,[[["self"],["entryflags"]],["option",["ordering"]]]],[11,"lt","","",32,[[["self"],["entryflags"]],["bool"]]],[11,"le","","",32,[[["self"],["entryflags"]],["bool"]]],[11,"gt","","",32,[[["self"],["entryflags"]],["bool"]]],[11,"ge","","",32,[[["self"],["entryflags"]],["bool"]]],[11,"partial_cmp","kfs_bootstrap::paging","",18,[[["self"],["entryflags"]],["option",["ordering"]]]],[11,"lt","","",18,[[["self"],["entryflags"]],["bool"]]],[11,"le","","",18,[[["self"],["entryflags"]],["bool"]]],[11,"gt","","",18,[[["self"],["entryflags"]],["bool"]]],[11,"ge","","",18,[[["self"],["entryflags"]],["bool"]]],[11,"hash","kfs_bootstrap::address","",14,N],[11,"hash","","",15,N],[11,"hash","kfs_bootstrap::paging::entry","",20,N],[11,"hash","kfs_bootstrap::paging::table::entry","",32,N],[11,"hash","kfs_bootstrap::paging","",18,N],[11,"add","kfs_bootstrap::address","Adding a length to an address gives another address",15,[[["self"],["usize"]],["virtualaddress"]]],[11,"add","","Adding a length to an address gives another address",14,[[["self"],["usize"]],["physicaladdress"]]],[11,"sub","","Subtracting a length from an address gives another address",15,[[["self"],["usize"]],["virtualaddress"]]],[11,"sub","","Subtracting a length from an address gives another address",14,[[["self"],["usize"]],["physicaladdress"]]],[11,"sub","","Subtracting two address gives their distance",15,[[["self"],["virtualaddress"]],["usize"]]],[11,"sub","","Subtracting two address gives their distance",14,[[["self"],["physicaladdress"]],["usize"]]],[11,"sub","kfs_bootstrap::paging::entry","Returns the set difference of the two sets of flags.",20,[[["self"],["entryflags"]],["entryflags"]]],[11,"sub","kfs_bootstrap::paging::table::entry","Returns the set difference of the two sets of flags.",32,[[["self"],["entryflags"]],["entryflags"]]],[11,"sub","kfs_bootstrap::paging","Returns the set difference of the two sets of flags.",18,[[["self"],["entryflags"]],["entryflags"]]],[11,"add_assign","kfs_bootstrap::address","Adding a length to an address gives another address",15,[[["self"],["usize"]]]],[11,"add_assign","","Adding a length to an address gives another address",14,[[["self"],["usize"]]]],[11,"sub_assign","","Subtracting a length from an address gives another address",15,[[["self"],["usize"]]]],[11,"sub_assign","","Subtracting a length from an address gives another address",14,[[["self"],["usize"]]]],[11,"sub_assign","kfs_bootstrap::paging::entry","Disables all flags enabled in the set.",20,[[["self"],["entryflags"]]]],[11,"sub_assign","kfs_bootstrap::paging::table::entry","Disables all flags enabled in the set.",32,[[["self"],["entryflags"]]]],[11,"sub_assign","kfs_bootstrap::paging","Disables all flags enabled in the set.",18,[[["self"],["entryflags"]]]],[11,"not","kfs_bootstrap::paging::entry","Returns the complement of this set of flags.",20,[[["self"]],["entryflags"]]],[11,"not","kfs_bootstrap::paging::table::entry","Returns the complement of this set of flags.",32,[[["self"]],["entryflags"]]],[11,"not","kfs_bootstrap::paging","Returns the complement of this set of flags.",18,[[["self"]],["entryflags"]]],[11,"bitand","kfs_bootstrap::paging::entry","Returns the intersection between the two sets of flags.",20,[[["self"],["entryflags"]],["entryflags"]]],[11,"bitand","kfs_bootstrap::paging::table::entry","Returns the intersection between the two sets of flags.",32,[[["self"],["entryflags"]],["entryflags"]]],[11,"bitand","kfs_bootstrap::paging","Returns the intersection between the two sets of flags.",18,[[["self"],["entryflags"]],["entryflags"]]],[11,"bitor","kfs_bootstrap::paging::entry","Returns the union of the two sets of flags.",20,[[["self"],["entryflags"]],["entryflags"]]],[11,"bitor","kfs_bootstrap::paging::table::entry","Returns the union of the two sets of flags.",32,[[["self"],["entryflags"]],["entryflags"]]],[11,"bitor","kfs_bootstrap::paging","Returns the union of the two sets of flags.",18,[[["self"],["entryflags"]],["entryflags"]]],[11,"bitxor","kfs_bootstrap::paging::entry","Returns the left flags, but with all the right flags…",20,[[["self"],["entryflags"]],["entryflags"]]],[11,"bitxor","kfs_bootstrap::paging::table::entry","Returns the left flags, but with all the right flags…",32,[[["self"],["entryflags"]],["entryflags"]]],[11,"bitxor","kfs_bootstrap::paging","Returns the left flags, but with all the right flags…",18,[[["self"],["entryflags"]],["entryflags"]]],[11,"bitand_assign","kfs_bootstrap::paging::entry","Disables all flags disabled in the set.",20,[[["self"],["entryflags"]]]],[11,"bitand_assign","kfs_bootstrap::paging::table::entry","Disables all flags disabled in the set.",32,[[["self"],["entryflags"]]]],[11,"bitand_assign","kfs_bootstrap::paging","Disables all flags disabled in the set.",18,[[["self"],["entryflags"]]]],[11,"bitor_assign","kfs_bootstrap::paging::entry","Adds the set of flags.",20,[[["self"],["entryflags"]]]],[11,"bitor_assign","kfs_bootstrap::paging::table::entry","Adds the set of flags.",32,[[["self"],["entryflags"]]]],[11,"bitor_assign","kfs_bootstrap::paging","Adds the set of flags.",18,[[["self"],["entryflags"]]]],[11,"bitxor_assign","kfs_bootstrap::paging::entry","Toggles the set of flags.",20,[[["self"],["entryflags"]]]],[11,"bitxor_assign","kfs_bootstrap::paging::table::entry","Toggles the set of flags.",32,[[["self"],["entryflags"]]]],[11,"bitxor_assign","kfs_bootstrap::paging","Toggles the set of flags.",18,[[["self"],["entryflags"]]]],[11,"deref","kfs_bootstrap::gdt","",5,[[["self"]],["tssstruct"]]],[11,"deref","","",6,[[["self"]],["tssstruct"]]],[11,"deref","kfs_bootstrap::paging::table","",25,N],[11,"deref","","",26,N],[11,"deref","","",27,[[["self"]],["t"]]],[11,"deref","","",28,N],[11,"deref","","",29,N],[11,"deref","","",30,N],[11,"deref","","",31,N],[11,"deref_mut","","",25,N],[11,"deref_mut","","",26,N],[11,"deref_mut","","",27,[[["self"]],["t"]]],[11,"deref_mut","","",28,N],[11,"deref_mut","","",29,N],[11,"deref_mut","","",30,N],[11,"deref_mut","","",31,N],[11,"drop","","",27,[[["self"]]]],[11,"drop","","",28,[[["self"]]]],[11,"drop","","",29,[[["self"]]]],[11,"drop","kfs_bootstrap::frame_alloc","",45,[[["self"]]]],[11,"index","kfs_bootstrap::paging::table","",24,[[["self"],["usize"]],["entry"]]],[11,"index","","",23,[[["self"],["usize"]],["entry"]]],[11,"index","","",25,[[["self"],["usize"]],["entry"]]],[11,"index","","",26,[[["self"],["usize"]],["entry"]]],[11,"index","","",28,[[["self"],["usize"]],["entry"]]],[11,"index","","",29,[[["self"],["usize"]],["entry"]]],[11,"index","","",30,[[["self"],["usize"]],["entry"]]],[11,"index","","",31,[[["self"],["usize"]],["entry"]]],[11,"index_mut","","",24,[[["self"],["usize"]],["entry"]]],[11,"index_mut","","",23,[[["self"],["usize"]],["entry"]]],[11,"index_mut","","",25,[[["self"],["usize"]],["entry"]]],[11,"index_mut","","",26,[[["self"],["usize"]],["entry"]]],[11,"index_mut","","",28,[[["self"],["usize"]],["entry"]]],[11,"index_mut","","",29,[[["self"],["usize"]],["entry"]]],[11,"index_mut","","",30,[[["self"],["usize"]],["entry"]]],[11,"index_mut","","",31,[[["self"],["usize"]],["entry"]]],[11,"extend","kfs_bootstrap::paging::entry","",20,[[["self"],["t"]]]],[11,"extend","kfs_bootstrap::paging::table::entry","",32,[[["self"],["t"]]]],[11,"extend","kfs_bootstrap::paging","",18,[[["self"],["t"]]]],[11,"from_iter","kfs_bootstrap::paging::entry","",20,[[["t"]],["entryflags"]]],[11,"from_iter","kfs_bootstrap::paging::table::entry","",32,[[["t"]],["entryflags"]]],[11,"from_iter","kfs_bootstrap::paging","",18,[[["t"]],["entryflags"]]],[11,"from","kfs_bootstrap::paging::entry","",20,[[["entryflags"]],["entryflags"]]],[11,"from","kfs_bootstrap::paging::table::entry","",32,[[["entryflags"]],["entryflags"]]],[11,"write_str","kfs_bootstrap::bootstrap_logging","Writes a string to COM1.",48,[[["self"],["str"]],["result",["error"]]]],[11,"fmt","kfs_bootstrap::paging::entry","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::paging::table::entry","",32,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::paging","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::paging::entry","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::paging::table::entry","",32,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::paging","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::address","",14,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","kfs_bootstrap::paging::entry","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::paging::table::entry","",32,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::paging","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::paging::entry","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::paging::table::entry","",32,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::paging","",18,[[["self"],["formatter"]],["result"]]],[11,"clone","kfs_bootstrap::gdt::i386","",12,[[["self"]],["privilegelevel"]]],[11,"clone","","",11,[[["self"]],["tssstruct"]]],[11,"clone","kfs_bootstrap::gdt","",9,[[["self"]],["systemdescriptortypes"]]],[11,"clone","","",8,[[["self"]],["descriptortableentry"]]],[11,"clone","kfs_bootstrap::address","",14,[[["self"]],["physicaladdress"]]],[11,"clone","","",15,[[["self"]],["virtualaddress"]]],[11,"clone","kfs_bootstrap::paging::entry","",20,[[["self"]],["entryflags"]]],[11,"clone","","",21,[[["self"]],["entry"]]],[11,"clone","kfs_bootstrap::paging::table::entry","",32,[[["self"]],["entryflags"]]],[11,"clone","","",33,[[["self"]],["entry"]]],[11,"clone","kfs_bootstrap::paging","",18,[[["self"]],["entryflags"]]],[11,"default","kfs_bootstrap::gdt::i386","",11,[[],["tssstruct"]]],[11,"initialize","kfs_bootstrap::gdt","",5,[[["self"]]]],[11,"initialize","","",6,[[["self"]]]]],"paths":[[3,"AlignedStack"],[3,"EndTag"],[3,"FramebufferTag"],[3,"ModuleAlignmentTag"],[3,"MultiBootHeader"],[3,"MAIN_TASK"],[3,"FAULT_TASK"],[3,"DescriptorTable"],[3,"DescriptorTableEntry"],[4,"SystemDescriptorTypes"],[3,"SegmentSelector"],[3,"TssStruct"],[4,"PrivilegeLevel"],[3,"DescriptorTablePointer"],[3,"PhysicalAddress"],[3,"VirtualAddress"],[3,"InactivePageTables"],[3,"PagingOffPageSet"],[3,"EntryFlags"],[4,"MappingType"],[3,"EntryFlags"],[3,"Entry"],[4,"PageState"],[3,"PageTable"],[3,"PageDirectory"],[3,"ActivePageDirectory"],[3,"ActivePageTable"],[3,"SmartHierarchicalTable"],[3,"InactivePageDirectory"],[3,"InactivePageTable"],[3,"PagingOffDirectory"],[3,"PagingOffTable"],[3,"EntryFlags"],[3,"Entry"],[4,"PageState"],[8,"I386PageTablesSet"],[8,"HierarchicalTable"],[8,"PageTableTrait"],[8,"PageDirectoryTrait"],[8,"PageTablesSet"],[8,"Flusher"],[8,"VirtualSpaceLand"],[3,"KernelLand"],[3,"UserLand"],[3,"AllocatorBitmap"],[3,"Frame"],[3,"FrameAllocator"],[3,"BootstrapStack"],[3,"Serial"],[3,"ActivePageTables"],[3,"TlbFlush"],[3,"NoFlush"]]};
searchIndex["kfs_clock"]={"doc":"Clock applet","items":[[3,"Rtc","kfs_clock","",N,N],[12,"command","","",0,N],[12,"data","","",0,N],[5,"get_day_of_week","","",N,[[["u8"]],["str"]]],[5,"get_month","","",N,[[["u8"]],["str"]]],[5,"main","","",N,[[]]],[7,"IOPORTS_PERMS","","Array of IO port this process is allowed to access.",N,N],[11,"new","","",0,[[],["rtc"]]],[11,"read_reg","","",0,[[["self"],["u8"]],["u8"]]],[11,"write_reg","","",0,[[["self"],["u8"],["u8"]]]],[11,"enable_update_ended_int","","",0,[[["self"]]]],[11,"read_interrupt_kind","","",0,[[["self"]],["u8"]]],[11,"is_12hr_clock","","",0,[[["self"]],["bool"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]]],"paths":[[3,"Rtc"]]};
searchIndex["kfs_kernel"]={"doc":"KFS","items":[[5,"force_double_fault","kfs_kernel","",N,[[]]],[5,"main","","",N,[[]]],[5,"start","","The entry point of our kernel.",N,N],[5,"common_start","","CRT0 starts here.",N,N],[5,"eh_personality","","The exception handling personality function for use in the…",N,[[]]],[5,"do_panic","","The kernel panic function.",N,N],[5,"panic_fmt","","Function called on `panic!` invocation.",N,N],[0,"paging","","Paging.",N,N],[3,"MappingFlags","kfs_kernel::paging","The flags of a mapping.",N,N],[12,"bits","","",0,N],[4,"PageState","","A hierarchical paging is composed of entries. An entry can…",N,N],[13,"Available","","Available, aka unused. Will page fault on use.",1,N],[13,"Guarded","","Guarded. Reserved and will cause a pagefault on use. Used…",1,N],[13,"Present","","Present. Used and has a backing physical address.",1,N],[5,"read_cr2","","Reads the value of cr2, retrieving the address that caused…",N,[[],["virtualaddress"]]],[0,"process_memory","","The management of a process' memory",N,N],[3,"ProcessMemory","kfs_kernel::paging::process_memory","The struct representing a process' memory, stored in the…",N,N],[12,"userspace_bookkeping","","The list of mappings in this address space.",2,N],[12,"table_hierarchy","","The architecture-dependent paging hierarchy.",2,N],[12,"heap_base_address","","The start of the heap of this process. The heap is managed…",2,N],[4,"QueryMemory","","Because we do not store Available mappings internally, we…",N,N],[13,"Available","","",3,N],[13,"Used","","",3,N],[4,"DynamicHierarchy","","",N,N],[13,"Active","","",4,N],[13,"Inactive","","",4,N],[11,"new","","Creates a ProcessMemory, allocating the…",2,[[],["self"]]],[11,"from_active_page_tables","","Creates a ProcessMemory referencing the current page…",2,[[],["self"]]],[11,"get_hierarchy","","If these tables are the one currently in use, we return…",2,[[["self"]],["dynamichierarchy"]]],[11,"map_phys_region_to","","Maps a single physical regions to a given virtual address.…",2,[[["self"],["physicalmemregion"],["virtualaddress"],["mappingflags"]],["result",["kernelerror"]]]],[11,"create_regular_mapping","","Allocates the physical regions, and maps them to specified…",2,[[["self"],["virtualaddress"],["usize"],["mappingflags"]],["result",["kernelerror"]]]],[11,"map_shared_mapping","","Maps a previously created shared mapping to specified…",2,[[["self"],["arc",["vec"]],["virtualaddress"],["mappingflags"]],["result",["kernelerror"]]]],[11,"guard","","Guards a range of addresses",2,[[["self"],["virtualaddress"],["usize"]],["result",["kernelerror"]]]],[11,"unmap","","Deletes a mapping in the page tables.",2,[[["self"],["virtualaddress"],["usize"]],["result",["mapping","kernelerror"]]]],[11,"query_memory","","Reads the state of the mapping at a given address",2,[[["self"],["virtualaddress"]],["result",["querymemory","kernelerror"]]]],[11,"shrink_mapping","","Shrink the mapping at `address` to `new_size`.",2,[[["self"],["virtualaddress"],["usize"]],["result",["option","kernelerror"]]]],[11,"expand_mapping","","Expand the mapping at `address` to `new_size`.",2,[[["self"],["virtualaddress"],["usize"]],["result",["kernelerror"]]]],[11,"find_available_space","","Finds a hole in virtual space at least `length` long.",2,[[["self"],["usize"]],["result",["virtualaddress","kernelerror"]]]],[11,"mirror_mapping","","Retrieves the mapping that `address` falls into, and…",2,[[["self"],["virtualaddress"],["usize"]],["result",["crossprocessmapping","kernelerror"]]]],[11,"resize_heap","","Resize the heap of this process, just like a brk. It can…",2,[[["self"],["usize"]],["result",["virtualaddress","kernelerror"]]]],[11,"switch_to","","Switches to this process memory",2,[[["self"]]]],[0,"kernel_memory","kfs_kernel::paging","The management of kernel memory",N,N],[3,"KernelMemory","kfs_kernel::paging::kernel_memory","A struct that acts on KernelLand and RecursiveTablesLand.",N,N],[12,"tables","","",5,N],[5,"get_kernel_memory","","Locks the KERNEL_MEMORY",N,[[],["mutexguard",["kernelmemory"]]]],[7,"KERNEL_MEMORY","","A mutex protecting the KernelMemory manager.",N,N],[11,"find_virtual_space_aligned","","Finds a hole in the virtual space at least 'length' long,…",5,[[["self"],["usize"],["usize"]],["result",["virtualaddress","kernelerror"]]]],[11,"find_virtual_space","","Finds a hole in the virtual space at least 'length' long.",5,[[["self"],["usize"]],["result",["virtualaddress","kernelerror"]]]],[11,"map_phys_region_to","","Maps a single physical regions to a given virtual address.",5,[[["self"],["physicalmemregion"],["virtualaddress"],["mappingflags"]]]],[11,"map_phys_region","","Maps a single physical region anywhere.",5,[[["self"],["physicalmemregion"],["mappingflags"]],["virtualaddress"]]],[11,"map_phys_regions","","Maps a list of physical region anywhere.",5,N],[11,"map_frame_iterator_to","","Maps a list of physical region yielded by an iterator.",5,[[["self"],["i"],["virtualaddress"],["mappingflags"]]]],[11,"map_frame_iterator","","Maps a list of physical region yielded by the iterator.…",5,[[["self"],["i"],["mappingflags"]],["virtualaddress"]]],[11,"get_page","","Allocates and maps a single page, choosing a spot in VMEM…",5,[[["self"]],["virtualaddress"]]],[11,"map_allocate_to","","Allocates non-contiguous frames, and map them at the given…",5,[[["self"],["virtualaddress"],["usize"],["mappingflags"]]]],[11,"get_pages","","Allocates and maps the given length, chosing a spot in…",5,[[["self"],["usize"]],["virtualaddress"]]],[11,"guard","","Guards a range of addresses.",5,[[["self"],["virtualaddress"],["usize"]]]],[11,"mapping_state","","Reads the state of the mapping at a given address.",5,[[["self"],["virtualaddress"]],["pagestate",["physicaladdress"]]]],[11,"unmap","","Deletes a mapping in the page tables. This functions…",5,[[["self"],["virtualaddress"],["usize"]]]],[11,"unmap_no_dealloc","","Deletes a mapping in the page tables, but does not free…",5,[[["self"],["virtualaddress"],["usize"]]]],[11,"reserve_kernel_land_frames","","Marks all frames mapped in KernelLand as reserve This is…",5,[[["self"]]]],[11,"get_hierarchy","","Safe access to the active page tables.",5,[[["self"]],["activehierarchy"]]],[11,"dump_kernelland_state","","Prints the state of the KernelLand by parsing the page…",5,[[["self"]]]],[0,"lands","kfs_kernel::paging","Module describing the split between the UserSpace and…",N,N],[3,"KernelLand","kfs_kernel::paging::lands","The virtual memory belonging to kernel",N,N],[3,"UserLand","","The virtual memory belonging to user",N,N],[3,"RecursiveTablesLand","","The virtual memory pointing to active page tables by…",N,N],[5,"__land_assertions","","",N,[[]]],[8,"VirtualSpaceLand","","A trait describing the splitting of virtual memory between…",N,N],[10,"start_addr","","The first address in this land.",6,[[],["virtualaddress"]]],[10,"end_addr","","The last address in this land.",6,[[],["virtualaddress"]]],[11,"length","","The length of this land.",6,[[],["usize"]]],[11,"start_table","","The index in page directory of the first table of this land.",6,[[],["usize"]]],[11,"end_table","","The index in page directory of the last table of this land.",6,[[],["usize"]]],[11,"contains_address","","Is the address contained in this Land ?",6,[[["virtualaddress"]],["bool"]]],[11,"contains_region","","Is the region fully contained in this Land ?",6,[[["virtualaddress"],["usize"]],["bool"]]],[11,"check_contains_address","","Checks that a given address falls in this land, or return…",6,[[["virtualaddress"]],["result",["kernelerror"]]]],[11,"check_contains_region","","Checks that a given region falls in this land, or return…",6,[[["virtualaddress"],["usize"]],["result",["kernelerror"]]]],[11,"start_addr","","",7,[[],["virtualaddress"]]],[11,"end_addr","","",7,[[],["virtualaddress"]]],[11,"start_addr","","",8,[[],["virtualaddress"]]],[11,"end_addr","","",8,[[],["virtualaddress"]]],[11,"start_addr","","",9,[[],["virtualaddress"]]],[11,"end_addr","","",9,[[],["virtualaddress"]]],[0,"mapping","kfs_kernel::paging","Mapping",N,N],[3,"Mapping","kfs_kernel::paging::mapping","A memory mapping. Stores the address, the length, and the…",N,N],[12,"address","","",10,N],[12,"length","","",10,N],[12,"mtype","","",10,N],[12,"flags","","",10,N],[4,"MappingType","","The types that a UserSpace mapping can be in.",N,N],[13,"Available","","Available, nothing is stored there. Accessing to it will…",11,N],[13,"Guarded","","Guarded, like Available, but nothing can be allocated…",11,N],[13,"Regular","","Regular, a region known only by this process. Access…",11,N],[13,"Shared","","Shared, a region that can be mapped in multiple processes.…",11,N],[13,"SystemReserved","","SystemReserved, used to denote the KernelLand and other…",11,N],[11,"new_regular","","Tries to construct a regular mapping.",10,[[["virtualaddress"],["vec",["physicalmemregion"]],["mappingflags"]],["result",["mapping","kernelerror"]]]],[11,"new_shared","","Tries to construct a shared mapping.",10,[[["virtualaddress"],["arc",["vec"]],["mappingflags"]],["result",["mapping","kernelerror"]]]],[11,"new_guard","","Tries to construct a guarded mapping.",10,[[["virtualaddress"],["usize"]],["result",["mapping","kernelerror"]]]],[11,"new_available","","Tries to construct an available mapping.",10,[[["virtualaddress"],["usize"]],["result",["mapping","kernelerror"]]]],[11,"new_system_reserved","","Tries to construct a system reserved mapping.",10,[[["virtualaddress"],["usize"]],["result",["mapping","kernelerror"]]]],[11,"address","","Returns the address of this mapping.",10,[[["self"]],["virtualaddress"]]],[11,"length","","Returns the address of this mapping.",10,[[["self"]],["usize"]]],[11,"mtype_ref","","Returns a reference to the type of this mapping.",10,[[["self"]],["mappingtype"]]],[11,"mtype","","Returns the type of this mapping.",10,[[["self"]],["mappingtype"]]],[11,"flags","","Returns the type of this mapping.",10,[[["self"]],["mappingflags"]]],[0,"cross_process","kfs_kernel::paging","Cross Process Mapping",N,N],[3,"CrossProcessMapping","kfs_kernel::paging::cross_process","A struct representing a UserLand mapping temporarily…",N,N],[12,"kernel_address","","",12,N],[12,"len","","",12,N],[12,"mapping","","",12,N],[11,"mirror_mapping","","Creates a CrossProcessMapping.",12,[[["mapping"],["usize"],["usize"]],["result",["crossprocessmapping","kernelerror"]]]],[11,"addr","","The address of the region asked to be remapped.",12,[[["self"]],["virtualaddress"]]],[11,"len","","The length of the region asked to be remapped.",12,[[["self"]],["usize"]]],[0,"error","kfs_kernel::paging","Errors specific to memory management",N,N],[4,"MmError","kfs_kernel::paging::error","An error related to Memory Management",N,N],[13,"OccupiedMapping","","",13,N],[12,"address","kfs_kernel::paging::error::MmError","",13,N],[12,"length","","",13,N],[12,"backtrace","","",13,N],[13,"DoesNotSpanMapping","kfs_kernel::paging::error","",13,N],[12,"address","kfs_kernel::paging::error::MmError","",13,N],[12,"length","","",13,N],[12,"backtrace","","",13,N],[13,"SpansSeveralMappings","kfs_kernel::paging::error","",13,N],[12,"address","kfs_kernel::paging::error::MmError","",13,N],[12,"length","","",13,N],[12,"backtrace","","",13,N],[13,"WasAvailable","kfs_kernel::paging::error","",13,N],[12,"address","kfs_kernel::paging::error::MmError","",13,N],[12,"backtrace","","",13,N],[13,"SharedMapping","kfs_kernel::paging::error","",13,N],[12,"backtrace","kfs_kernel::paging::error::MmError","",13,N],[13,"InvalidMapping","kfs_kernel::paging::error","",13,N],[12,"backtrace","kfs_kernel::paging::error::MmError","",13,N],[13,"ThisWillNeverHappenButPleaseDontMatchExhaustively","kfs_kernel::paging::error","",13,N],[17,"_DERIVE_failure_Fail_FOR_MmError","","",N,N],[17,"_DERIVE_failure_core_fmt_Display_FOR_MmError","","",N,N],[0,"hierarchical_table","kfs_kernel::paging","Arch-independent traits for architectures that implement…",N,N],[3,"NoFlush","kfs_kernel::paging::hierarchical_table","Flusher that doesn't flush.",N,N],[3,"SmartHierarchicalTable","","This is just a wrapper for a pointer to a table. It…",N,N],[12,"0","","",14,N],[12,"1","","",14,N],[4,"PageState","","A hierarchical paging is composed of entries. An entry can…",N,N],[13,"Available","","Available, aka unused. Will page fault on use.",1,N],[13,"Guarded","","Guarded. Reserved and will cause a pagefault on use. Used…",1,N],[13,"Present","","Present. Used and has a backing physical address.",1,N],[8,"HierarchicalEntry","","A hierarchical paging is composed of entries. All entries…",N,N],[16,"EntryFlagsType","","An entry comports some flags. They are often represented…",15,N],[10,"is_unused","","Is the entry unused ?",15,[[["self"]],["bool"]]],[10,"set_unused","","Clear the entry",15,[[["self"]],["pagestate",["physicaladdress"]]]],[10,"is_guard","","Is the entry a page guard ?",15,[[["self"]],["bool"]]],[10,"flags","","Get the current entry flags",15,N],[10,"pointed_frame","","Get the associated physical address, if available",15,[[["self"]],["pagestate",["physicaladdress"]]]],[10,"set","","Sets the entry",15,N],[10,"set_guard","","Make this entry a page guard",15,[[["self"]]]],[8,"HierarchicalTable","","A hierarchical paging is composed of tables. All tables…",N,N],[16,"EntryType","","The Entry our table has",16,N],[16,"CacheFlusherType","","A Flusher that should be called on table modifications",16,N],[16,"ChildTableType","","If we're a parent table, the type of our child tables. If…",16,N],[10,"entries","","gets the raw array of entries",16,N],[11,"zero","","zero out the whole table",16,[[["self"]]]],[11,"guard_all_entries","","Makes all entries guarded",16,[[["self"]]]],[11,"map_nth_entry","","Creates a mapping on the nth entry of a table",16,N],[11,"guard_nth_entry","","Marks the nth entry as guard page",16,[[["self"],["usize"]]]],[11,"unmap_nth_entry","","Marks the nth entry as guard page",16,[[["self"],["usize"]]]],[10,"table_level","","Called to check if this table's entries should be treated…",16,[[],["usize"]]],[11,"entry_vm_size","","the size an entry in this table spans in virtual memory.…",16,[[],["usize"]]],[10,"get_child_table","","Gets a reference to a child page table.",16,[[["self"],["usize"]],["pagestate",["smarthierarchicaltable"]]]],[10,"create_child_table","","Allocates a child page table, zero it and add an entry…",16,[[["self"],["usize"]],["smarthierarchicaltable"]]],[11,"get_child_table_or_create","","Gets the child page table at given index, or creates it if…",16,[[["self"],["usize"]],["pagestate",["smarthierarchicaltable"]]]],[8,"PagingCacheFlusher","","Most implementations of paging have are accelerated with a…",N,N],[10,"flush_whole_cache","","Flushes the whole cache.",17,[[]]],[8,"TableHierarchy","","A trait operating on a whole hierarchy of tables.",N,N],[16,"TopLevelTableType","","",18,N],[10,"get_top_level_table","","Gets a reference to the top level table, either through…",18,[[["self"]],["smarthierarchicaltable"]]],[11,"map_to_from_iterator","","Creates a mapping in the page tables with the given flags.",18,[[["self"],["i"],["virtualaddress"],["mappingflags"]]]],[11,"guard","","Creates a span of guard pages",18,[[["self"],["virtualaddress"],["usize"]]]],[11,"unmap","","Unmaps a range of virtual address. On every frames mapped…",18,[[["self"],["virtualaddress"],["usize"],["c"]]]],[11,"for_every_entry","","Iters in the page tables, applying closure on every…",18,[[["self"],["virtualaddress"],["usize"],["c"]]]],[11,"find_available_virtual_space_aligned","","Finds a virtual space hole that is at least length long,…",18,[[["self"],["usize"],["virtualaddress"],["virtualaddress"],["usize"]],["option",["virtualaddress"]]]],[8,"InactiveHierarchyTrait","","A trait implemented by innactive table hierarchies.…",N,N],[10,"new","","Creates a hierarchy. Allocates at least a top level…",19,[[],["self"]]],[10,"switch_to","","Switches to this hierarchy,",19,[[["self"]]]],[11,"destroy","","De-allocates all physical memory used by tables of this…",19,[[["self"]]]],[10,"copy_active_kernel_space","","Performs a shallow copy of the top level-directory section…",19,[[["self"]]]],[10,"is_currently_active","","Checks if this inactive hierarchy is actually the…",19,[[["self"]],["bool"]]],[10,"from_currently_active","","Returns the currently active hierarchy as an inactive…",19,[[],["self"]]],[11,"unwrap","kfs_kernel::paging","Move the value T out of the PageState if it is Present(T).",1,[[["self"]],["t"]]],[11,"map","","Maps a PageState to PageState by applying a function to a…",1,[[["self"],["f"]],["pagestate"]]],[11,"as_option","","Turns the PageState into an Option, setting both Guarded…",1,[[["self"]],["option"]]],[11,"new","kfs_kernel::paging::hierarchical_table","",14,N],[0,"arch","kfs_kernel::paging","Arch-specific implementations of paging",N,N],[0,"i386","kfs_kernel::paging::arch","Paging implementation on i386",N,N],[5,"is_paging_on","kfs_kernel::paging::arch::i386","Check if the paging is currently active.",N,[[],["bool"]]],[5,"enable_paging","","Not used anymore, bootstrap's job",N,[[["physicaladdress"]]]],[5,"flush_tlb","","Flush the Translation Lookaside Buffer…",N,[[]]],[5,"swap_cr3","","Changes the content of the cr3 register, and returns the…",N,[[["physicaladdress"]],["physicaladdress"]]],[5,"read_cr3","","Reads the value of cr3, retrieving the current page…",N,[[],["physicaladdress"]]],[5,"read_cr2","","Reads the value of cr2, retrieving the address that caused…",N,[[],["virtualaddress"]]],[0,"entry","","i386 page table entry",N,N],[3,"I386EntryFlags","kfs_kernel::paging::arch::i386::entry","The flags of a table entry",N,N],[12,"bits","","",20,N],[3,"I386Entry","","An entry in a page table or page directory. An unused…",N,N],[12,"0","","",21,N],[17,"ENTRY_PHYS_ADDRESS_MASK","","",N,N],[18,"PRESENT","","",20,N],[18,"WRITABLE","","",20,N],[18,"USER_ACCESSIBLE","","",20,N],[18,"WRITE_THROUGH","","",20,N],[18,"NO_CACHE","","",20,N],[18,"ACCESSED","","",20,N],[18,"DIRTY","","",20,N],[18,"HUGE_PAGE","","",20,N],[18,"GLOBAL","","",20,N],[18,"GUARD_PAGE","","",20,N],[18,"USER_DEFINED_2","","",20,N],[18,"USER_DEFINED_3","","",20,N],[11,"empty","","Returns an empty set of flags.",20,[[],["i386entryflags"]]],[11,"all","","Returns the set containing all flags.",20,[[],["i386entryflags"]]],[11,"bits","","Returns the raw value of the flags currently stored.",20,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",20,[[["u32"]],["option",["i386entryflags"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",20,[[["u32"]],["i386entryflags"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",20,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",20,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",20,[[["self"],["i386entryflags"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",20,[[["self"],["i386entryflags"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",20,[[["self"],["i386entryflags"]]]],[11,"remove","","Removes the specified flags in-place.",20,[[["self"],["i386entryflags"]]]],[11,"toggle","","Toggles the specified flags in-place.",20,[[["self"],["i386entryflags"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",20,[[["self"],["i386entryflags"],["bool"]]]],[0,"table","kfs_kernel::paging::arch::i386","i386 Page Tables hierarchy",N,N],[3,"Table","kfs_kernel::paging::arch::i386::table","A page table in memory",N,N],[12,"entries","","",22,N],[3,"ActivePageTable","","",N,N],[12,"0","","",23,N],[3,"ActivePageDirectory","","",N,N],[12,"0","","",24,N],[3,"ActiveHierarchy","","",N,N],[3,"InactivePageTable","","",N,N],[12,"0","","",25,N],[3,"InactivePageDirectory","","",N,N],[12,"0","","",26,N],[3,"InactiveHierarchy","","",N,N],[12,"directory_physical_address","","",27,N],[3,"TlbFlush","","When passing this struct the TLB will be flushed. Used by…",N,N],[17,"DIRECTORY_RECURSIVE_ADDRESS","","When paging is on, accessing this address loops back to…",N,N],[11,"get_table_address","","reduce recursive mapping by one time to get further down…",24,[[["self"],["usize"]],["pagestate",["usize"]]]],[17,"PAGE_SIZE","kfs_kernel::paging::arch::i386","The page size. Dictated by the MMU. In simple, elegant,…",N,N],[17,"ENTRY_COUNT","","The number of entries a page table has. On i386 a page…",N,N],[0,"bookkeeping","kfs_kernel::paging","Bookkeeping of mappings in UserLand",N,N],[3,"UserspaceBookkeeping","kfs_kernel::paging::bookkeeping","A bookkeeping is just a list of Mappings",N,N],[12,"mappings","","",28,N],[4,"QueryMemory","","Because we do not store Available mappings internally, we…",N,N],[13,"Available","","",3,N],[13,"Used","","",3,N],[11,"as_ref","kfs_kernel::paging::process_memory","Returns a reference to the underlying mapping.",3,[[["self"]],["mapping"]]],[11,"new","kfs_kernel::paging::bookkeeping","Constructs a UserspaceBookkeeping",28,[[],["self"]]],[11,"mapping_at_or_following","","Returns the mapping `address` falls into, or if it is…",28,[[["self"],["virtualaddress"]],["option",["mapping"]]]],[11,"mapping_at_or_preceding","","Returns the mapping `address` falls into, or if it is…",28,[[["self"],["virtualaddress"]],["option",["mapping"]]]],[11,"mapping_at","","Returns the mapping `address` falls into.",28,[[["self"],["virtualaddress"]],["querymemory"]]],[11,"occupied_mapping_at","","Returns the mapping `address` falls into.",28,[[["self"],["virtualaddress"]],["result",["mapping","kernelerror"]]]],[11,"is_vacant","","Checks that a given range is unoccupied.",28,[[["self"],["virtualaddress"],["usize"]],["result",["bool","kernelerror"]]]],[11,"check_vacant","","Asserts that a given range is unoccupied",28,[[["self"],["virtualaddress"],["usize"]],["result",["kernelerror"]]]],[11,"add_mapping","","Adds a mapping to the list of tracked mappings",28,[[["self"],["mapping"]],["result",["kernelerror"]]]],[11,"remove_mapping","","Removes a mapping from the tracked mappings, and returns it.",28,[[["self"],["virtualaddress"],["usize"]],["result",["mapping","kernelerror"]]]],[11,"remove_mapping_split","","Removes part of a mapping from the tracked mappings, and…",28,[[["self"],["virtualaddress"],["usize"]],["result",["mapping","kernelerror"]]]],[11,"find_available_space","","Finds a hole in virtual space at least `length` long.",28,[[["self"],["usize"]],["result",["virtualaddress","kernelerror"]]]],[17,"PAGE_SIZE","kfs_kernel::paging","The page size. Dictated by the MMU. In simple, elegant,…",N,N],[18,"READABLE","","Mapping is readable.",0,N],[18,"WRITABLE","","Mapping is writable.",0,N],[18,"EXECUTABLE","","Mapping is executable.",0,N],[18,"USER_ACCESSIBLE","","Mapping can be accessed from userland, with the same…",0,N],[11,"empty","","Returns an empty set of flags.",0,[[],["mappingflags"]]],[11,"all","","Returns the set containing all flags.",0,[[],["mappingflags"]]],[11,"bits","","Returns the raw value of the flags currently stored.",0,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",0,[[["u32"]],["option",["mappingflags"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",0,[[["u32"]],["mappingflags"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",0,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",0,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",0,[[["self"],["mappingflags"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",0,[[["self"],["mappingflags"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",0,[[["self"],["mappingflags"]]]],[11,"remove","","Removes the specified flags in-place.",0,[[["self"],["mappingflags"]]]],[11,"toggle","","Toggles the specified flags in-place.",0,[[["self"],["mappingflags"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",0,[[["self"],["mappingflags"],["bool"]]]],[11,"k_r","","Shorthand for READABLE",0,[[],["mappingflags"]]],[11,"k_w","","Shorthand for WRITABLE",0,[[],["mappingflags"]]],[11,"k_rw","","Shorthand for READABLE | WRITABLE",0,[[],["mappingflags"]]],[11,"k_rx","","Shorthand for READABLE | EXECUTABLE",0,[[],["mappingflags"]]],[11,"u_r","","Shorthand for USER_ACCESSIBLE | READABLE",0,[[],["mappingflags"]]],[11,"u_w","","Shorthand for USER_ACCESSIBLE | WRITABLE",0,[[],["mappingflags"]]],[11,"u_rw","","Shorthand for USER_ACCESSIBLE | WRITABLE",0,[[],["mappingflags"]]],[11,"u_rx","","Shorthand for USER_ACCESSIBLE | WRITABLE",0,[[],["mappingflags"]]],[0,"event","kfs_kernel","The core event handling primitives of KFS.",N,N],[3,"IRQEvent","kfs_kernel::event","An event waiting for an IRQ.",N,N],[12,"state","","",29,N],[12,"ack","","",29,N],[3,"IRQState","","",N,N],[12,"irqnum","","",30,N],[12,"counter","","",30,N],[12,"waiting_processes","","",30,N],[5,"wait","","Waits for an event to occur on one of the given Waitable…",N,[[["intoiter"]],["result",["waitable","userspaceerror"]]]],[5,"dispatch_event","","Signal the scheduler and waiters that an IRQ has been…",N,[[["usize"]]]],[5,"wait_event","","Creates an IRQEvent waiting for the given IRQ number.",N,[[["usize"]],["irqevent"]]],[7,"IRQ_STATES","","",N,N],[8,"Waitable","","A waitable item.",N,N],[10,"is_signaled","","Checks whether the Waitable was signalled.",31,[[["self"]],["bool"]]],[10,"register","","Register the waitable with the scheduler.",31,[[["self"]]]],[11,"new","","",30,[[["usize"]],["irqstate"]]],[0,"error","kfs_kernel","UserspaceError and KernelError",N,N],[3,"UserspaceError","kfs_kernel::error","Kernel syscall error codes.",N,N],[12,"0","","",32,N],[4,"ArithmeticOperation","","",N,N],[13,"Add","","",33,N],[13,"Sub","","",33,N],[13,"Mul","","",33,N],[13,"Div","","",33,N],[13,"Mod","","",33,N],[13,"Pow","","",33,N],[4,"KernelError","","Kernel Error.",N,N],[13,"PhysicalMemoryExhaustion","","",34,N],[12,"backtrace","kfs_kernel::error::KernelError","",34,N],[13,"VirtualMemoryExhaustion","kfs_kernel::error","",34,N],[12,"backtrace","kfs_kernel::error::KernelError","",34,N],[13,"InvalidAddress","kfs_kernel::error","",34,N],[12,"address","kfs_kernel::error::KernelError","",34,N],[12,"length","","",34,N],[12,"backtrace","","",34,N],[13,"InvalidSize","kfs_kernel::error","",34,N],[12,"size","kfs_kernel::error::KernelError","",34,N],[12,"backtrace","","",34,N],[13,"AlignmentError","kfs_kernel::error","",34,N],[12,"given","kfs_kernel::error::KernelError","",34,N],[12,"needed","","",34,N],[12,"backtrace","","",34,N],[13,"WouldOverflow","kfs_kernel::error","",34,N],[12,"lhs","kfs_kernel::error::KernelError","",34,N],[12,"rhs","","",34,N],[12,"operation","","",34,N],[12,"backtrace","","",34,N],[13,"ZeroLengthError","kfs_kernel::error","",34,N],[12,"backtrace","kfs_kernel::error::KernelError","",34,N],[13,"MmError","kfs_kernel::error","",34,N],[13,"ProcessKilled","","",34,N],[12,"backtrace","kfs_kernel::error::KernelError","",34,N],[13,"ThreadAlreadyStarted","kfs_kernel::error","",34,N],[12,"backtrace","kfs_kernel::error::KernelError","",34,N],[13,"ThisWillNeverHappenButPleaseDontMatchExhaustively","kfs_kernel::error","",34,N],[17,"_DERIVE_failure_Fail_FOR_KernelError","","",N,N],[17,"_DERIVE_failure_core_fmt_Display_FOR_KernelError","","",N,N],[0,"log_impl","kfs_kernel","A simple log implementation based on env_logger",N,N],[3,"Logger","kfs_kernel::log_impl","",N,N],[12,"filter","","",35,N],[5,"early_init","","Initializes the Logger in a heapless environment.",N,[[]]],[5,"init","","Reinitializes the logger using the cmdline. This requires…",N,[[]]],[0,"filter","","Filtering for log records.",N,N],[3,"Filter","kfs_kernel::log_impl::filter","A log filter.",N,N],[12,"directives","","",36,N],[12,"filter","","",36,N],[3,"Builder","","A builder for a log filter.",N,N],[12,"directives","","",37,N],[12,"filter","","",37,N],[3,"Directive","","",N,N],[12,"name","","",38,N],[12,"level","","",38,N],[5,"parse_spec","","Parse a logging specification string (e.g:…",N,N],[5,"enabled","","",N,N],[0,"inner","","",N,N],[3,"Filter","kfs_kernel::log_impl::filter::inner","",N,N],[12,"inner","","",39,N],[11,"new","","",39,[[["str"]],["result",["filter","string"]]]],[11,"is_match","","",39,[[["self"],["str"]],["bool"]]],[11,"filter","kfs_kernel::log_impl::filter","Returns the maximum `LevelFilter` that this filter…",36,[[["self"]],["levelfilter"]]],[11,"matches","","Checks if this record matches the configured filter.",36,[[["self"],["record"]],["bool"]]],[11,"enabled","","Determines if a log message with the specified metadata…",36,[[["self"],["metadata"]],["bool"]]],[11,"new","","Initializes the filter builder with defaults.",37,[[],["builder"]]],[11,"filter_module","","Initializes the filter builder from an environment. Adds a…",37,[[["self"],["str"],["levelfilter"]],["self"]]],[11,"filter_level","","Adds a directive to the filter for all modules.",37,[[["self"],["levelfilter"]],["self"]]],[11,"filter","","Adds a directive to the filter.",37,[[["self"],["option",["str"]],["levelfilter"]],["self"]]],[11,"parse","","Parses the directives string.",37,[[["self"],["str"]],["self"]]],[11,"build","","Build a log filter.",37,[[["self"]],["filter"]]],[7,"LOGGER","kfs_kernel::log_impl","",N,N],[0,"i386","kfs_kernel","This crate is x86_64's little brother. It provides i386…",N,N],[3,"TssStruct","kfs_kernel::i386","The Task State Segment (TSS) is a special data structure…",N,N],[12,"link","","",40,N],[12,"_reserved1","","",40,N],[12,"esp0","","",40,N],[12,"ss0","","",40,N],[12,"_reserved2","","",40,N],[12,"esp1","","",40,N],[12,"ss1","","",40,N],[12,"_reserved3","","",40,N],[12,"esp2","","",40,N],[12,"ss2","","",40,N],[12,"_reserved4","","",40,N],[12,"cr3","","",40,N],[12,"eip","","",40,N],[12,"eflags","","",40,N],[12,"eax","","",40,N],[12,"ecx","","",40,N],[12,"edx","","",40,N],[12,"ebx","","",40,N],[12,"esp","","",40,N],[12,"ebp","","",40,N],[12,"esi","","",40,N],[12,"edi","","",40,N],[12,"es","","",40,N],[12,"_reserved5","","",40,N],[12,"cs","","",40,N],[12,"_reserved6","","",40,N],[12,"ss","","",40,N],[12,"_reserved7","","",40,N],[12,"ds","","",40,N],[12,"_reserved8","","",40,N],[12,"fs","","",40,N],[12,"_reserved9","","",40,N],[12,"gs","","",40,N],[12,"_reserveda","","",40,N],[12,"ldt_selector","","",40,N],[12,"_reservedb","","",40,N],[12,"_reservedc","","",40,N],[12,"iopboffset","","",40,N],[3,"AlignedTssStruct","","Wrapper around TssStruct ensuring it is kept at the page…",N,N],[12,"0","","",41,N],[4,"PrivilegeLevel","","Represents a protection ring level.",N,N],[13,"Ring0","","Privilege-level 0 (most privilege): This level is used by…",42,N],[13,"Ring1","","Privilege-level 1 (moderate privilege): This level is used…",42,N],[13,"Ring2","","Privilege-level 2 (moderate privilege): Like level 1, this…",42,N],[13,"Ring3","","Privilege-level 3 (least privilege): This level is used by…",42,N],[5,"tss_struct_size","","",N,[[]]],[0,"registers","","i386 registers reading",N,N],[5,"eip","kfs_kernel::i386::registers","Gets the current $eip.",N,[[],["usize"]]],[0,"eflags","","Processor state stored in the EFLAGS register.",N,N],[3,"EFlags","kfs_kernel::i386::registers::eflags","The EFLAGS register.",N,N],[12,"bits","","",43,N],[5,"read","","Returns the current value of the EFLAGS register.",N,[[],["eflags"]]],[5,"read_raw","","Returns the raw current value of the EFLAGS register.",N,[[],["u32"]]],[5,"write","","Writes the EFLAGS register, preserves reserved bits.",N,[[["eflags"]]]],[5,"write_raw","","Writes the EFLAGS register.",N,[[["u32"]]]],[18,"ID","","Processor feature identification flag.",43,N],[18,"VIRTUAL_INTERRUPT_PENDING","","Indicates that an external, maskable interrupt is pending.",43,N],[18,"VIRTUAL_INTERRUPT","","Virtual image of the INTERRUPT_FLAG bit.",43,N],[18,"ALIGNMENT_CHECK","","Enable automatic alignment checking if CR0.AM is set. Only…",43,N],[18,"VIRTUAL_8086_MODE","","Enable the virtual-8086 mode.",43,N],[18,"RESUME_FLAG","","Allows to restart an instruction following an instrucion…",43,N],[18,"NESTED_TASK","","Used by `iret` in hardware task switch mode to determine…",43,N],[18,"IOPL_HIGH","","The high bit of the I/O Privilege Level field.",43,N],[18,"IOPL_LOW","","The low bit of the I/O Privilege Level field.",43,N],[18,"OVERFLOW_FLAG","","Set by hardware to indicate that the sign bit of the…",43,N],[18,"DIRECTION_FLAG","","Determines the order in which strings are processed.",43,N],[18,"INTERRUPT_FLAG","","Enable interrupts.",43,N],[18,"TRAP_FLAG","","Enable single-step mode for debugging.",43,N],[18,"SIGN_FLAG","","Set by hardware if last arithmetic operation resulted in a…",43,N],[18,"ZERO_FLAG","","Set by hardware if last arithmetic operation resulted in a…",43,N],[18,"AUXILIARY_CARRY_FLAG","","Set by hardware if last arithmetic operation generated a…",43,N],[18,"PARITY_FLAG","","Set by hardware if last result has an even number of 1…",43,N],[18,"CARRY_FLAG","","Set by hardware if last arithmetic operation generated a…",43,N],[11,"empty","","Returns an empty set of flags.",43,[[],["eflags"]]],[11,"all","","Returns the set containing all flags.",43,[[],["eflags"]]],[11,"bits","","Returns the raw value of the flags currently stored.",43,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",43,[[["u32"]],["option",["eflags"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",43,[[["u32"]],["eflags"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",43,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",43,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",43,[[["self"],["eflags"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",43,[[["self"],["eflags"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",43,[[["self"],["eflags"]]]],[11,"remove","","Removes the specified flags in-place.",43,[[["self"],["eflags"]]]],[11,"toggle","","Toggles the specified flags in-place.",43,[[["self"],["eflags"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",43,[[["self"],["eflags"],["bool"]]]],[0,"stack","kfs_kernel::i386","Kernel stack",N,N],[3,"KernelStack","kfs_kernel::i386::stack","A structure representing a kernel stack",N,N],[12,"stack_address","","",44,N],[3,"StackDumpSource","","The minimal information needed to perform a stack dump.",N,N],[12,"esp","","The initial top of the stack.",45,N],[12,"ebp","","The initial bottom of the first stack frame.",45,N],[12,"eip","","The initial pc.",45,N],[5,"dump_stack","","Dumps the stack from the given information, displaying it…",N,[[["stackdumpsource"],["option"]]]],[5,"dump_stack_from_slice","","Dumps a stack, displaying it in a frame-by-frame format.",N,N],[17,"STACK_SIZE","","The size of a kernel stack in pages, not accounting for…",N,N],[17,"STACK_SIZE_WITH_GUARD","","The size of a kernel stack in pages, with the page guard.",N,N],[17,"STACK_ALIGNEMENT","","The alignment of the stack.…",N,N],[11,"allocate_stack","","Allocates the kernel stack of a process.",44,[[],["result",["kernelstack","kernelerror"]]]],[11,"get_stack_bottom","","",44,[[["usize"]],["usize"]]],[11,"get_current_stack_bottom","","Gets the bottom of the stack by and'ing $esp with…",44,[[],["usize"]]],[11,"get_current_stack","","Retrieves the current stack from $esp",44,[[],["kernelstack"]]],[18,"STACK_POISON_SIZE","","We keep 2 poison pointers for fake saved ebp and saved esp…",44,N],[11,"create_poison_pointers","","Puts two poisons pointers at the base of the stack for the…",44,[[["self"]]]],[11,"get_stack_start","","Get the address of the beginning of usable stack. Used for…",44,[[["self"]],["usize"]]],[11,"dump_current_stack","","Dumps the stack, displaying it in a frame-by-frame format.",44,[[["option"]]]],[11,"new","","Creates a StackDumpSource from :",45,[[["usize"],["usize"],["usize"]],["self"]]],[0,"multiboot","kfs_kernel::i386","Multiboot Information",N,N],[5,"get_boot_information","kfs_kernel::i386::multiboot","Get a pointer to the multiboot information structure.",N,[[],["bootinformation"]]],[5,"try_get_boot_information","","Tries to get a pointer to the multiboot information…",N,[[],["option",["bootinformation"]]]],[5,"init","","Initializes the boot information module, allowing the…",N,[[["bootinformation"]]]],[7,"BOOT_INFO","","",N,N],[0,"structures","kfs_kernel::i386","Representations of various x86 specific structures and…",N,N],[0,"gdt","kfs_kernel::i386::structures","Types for the Global Descriptor Table and segment selectors.",N,N],[3,"SegmentSelector","kfs_kernel::i386::structures::gdt","Specifies which element to load into a segment from…",N,N],[12,"0","","",46,N],[11,"new","","Creates a new SegmentSelector",46,[[["u16"],["privilegelevel"]],["segmentselector"]]],[11,"index","","Returns the GDT index.",46,[[["self"]],["u16"]]],[11,"rpl","","Returns the requested privilege level.",46,[[["self"]],["privilegelevel"]]],[0,"idt","kfs_kernel::i386::structures","Provides types for the Interrupt Descriptor Table and its…",N,N],[3,"Idt","kfs_kernel::i386::structures::idt","An Interrupt Descriptor Table with 256 entries.",N,N],[12,"divide_by_zero","","A divide by zero exception (`#DE`) occurs when the…",47,N],[12,"debug","","When the debug-exception mechanism is enabled, a `#DB`…",47,N],[12,"non_maskable_interrupt","","An non maskable interrupt exception (NMI) occurs as a…",47,N],[12,"breakpoint","","A breakpoint (`#BP`) exception occurs when an `INT3`…",47,N],[12,"overflow","","An overflow exception (`#OF`) occurs as a result of…",47,N],[12,"bound_range_exceeded","","A bound-range exception (`#BR`) exception can occur as a…",47,N],[12,"invalid_opcode","","An invalid opcode exception (`#UD`) occurs when an attempt…",47,N],[12,"device_not_available","","A device not available exception (`#NM`) occurs under any…",47,N],[12,"double_fault","","A double fault (`#DF`) exception can occur when a second…",47,N],[12,"coprocessor_segment_overrun","","This interrupt vector is reserved. It is for a…",47,N],[12,"invalid_tss","","An invalid TSS exception (`#TS`) occurs only as a result…",47,N],[12,"segment_not_present","","An segment-not-present exception (`#NP`) occurs when an…",47,N],[12,"stack_segment_fault","","An stack segment exception (`#SS`) can occur in the…",47,N],[12,"general_protection_fault","","A general protection fault (`#GP`) can occur in various…",47,N],[12,"page_fault","","A page fault (`#PF`) can occur during a memory access in…",47,N],[12,"reserved_1","","vector nr. 15",47,N],[12,"x87_floating_point","","The x87 Floating-Point Exception-Pending exception (`#MF`)…",47,N],[12,"alignment_check","","An alignment check exception (`#AC`) occurs when an…",47,N],[12,"machine_check","","The machine check exception (`#MC`) is model specific.…",47,N],[12,"simd_floating_point","","The SIMD Floating-Point Exception (`#XF`) is used to…",47,N],[12,"virtualization","","vector nr. 20",47,N],[12,"reserved_2","","vector nr. 21-29",47,N],[12,"security_exception","","The Security Exception (`#SX`) signals security-sensitive…",47,N],[12,"reserved_3","","vector nr. 31",47,N],[12,"interrupts","","User-defined interrupts can be initiated either by system…",47,N],[3,"IdtEntry","","An Interrupt Descriptor Table entry.",N,N],[12,"pointer_low","","",48,N],[12,"gdt_selector","","",48,N],[12,"zero","","",48,N],[12,"options","","",48,N],[12,"pointer_high","","",48,N],[12,"phantom","","",48,N],[3,"EntryOptions","","Represents the options field of an IDT entry.",N,N],[12,"0","","",49,N],[3,"ExceptionStackFrame","","Represents the exception stack frame pushed by the CPU on…",N,N],[12,"instruction_pointer","","This value points to the instruction that should be…",50,N],[12,"code_segment","","The code segment selector, padded with zeros.",50,N],[12,"cpu_flags","","The flags register before the interrupt handler was invoked.",50,N],[12,"stack_pointer","","The stack pointer at the time of the interrupt.",50,N],[12,"stack_segment","","The stack segment descriptor at the time of the interrupt…",50,N],[3,"PageFaultErrorCode","","Describes an page fault error code.",N,N],[12,"bits","","",51,N],[5,"const_assert_idt","","",N,[[]]],[5,"const_assert_idtentry","","",N,[[]]],[6,"HandlerFunc","","A handler function for an interrupt or an exception…",N,N],[6,"HandlerFuncWithErrCode","","A handler function for an exception that pushes an error…",N,N],[6,"PageFaultHandlerFunc","","A page fault handler function that pushes a page fault…",N,N],[11,"init","","Creates a new IDT filled with non-present entries.",47,[[["self"]]]],[11,"load","","Loads the IDT in the CPU using the `lidt` command.",47,[[["self"]]]],[11,"missing","","Creates a non-present IDT entry (but sets the must-be-one…",48,[[],["self"]]],[11,"set_interrupt_gate_addr","","Set an interrupt gate function for the IDT entry and sets…",48,[[["self"],["u32"]],["entryoptions"]]],[11,"set_handler_task_gate_addr","","Set a task gate for the IDT entry and sets the present bit.",48,[[["self"],["u32"]]]],[11,"set_handler_fn","","Set an interrupt gate function for the IDT entry and sets…",48,[[["self"],["handlerfunc"]],["entryoptions"]]],[11,"set_task_fn","","Set a task gate function for the IDT entry and sets the…",48,[[["self"],["handlerfunc"]]]],[11,"set_handler_fn","","Set an interrupt gate function for the IDT entry and sets…",48,[[["self"],["handlerfuncwitherrcode"]],["entryoptions"]]],[11,"set_task_fn","","Set a task gate function for the IDT entry and sets the…",48,[[["self"],["handlerfuncwitherrcode"]]]],[11,"set_handler_fn","","Set an interrupt gate function for the IDT entry and sets…",48,[[["self"],["pagefaulthandlerfunc"]],["entryoptions"]]],[11,"set_task_fn","","Set a task gate function for the IDT entry and sets the…",48,[[["self"],["pagefaulthandlerfunc"]]]],[11,"minimal","","Creates a minimal options field with all the must-be-one…",49,[[],["self"]]],[11,"set_present_interrupt","","Set or reset the preset bit.",49,[[["self"],["bool"]],["self"]]],[11,"set_present_task","","Set or reset the preset bit.",49,[[["self"],["bool"]],["self"]]],[11,"disable_interrupts","","Let the CPU disable hardware interrupts when the handler…",49,[[["self"],["bool"]],["self"]]],[11,"set_privilege_level","","Set the required privilege level (DPL) for invoking the…",49,[[["self"],["privilegelevel"]],["self"]]],[18,"PROTECTION_VIOLATION","","If this flag is set, the page fault was caused by a…",51,N],[18,"CAUSED_BY_WRITE","","If this flag is set, the memory access that caused the…",51,N],[18,"USER_MODE","","If this flag is set, an access in user mode (CPL=3) caused…",51,N],[18,"MALFORMED_TABLE","","If this flag is set, the page fault is a result of the…",51,N],[18,"INSTRUCTION_FETCH","","If this flag is set, it indicates that the access that…",51,N],[11,"empty","","Returns an empty set of flags.",51,[[],["pagefaulterrorcode"]]],[11,"all","","Returns the set containing all flags.",51,[[],["pagefaulterrorcode"]]],[11,"bits","","Returns the raw value of the flags currently stored.",51,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",51,[[["u32"]],["option",["pagefaulterrorcode"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",51,[[["u32"]],["pagefaulterrorcode"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",51,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",51,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",51,[[["self"],["pagefaulterrorcode"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",51,[[["self"],["pagefaulterrorcode"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",51,[[["self"],["pagefaulterrorcode"]]]],[11,"remove","","Removes the specified flags in-place.",51,[[["self"],["pagefaulterrorcode"]]]],[11,"toggle","","Toggles the specified flags in-place.",51,[[["self"],["pagefaulterrorcode"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",51,[[["self"],["pagefaulterrorcode"],["bool"]]]],[0,"process_switch","kfs_kernel::i386","Arch-specific process switch functions",N,N],[3,"ThreadHardwareContext","kfs_kernel::i386::process_switch","The hardware context of a paused thread. It contains just…",N,N],[12,"esp","","",52,N],[5,"process_switch","","Performs the process switch, switching from currently…",N,[[["arc",["threadstruct"]],["arc",["threadstruct"]]],["arc",["threadstruct"]]]],[5,"prepare_for_first_schedule","","Prepares the thread for its first schedule by writing…",N,[[["threadstruct"],["usize"],["usize"]]]],[5,"first_schedule","","The function ret'd on, on a thread's first schedule - as…",N,[[]]],[5,"jump_to_entrypoint","","",N,[[["usize"],["usize"]]]],[11,"new","","Creates an empty ThreadHardwareContext.",52,[[],["self"]]],[0,"gdt","kfs_kernel::i386","GDT Handler",N,N],[3,"GdtManager","kfs_kernel::i386::gdt","",N,N],[12,"unloaded_table","","",53,N],[3,"MAIN_TASK","","VirtualAddress of the TSS structure of the main task. Has…",N,N],[12,"__private_field","","",54,N],[3,"DescriptorTable","","A structure containing our GDT.",N,N],[12,"table","","",55,N],[3,"DescriptorTableEntry","","",N,N],[12,"0","","",56,N],[4,"SystemDescriptorTypes","","",N,N],[13,"AvailableTss16","","",57,N],[13,"Ldt","","",57,N],[13,"BusyTss16","","",57,N],[13,"CallGate16","","",57,N],[13,"TaskGate","","",57,N],[13,"InterruptGate16","","",57,N],[13,"TrapGate16","","",57,N],[13,"AvailableTss32","","",57,N],[13,"BusyTss32","","",57,N],[13,"CallGate32","","",57,N],[13,"InterruptGate32","","",57,N],[13,"TrapGate32","","",57,N],[5,"init_gdt","","Initializes the GDT.",N,[[]]],[5,"push_task_segment","","Push a task segment.",N,[[["tssstruct"]],["u16"]]],[5,"get_main_iopb","","Get the IOPB of the Main Task.",N,N],[7,"GDT","","",N,N],[7,"GLOBAL_LDT","","The global LDT used by all the processes.",N,N],[7,"MAIN_TASK","","",N,N],[11,"load","","",53,[[["descriptortable"],["u16"],["u16"],["u16"]],["gdtmanager"]]],[11,"commit","","",53,[[["self"],["u16"],["u16"],["u16"]]]],[11,"new","","Create an empty GDT. This will not include the null entry,…",55,[[],["descriptortable"]]],[11,"set_from_loaded","","Fill the current DescriptorTable with a copy of the…",55,[[["self"]]]],[11,"push","","Push a new entry to the table, returning a segment…",55,[[["self"],["descriptortableentry"]],["u16"]]],[11,"load_global","","",55,[[["self"],["u16"],["u16"],["u16"]],["descriptortablepointer"]]],[11,"null_descriptor","","",56,[[],["descriptortableentry"]]],[11,"new","","Creates an empty GDT descriptor, but with some flags set…",56,[[["u32"],["u32"],["bool"],["privilegelevel"]],["descriptortableentry"]]],[11,"new_system","","Creates an empty GDT descriptor, but with some flags set…",56,[[["systemdescriptortypes"],["u32"],["u32"],["privilegelevel"]],["descriptortableentry"]]],[11,"new_ldt","","Creates a new LDT descriptor.",56,[[["descriptortable"],["privilegelevel"]],["descriptortableentry"]]],[11,"new_tss","","Creates a GDT descriptor pointing to a TSS segment",56,[[["tssstruct"],["privilegelevel"],["usize"]],["descriptortableentry"]]],[11,"get_limit","","",56,[[["self"]],["u32"]]],[11,"set_limit","","",56,[[["self"],["u32"]]]],[11,"get_base","","",56,[[["self"]],["u32"]]],[11,"set_base","","",56,[[["self"],["u32"]]]],[11,"get_accessed","","",56,[[["self"]],["bool"]]],[11,"is_readwrite_allowed","","",56,[[["self"]],["bool"]]],[11,"is_comformant","","",56,[[["self"]],["bool"]]],[11,"is_executable","","",56,[[["self"]],["bool"]]],[11,"get_ring_level","","",56,[[["self"]],["privilegelevel"]]],[11,"get_present","","",56,[[["self"]],["bool"]]],[11,"is_4k_granularity","","",56,[[["self"]],["bool"]]],[11,"set_4k_granularity","","",56,[[["self"],["bool"]]]],[11,"is_32bit","","",56,[[["self"]],["bool"]]],[0,"pio","kfs_kernel::i386","Port IO",N,N],[3,"Pio","kfs_kernel::i386::pio","Port IO accessor.",N,N],[12,"port","","",58,N],[12,"value","","",58,N],[0,"instructions","kfs_kernel::i386","Low level functions for special i386 instructions.",N,N],[0,"tables","kfs_kernel::i386::instructions","Instructions for loading descriptor tables (GDT, IDT, etc.).",N,N],[3,"DescriptorTablePointer","kfs_kernel::i386::instructions::tables","A struct describing a pointer to a descriptor table (GDT /…",N,N],[12,"limit","","Size of the DT.",59,N],[12,"base","","Pointer to the memory region containing the DT.",59,N],[5,"lgdt","","Load GDT table.",N,[[["descriptortablepointer"]]]],[5,"sgdt","","Store GDT table.",N,[[],["descriptortablepointer"]]],[5,"lldt","","Load LDT table.",N,[[["segmentselector"]]]],[5,"ltr","","Sets the task register to the given TSS segment.",N,[[["segmentselector"]]]],[5,"lidt","","Load IDT table.",N,[[["descriptortablepointer"]]]],[0,"segmentation","kfs_kernel::i386::instructions","Provides functions to read and write segment registers.",N,N],[5,"set_cs","kfs_kernel::i386::instructions::segmentation","Reload code segment register. Note this is special since…",N,[[["segmentselector"]]]],[5,"load_ss","","Reload stack segment register.",N,[[["segmentselector"]]]],[5,"load_ds","","Reload data segment register.",N,[[["segmentselector"]]]],[5,"load_es","","Reload es segment register.",N,[[["segmentselector"]]]],[5,"load_fs","","Reload fs segment register.",N,[[["segmentselector"]]]],[5,"load_gs","","Reload gs segment register.",N,[[["segmentselector"]]]],[5,"cs","","Returns the current value of the code segment register.",N,[[],["segmentselector"]]],[0,"interrupts","kfs_kernel::i386::instructions","Interrupt disabling functionality.",N,N],[5,"sti","kfs_kernel::i386::instructions::interrupts","Enable interrupts",N,[[]]],[5,"cli","","Disable interrupts",N,[[]]],[5,"hlt","","Waits until an interrupt is fired",N,[[]]],[5,"are_enabled","","Returns whether interrupts are enabled.",N,[[],["bool"]]],[5,"without_interrupts","","Run a closue with disabled interrupts.",N,[[["f"]],["r"]]],[11,"from_u16","kfs_kernel::i386","Creates a `PrivilegeLevel` from a numeric value. The value…",42,[[["u16"]],["privilegelevel"]]],[11,"new","","Creates a new TssStruct.",40,[[],["tssstruct"]]],[11,"set_esp0_stack","","Set the stack pointer used to handle interrupts occuring…",40,[[["self"],["u32"]]]],[11,"set_ip","","Set the IP of the current task struct. When we hardware…",40,[[["self"],["u32"]]]],[11,"new","","Create a new AlignedTssStruct, using boxing to avoid…",41,[[["tssstruct"]],["box",["alignedtssstruct"]]]],[0,"interrupts","kfs_kernel","Interrupt handling.",N,N],[3,"IDT","kfs_kernel::interrupts","",N,N],[12,"__private_field","","",60,N],[5,"check_thread_killed","","Checks if our thread was killed, in which case unschedule…",N,[[]]],[5,"panic_on_exception","","Panics with an informative message.",N,N],[5,"divide_by_zero_handler","","",N,[[["exceptionstackframe"]]]],[5,"debug_handler","","",N,[[["exceptionstackframe"]]]],[5,"non_maskable_interrupt_handler","","",N,[[["exceptionstackframe"]]]],[5,"breakpoint_handler","","",N,[[["exceptionstackframe"]]]],[5,"overflow_handler","","",N,[[["exceptionstackframe"]]]],[5,"bound_range_exceeded_handler","","",N,[[["exceptionstackframe"]]]],[5,"invalid_opcode_handler","","",N,[[["exceptionstackframe"]]]],[5,"device_not_available_handler","","",N,[[["exceptionstackframe"]]]],[5,"double_fault_handler","","",N,[[]]],[5,"invalid_tss_handler","","",N,[[["exceptionstackframe"],["u32"]]]],[5,"segment_not_present_handler","","",N,[[["exceptionstackframe"],["u32"]]]],[5,"stack_segment_fault_handler","","",N,[[["exceptionstackframe"],["u32"]]]],[5,"general_protection_fault_handler","","",N,[[["exceptionstackframe"],["u32"]]]],[5,"page_fault_handler","","",N,[[["exceptionstackframe"],["pagefaulterrorcode"]]]],[5,"x87_floating_point_handler","","",N,[[["exceptionstackframe"]]]],[5,"alignment_check_handler","","",N,[[["exceptionstackframe"],["u32"]]]],[5,"machine_check_handler","","",N,[[["exceptionstackframe"]]]],[5,"simd_floating_point_handler","","",N,[[["exceptionstackframe"]]]],[5,"virtualization_handler","","",N,[[["exceptionstackframe"]]]],[5,"security_exception_handler","","",N,[[["exceptionstackframe"],["u32"]]]],[5,"syscall_handler","","This is the function called on int 0x80.",N,[[]]],[5,"init","","Initialize the interrupt subsystem. Sets up the PIC and…",N,[[]]],[0,"irq","","",N,N],[5,"acknowledge_irq","kfs_kernel::interrupts::irq","",N,[[["u8"]]]],[5,"timer_handler","","",N,[[["exceptionstackframe"]]]],[7,"IRQ_HANDLERS","","",N,N],[0,"syscalls","kfs_kernel::interrupts","Syscall implementations",N,N],[3,"Registers","kfs_kernel::interrupts::syscalls","",N,N],[12,"eax","","",61,N],[12,"ebx","","",61,N],[12,"ecx","","",61,N],[12,"edx","","",61,N],[12,"esi","","",61,N],[12,"edi","","",61,N],[12,"ebp","","",61,N],[5,"ignore_syscall","","",N,[[["usize"]],["result",["userspaceerror"]]]],[5,"set_heap_size","","Resize the heap of a process, just like a brk. It can both…",N,[[["usize"]],["result",["usize","userspaceerror"]]]],[5,"map_framebuffer","","Maps the vga frame buffer mmio in userspace memory",N,[[],["result",["userspaceerror"]]]],[5,"create_interrupt_event","","",N,[[["usize"],["u32"]],["result",["usize","userspaceerror"]]]],[5,"wait_synchronization","","",N,[[["userspaceptr"],["usize"]],["result",["usize","userspaceerror"]]]],[5,"output_debug_string","","",N,[[["userspaceptr"]],["result",["userspaceerror"]]]],[5,"exit_process","","Kills our own process.",N,[[],["result",["userspaceerror"]]]],[5,"connect_to_port","","",N,[[["u32"]],["result",["usize","userspaceerror"]]]],[5,"exit_thread","","Kills our own thread.",N,[[],["result",["userspaceerror"]]]],[5,"create_thread","","Creates a thread in the current process. The thread can…",N,[[["usize"],["usize"],["usize"],["u32"],["u32"]],["result",["usize","userspaceerror"]]]],[5,"start_thread","","Starts a previously created thread.",N,[[["u32"]],["result",["userspaceerror"]]]],[5,"connect_to_named_port","","",N,[[["userspaceptr"]],["result",["usize","userspaceerror"]]]],[5,"manage_named_port","","",N,[[["userspaceptr"],["u32"]],["result",["usize","userspaceerror"]]]],[5,"accept_session","","",N,[[["u32"]],["result",["usize","userspaceerror"]]]],[5,"send_sync_request_with_user_buffer","","",N,[[["userspaceptrmut"],["u32"]],["result",["userspaceerror"]]]],[5,"reply_and_receive_with_user_buffer","","",N,[[["userspaceptrmut"],["userspaceptr"],["u32"],["usize"]],["result",["usize","userspaceerror"]]]],[5,"close_handle","","",N,[[["u32"]],["result",["userspaceerror"]]]],[5,"sleep_thread","","",N,[[["usize"]],["result",["userspaceerror"]]]],[5,"create_port","","",N,[[["u32"],["bool"],["userspaceptr"]],["result",["userspaceerror"]]]],[5,"create_shared_memory","","",N,[[["u32"],["u32"],["u32"]],["result",["usize","userspaceerror"]]]],[5,"map_shared_memory","","",N,[[["u32"],["usize"],["usize"],["u32"]],["result",["userspaceerror"]]]],[5,"unmap_shared_memory","","",N,[[["u32"],["usize"],["usize"]],["result",["userspaceerror"]]]],[5,"query_memory","","",N,[[["userspaceptrmut",["memoryinfo"]],["usize"],["usize"]],["result",["usize","userspaceerror"]]]],[5,"create_session","","",N,[[["bool"],["usize"]],["result",["userspaceerror"]]]],[5,"syscall_handler_inner","","",N,[[["registers"]]]],[11,"apply0","","",61,[[["self"],["result",["userspaceerror"]]]]],[11,"apply1","","",61,[[["self"],["result",["usize","userspaceerror"]]]]],[11,"apply2","","",61,[[["self"],["result",["userspaceerror"]]]]],[11,"apply3","","",61,[[["self"],["result",["userspaceerror"]]]]],[11,"apply4","","",61,[[["self"],["result",["userspaceerror"]]]]],[7,"IDT","kfs_kernel::interrupts","",N,N],[0,"frame_allocator","kfs_kernel","Physical memory manager.",N,N],[3,"FrameAllocator","kfs_kernel::frame_allocator","The physical memory manager.",N,N],[5,"init","","Initialize the [FrameAllocator] by parsing the multiboot…",N,[[["bootinformation"]]]],[5,"mark_frame_bootstrap_allocated","","Marks a physical memory frame as already allocated…",N,[[["physicaladdress"]]]],[0,"physical_mem_region","","PhysicalMemRegion",N,N],[3,"PhysicalMemRegion","kfs_kernel::frame_allocator::physical_mem_region","A span of adjacent physical frames. A frame is [PAGE_SIZE].",N,N],[12,"frames","","The number of frames in this region.",62,N],[12,"start_addr","","The (physical) address of the start of this region.",62,N],[12,"should_free_on_drop","","Denotes if the frames held in this region should be freed…",62,N],[3,"PhysicalMemRegionIter","","An iterator over a physical region. Yields the address of…",N,N],[12,"0","","",63,N],[12,"1","","",63,N],[11,"address","","Get the start address of this PhysicalMemRegion",62,[[["self"]],["physicaladdress"]]],[11,"size","","Get the size this PhysicalMemRegion spans",62,[[["self"]],["usize"]]],[11,"on_fixed_mmio","","Constructs a `PhysicalMemRegion` by circumventing the…",62,[[["physicaladdress"],["usize"]],["self"]]],[11,"reconstruct","","Constructs a `PhysicalMemRegion` from a physical address,…",62,[[["physicaladdress"],["usize"]],["self"]]],[11,"reconstruct_no_dealloc","","Constructs a `PhysicalMemRegion` from a physical address,…",62,[[["physicaladdress"],["usize"]],["self"]]],[0,"i386","kfs_kernel::frame_allocator","Architecture specific-behaviour i386 implementation of the…",N,N],[3,"FrameAllocatori386","kfs_kernel::frame_allocator::i386","",N,N],[12,"memory_bitmap","","A big bitmap denoting for every frame if it is free or not",64,N],[12,"initialized","","All operations have to check that the Allocator has been…",64,N],[3,"FrameAllocator","","The physical memory manager.",N,N],[5,"addr_to_frame","","Gets the frame number from a physical address",N,[[["usize"]],["usize"]]],[5,"frame_to_addr","","Gets the physical address from a frame number",N,[[["usize"]],["usize"]]],[5,"init","","Initialize the [FrameAllocator] by parsing the multiboot…",N,[[["bootinformation"]]]],[5,"mark_area_reserved","","Marks a physical memory area as reserved and will never…",N,N],[5,"mark_area_free","","Marks a physical memory area as free for frame allocation",N,N],[5,"mark_frame_bootstrap_allocated","","Marks a physical memory frame as already allocated…",N,[[["physicaladdress"]]]],[7,"FRAME_ALLOCATOR","","A physical memory manger to allocate and free memory frames",N,N],[17,"FRAME_OFFSET_MASK","","",N,N],[17,"FRAME_BASE_MASK","","",N,N],[17,"FRAME_BASE_LOG","","",N,N],[17,"FRAMES_BITMAP_SIZE","","The size of the frames_bitmap (~128ko)",N,N],[17,"FRAME_FREE","","",N,N],[17,"FRAME_OCCUPIED","","",N,N],[11,"new","","",64,[[],["self"]]],[0,"private","kfs_kernel::frame_allocator","",N,N],[8,"FrameAllocatorTraitPrivate","kfs_kernel::frame_allocator::private","",N,N],[10,"free_region","","Marks a region as deallocated. Called when a…",65,[[["physicalmemregion"]]]],[10,"check_is_allocated","","Checks if a region is marked allocated.",65,[[["physicaladdress"],["usize"]],["bool"]]],[10,"check_is_reserved","","Checks if a region is marked reserved.",65,[[["physicaladdress"],["usize"]],["bool"]]],[8,"FrameAllocatorTrait","kfs_kernel::frame_allocator","An arch-specific FrameAllocator must expose the following…",N,N],[10,"allocate_region","","Allocates a single PhysicalMemRegion. Frames are…",66,[[["usize"]],["result",["physicalmemregion","kernelerror"]]]],[10,"allocate_frames_fragmented","","Allocates physical frames, possibly fragmented across…",66,[[["usize"]],["result",["vec","kernelerror"]]]],[11,"allocate_frame","","Allocates a single physical frame.",66,[[],["result",["physicalmemregion","kernelerror"]]]],[0,"heap_allocator","kfs_kernel","Virtual heap allocator.",N,N],[3,"Allocator","kfs_kernel::heap_allocator","Simple wrapper around linked_list_allocator, growing heap…",N,N],[12,"0","","",67,N],[5,"rust_oom","","Called when the kernel heap allocator detects Out Of…",N,N],[17,"RESERVED_HEAP_SIZE","","",N,N],[11,"expand","","Safely expands the heap if possible.",67,[[["self"],["usize"]]]],[11,"init","","",67,[[],["spinlock",["heap"]]]],[11,"new","","Creates a new heap based off of loader settings.",67,[[],["allocator"]]],[0,"devices","kfs_kernel","Device drivers",N,N],[0,"rs232","kfs_kernel::devices","RS-232",N,N],[3,"ComPort","kfs_kernel::devices::rs232","The port of a COM",N,N],[12,"0","","",68,N],[3,"SerialAttributes","","A foreground and a background combination",N,N],[12,"fg","","",69,N],[12,"bg","","",69,N],[3,"SerialInternal","","",N,N],[12,"data_port","","",70,N],[12,"status_port","","",70,N],[3,"SerialLogger","","A logger that sends its output to COM1.",N,N],[4,"SerialColor","","The possible colors for serial",N,N],[13,"Black","","",71,N],[13,"Red","","",71,N],[13,"Green","","",71,N],[13,"Yellow","","",71,N],[13,"Blue","","",71,N],[13,"Magenta","","",71,N],[13,"Cyan","","",71,N],[13,"LightGray","","",71,N],[13,"Default","","",71,N],[13,"DarkGray","","",71,N],[13,"LightRed","","",71,N],[13,"LightGreen","","",71,N],[13,"LightYellow","","",71,N],[13,"LightBlue","","",71,N],[13,"LightMagenta","","",71,N],[13,"LightCyan","","",71,N],[13,"White","","",71,N],[7,"G_SERIAL","","",N,N],[17,"COM1","","",N,N],[17,"COM2","","",N,N],[17,"COM3","","",N,N],[17,"COM4","","",N,N],[11,"fg","","Creates a color attribute with `fg` foreground and default…",69,[[["serialcolor"]],["serialattributes"]]],[11,"fg_bg","","Creates a color attribute with `fg` foreground and `bg`…",69,[[["serialcolor"],["serialcolor"]],["serialattributes"]]],[11,"default","","Creates a color attribute with default foreground and…",69,[[],["serialattributes"]]],[11,"new","","Creates the serial for i386",70,[[["comport"]],["serialinternal",["pio"]]]],[11,"send_string","","",70,[[["self"],["str"]]]],[11,"force_unlock","","Re-take the lock protecting multiple access to the device.",72,[[["self"]]]],[0,"pit","kfs_kernel::devices","Programmable Interval Timer",N,N],[3,"PIT_PORTS","kfs_kernel::devices::pit","The mutex wrapping the ports",N,N],[12,"__private_field","","",73,N],[3,"Port61Flags","","The port 0x61 flags we use",N,N],[12,"bits","","",74,N],[3,"PITPorts","","We put the PIT ports in a structure to have them under a…",N,N],[12,"port_chan_0","","",75,N],[12,"port_chan_2","","",75,N],[12,"port_cmd","","",75,N],[12,"port_61","","",75,N],[3,"PITChannel2","","Channel 2",N,N],[12,"ports","","",76,N],[3,"WaitFor","","",N,N],[12,"every_ms","","",77,N],[12,"parent_event","","",77,N],[12,"spins_needed","","",77,N],[4,"ChannelSelector","","Used internally to select which channel to apply…",N,N],[13,"Channel0","","",78,N],[13,"Channel2","","",78,N],[5,"spin_wait_ms","","Spin waits for at least `ms` amount of milliseconds",N,[[["usize"]]]],[5,"wait_ms","","Returns a stream of event that trigger every `ms` amount…",N,N],[5,"init_channel_0","","Initialize the channel 0 to send recurring irqs",N,[[]]],[7,"PIT_PORTS","","",N,N],[17,"OSCILLATOR_FREQ","","The oscillator frequency when not divided, in hertz.",N,N],[17,"CHAN_0_FREQUENCY","","The frequency of channel 0 irqs, in hertz. One every 10…",N,N],[17,"CHAN_0_DIVISOR","","The channel 0 reset value",N,N],[18,"SPKR_CONTROL","","",74,N],[18,"OUT2_STATUS","","",74,N],[18,"GATE_2","","",74,N],[18,"OUT1_STATUS","","",74,N],[18,"OTHER_2","","",74,N],[18,"OTHER_3","","",74,N],[18,"OTHER_6","","",74,N],[18,"OTHER_7","","",74,N],[11,"empty","","Returns an empty set of flags.",74,[[],["port61flags"]]],[11,"all","","Returns the set containing all flags.",74,[[],["port61flags"]]],[11,"bits","","Returns the raw value of the flags currently stored.",74,[[["self"]],["u8"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",74,[[["u8"]],["option",["port61flags"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",74,[[["u8"]],["port61flags"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",74,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",74,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",74,[[["self"],["port61flags"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",74,[[["self"],["port61flags"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",74,[[["self"],["port61flags"]]]],[11,"remove","","Removes the specified flags in-place.",74,[[["self"],["port61flags"]]]],[11,"toggle","","Toggles the specified flags in-place.",74,[[["self"],["port61flags"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",74,[[["self"],["port61flags"],["bool"]]]],[11,"write_reload_value","","Writes a reload value in lobyte/hibyte access mode",75,[[["self"],["channelselector"],["u16"]]]],[11,"init","","Sets mode #0 for channel 2",76,[[["pitports"]],["pitchannel2"]]],[11,"start_countdown","","Sets the countdown reset value by writing to channel 2…",76,[[["self"],["u16"]]]],[11,"is_countdown_finished","","Checks if the countdown is finished",76,[[["self"]],["bool"]]],[11,"wait_countdown_is_finished","","Waits until countdown is finished",76,[[["self"]]]],[11,"spin_wait_ms","","Spin waits for at least `ms` amount of milliseconds",76,[[["self"],["usize"]]]],[0,"pic","kfs_kernel::devices","Driver for the 8259 Programmable Interrupt Controller.",N,N],[3,"ICW1","kfs_kernel::devices::pic","The first control word sent to the PIC.",N,N],[12,"bits","","",79,N],[3,"InternalPic","","A single PIC8259 device.",N,N],[12,"port_cmd","","",80,N],[12,"port_data","","",80,N],[3,"Pic","","A master/slave PIC setup, as commonly found on IBM PCs.",N,N],[12,"master","","",81,N],[12,"slave","","",81,N],[5,"get","","Acquires a reference to the PIC, initializing it if it…",N,[[],["pic"]]],[5,"init","","Initializes the PIC if it has not yet been initialized.…",N,[[]]],[7,"PIC","","",N,N],[17,"ICW4_8086","","",N,N],[18,"ICW4","","If this bit is set, ICW4 has to be read. If ICW4 is not…",79,N],[18,"SINGLE","","Single. Means that this is the only 8259A in the system.…",79,N],[18,"INTERVAL4","","Call Address Interval. Used only in 8085, not 8086.…",79,N],[18,"LEVEL","","If LEVEL = 1, then the 8259A will operate in the level…",79,N],[18,"INIT","","Should always be set to 1.",79,N],[11,"empty","","Returns an empty set of flags.",79,[[],["icw1"]]],[11,"all","","Returns the set containing all flags.",79,[[],["icw1"]]],[11,"bits","","Returns the raw value of the flags currently stored.",79,[[["self"]],["u8"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",79,[[["u8"]],["option",["icw1"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",79,[[["u8"]],["icw1"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",79,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",79,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",79,[[["self"],["icw1"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",79,[[["self"],["icw1"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",79,[[["self"],["icw1"]]]],[11,"remove","","Removes the specified flags in-place.",79,[[["self"],["icw1"]]]],[11,"toggle","","Toggles the specified flags in-place.",79,[[["self"],["icw1"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",79,[[["self"],["icw1"],["bool"]]]],[11,"new","","Creates a new PIC, and initializes it.",81,[[],["pic"]]],[11,"mask","","Mask the given IRQ number. Will redirect the call to the…",81,[[["self"],["u8"]]]],[11,"acknowledge","","Acknowledges an IRQ, allowing the PIC to send a new IRQ on…",81,[[["self"],["u8"]]]],[11,"new","","Setup the 8259 pic. Redirect the IRQ to the chosen…",80,[[["u16"],["bool"],["u8"]],["internalpic"]]],[11,"acknowledge","","Acknowledges an IRQ, allowing the PIC to send a new IRQ on…",80,[[["self"]]]],[11,"mask","","Mask the given IRQ",80,[[["self"],["u8"]]]],[0,"sync","kfs_kernel","Synchronization primitives used by KFS",N,N],[3,"Once","kfs_kernel::sync","A synchronization primitive which can be used to run a…",N,N],[12,"state","","",82,N],[12,"data","","",82,N],[3,"RwLock","","A reader-writer lock",N,N],[12,"lock","","",83,N],[12,"data","","",83,N],[3,"RwLockReadGuard","","A guard to which the protected data can be read",N,N],[12,"lock","","",84,N],[12,"data","","",84,N],[3,"RwLockWriteGuard","","A guard to which the protected data can be written",N,N],[12,"lock","","",85,N],[12,"data","","",85,N],[3,"SpinLock","","This type provides MUTual EXclusion based on spinning.",N,N],[12,"lock","","",86,N],[12,"data","","",86,N],[3,"SpinLockGuard","","A guard to which the protected data can be accessed",N,N],[12,"lock","","",87,N],[12,"data","","",87,N],[3,"SpinLockIRQ","","SpinLock that disables IRQ.",N,N],[12,"internal","","",88,N],[3,"SpinLockIRQGuard","","The SpinLockIrq lock guard.",N,N],[12,"0","","",89,N],[5,"enable_interrupts","","Decrement the interrupt disable counter.",N,[[]]],[5,"disable_interrupts","","Increment the interrupt disable counter.",N,[[]]],[5,"permanently_disable_interrupts","","Permanently disables the interrupts. Forever.",N,[[]]],[6,"Mutex","","Placeholder for future Mutex implementation.",N,N],[6,"MutexGuard","","Placeholder for future Mutex implementation.",N,N],[7,"INTERRUPT_DISARM","","",N,N],[8,"Lock","","Abstraction around various kind of locks.",N,N],[10,"lock","","Locks the lock until the returned guard is dropped. The…",90,[[["self"]],["guard"]]],[11,"new","","Creates a new spinlockirq wrapping the supplied data.",88,[[["t"]],["spinlockirq"]]],[11,"into_inner","","Consumes this SpinLockIRQ, returning the underlying data.",88,[[["self"]],["t"]]],[11,"lock","","Disables interrupts and locks the mutex.",88,[[["self"]],["spinlockirqguard"]]],[11,"try_lock","","Disables interrupts and locks the mutex.",88,[[["self"]],["option",["spinlockirqguard"]]]],[11,"force_unlock","","Force unlocks the lock.",88,[[["self"]]]],[0,"process","kfs_kernel","Process",N,N],[3,"ProcessStruct","kfs_kernel::process","The struct representing a process. There's one for every…",N,N],[12,"pid","","The unique id of this process.",91,N],[12,"name","","A name for this process.",91,N],[12,"pmemory","","The memory view of this process. Shared among the threads.",91,N],[12,"phandles","","The handles of this process. Shared among the threads.",91,N],[12,"threads","","The threads of this process. A ProcessStruct with no…",91,N],[12,"killed","","Marks when the process is dying.",91,N],[12,"ioports","","A vector of readable IO ports.",91,N],[12,"thread_maternity","","An array of the created but not yet started threads.",91,N],[3,"ThreadStruct","","The struct representing a thread. A process may own…",N,N],[12,"state","","The state of this thread.",92,N],[12,"kstack","","The kernel stack it uses for handling syscalls/irqs.",92,N],[12,"hwcontext","","The saved hardware context, for getting it running again…",92,N],[12,"process","","The process that this thread belongs to.",92,N],[12,"int_disable_counter","","Interrupt disable counter.",92,N],[3,"HandleTable","","Holds the table associating userspace handle numbers to a…",N,N],[12,"table","","",93,N],[12,"counter","","",93,N],[3,"ThreadStateAtomic","","Stores a ThreadState atomically.",N,N],[12,"0","","",94,N],[4,"Handle","","A handle to a userspace-accessible resource.",N,N],[13,"ReadableEvent","","An event on which we can wait. Could be an IRQ, or a…",95,N],[13,"ServerPort","","The server side of an IPC port. See [::ipc::port] for more…",95,N],[13,"ClientPort","","The client side of an IPC port. See [::ipc::port] for more…",95,N],[13,"ServerSession","","The server side of an IPC session. See [::ipc::session]…",95,N],[13,"ClientSession","","The client side of an IPC session. See [::ipc::session]…",95,N],[13,"Thread","","A thread.",95,N],[13,"SharedMemory","","A shared memory region. The handle holds on to the…",95,N],[4,"ThreadState","","The state of a thread.",N,N],[13,"Running","","Currently on the CPU.",96,N],[13,"Scheduled","","Scheduled to be running.",96,N],[13,"Stopped","","Not in the scheduled queue, waiting for an event.",96,N],[13,"Killed","","Dying, will be unscheduled and dropped at syscall boundary.",96,N],[7,"NEXT_PROCESS_ID","","",N,N],[11,"as_waitable","","Gets the handle as a [Waitable], or return a…",95,[[["self"]],["result",["waitable","userspaceerror"]]]],[11,"as_client_port","","Casts the handle as a [ClientPort], or returns a…",95,[[["self"]],["result",["clientport","userspaceerror"]]]],[11,"as_server_session","","Casts the handle as a [ServerSession], or returns a…",95,[[["self"]],["result",["serversession","userspaceerror"]]]],[11,"as_client_session","","Casts the handle as a [ClientSession], or returns a…",95,[[["self"]],["result",["clientsession","userspaceerror"]]]],[11,"as_thread_handle","","Casts the handle as a Weak<[ThreadStruct]>, or returns a…",95,[[["self"]],["result",["weak","userspaceerror"]]]],[11,"as_shared_memory","","Casts the handle as an Arc<Vec<[PhysicalMemRegion]>, or…",95,[[["self"]],["result",["arc","userspaceerror"]]]],[11,"new","","Creates an empty handle table. Note that an empty handle…",93,[[],["handletable"]]],[11,"add_handle","","Add a handle to the handle table, returning the userspace…",93,[[["self"],["arc",["handle"]]],["u32"]]],[11,"get_handle","","Gets the Kernel Handle associated with the given userspace…",93,[[["self"],["u32"]],["result",["arc","userspaceerror"]]]],[11,"delete_handle","","Deletes the mapping from the given userspace handle…",93,[[["self"],["u32"]],["result",["arc","userspaceerror"]]]],[11,"from_primitive","","",96,[[["usize"]],["threadstate"]]],[11,"new","","",94,[[["threadstate"]],["threadstateatomic"]]],[11,"into_inner","","",94,[[["self"]],["threadstate"]]],[11,"load","","",94,[[["self"],["ordering"]],["threadstate"]]],[11,"store","","",94,[[["self"],["threadstate"],["ordering"]]]],[11,"swap","","",94,[[["self"],["threadstate"],["ordering"]],["threadstate"]]],[11,"compare_and_swap","","",94,[[["self"],["threadstate"],["threadstate"],["ordering"]],["threadstate"]]],[11,"compare_exchange","","",94,[[["self"],["threadstate"],["threadstate"],["ordering"],["ordering"]],["result",["threadstate","threadstate"]]]],[11,"compare_exchange_weak","","",94,[[["self"],["threadstate"],["threadstate"],["ordering"],["ordering"]],["result",["threadstate","threadstate"]]]],[11,"fetch_update","","",94,[[["self"],["f"],["ordering"],["ordering"]],["result",["threadstate","threadstate"]]]],[11,"new","","Creates a new process.",91,[[["string"],["vec",["u16"]]],["arc",["processstruct"]]]],[11,"create_first_process","","Creates the very first process at boot. Called internally…",91,[[],["arc",["processstruct"]]]],[11,"kill_process","","Kills a process by killing all of its threads.",91,[[["arc"]]]],[11,"new","","Creates a new thread.",92,[[["arc"],["virtualaddress"],["virtualaddress"]],["result",["weak","kernelerror"]]]],[11,"create_first_thread","","Creates the very first process and thread at boot.",92,[[],["arc",["threadstruct"]]]],[11,"start","","Takes a reference to a thread, removes it from the…",92,[[["weak"]],["result",["kernelerror"]]]],[11,"kill","","Sets the thread to the `Killed` state.",92,[[["arc"]]]],[0,"scheduler","kfs_kernel","The Completly Unfair Scheduler",N,N],[5,"try_get_current_thread","kfs_kernel::scheduler","Gets the current ThreadStruct, incrementing its refcount.…",N,[[],["option",["arc"]]]],[5,"get_current_thread","","Gets the current ThreadStruct, incrementing its refcount.",N,[[],["arc",["threadstruct"]]]],[5,"try_get_current_process","","Gets the ProcessStruct of the current thread, incrementing…",N,[[],["option",["arc"]]]],[5,"get_current_process","","Gets the ProcessStruct of the current thread, incrementing…",N,[[],["arc",["processstruct"]]]],[5,"set_current_thread","","Sets the current ThreadStruct.",N,[[["arc",["threadstruct"]],["f"]],["r"]]],[5,"add_to_schedule_queue","","Adds a thread at the end of the schedule queue, and…",N,[[["arc",["threadstruct"]]]]],[5,"is_in_schedule_queue","","Checks if a thread is already either in the schedule queue…",N,[[["spinlockirqguard"],["arc"]],["bool"]]],[5,"unschedule","","Removes the current thread from the schedule queue, and…",N,[[["lock"],["guard"]],["result",["userspaceerror"]]]],[5,"create_first_process","","Creates the very first process at boot. The created…",N,[[]]],[5,"schedule","","Performs a process switch.",N,[[]]],[5,"find_next_thread_to_run","","Parses the queue to find the first unlocked process.…",N,[[["vec"]],["option",["usize"]]]],[5,"internal_schedule","","Internal impl of the process switch, used by schedule and…",N,[[["lock"],["bool"]],["guard"]]],[5,"scheduler_first_schedule","","The function called when a thread was scheduled for the…",N,[[["arc",["threadstruct"]],["f"]]]],[7,"CURRENT_THREAD","","An Arc to the currently running thread.",N,N],[7,"SCHEDULE_QUEUE","","The schedule queue",N,N],[0,"mem","kfs_kernel","Basic functionality for dealing with memory.",N,N],[3,"PhysicalAddress","kfs_kernel::mem","Represents a Physical address",N,N],[12,"0","","",97,N],[3,"VirtualAddress","","Represents a Virtual address",N,N],[12,"0","","",98,N],[3,"UserSpacePtr","","A pointer to read-only userspace memory. Prevents…",N,N],[12,"0","","",99,N],[3,"UserSpacePtrMut","","A pointer to read-write userspace memory. Prevents…",N,N],[12,"0","","",100,N],[3,"FatPtr","","Internal rust representation of a DST pointer.",N,N],[12,"data","","A pointer to the underlying slice.",101,N],[12,"len","","The length of the slice, in number of elements.",101,N],[5,"round_to_page","","Rounds an address to its page address",N,[[["usize"]],["usize"]]],[5,"round_to_page_upper","","Rounds an address to the next page address except if its…",N,[[["usize"]],["usize"]]],[5,"count_pages","","Counts the number of pages `size` takes",N,[[["usize"]],["usize"]]],[11,"addr","","Gets the address as a `usize`.",98,[[["self"]],["usize"]]],[11,"addr","","Gets the address as a `usize`.",97,[[["self"]],["usize"]]],[11,"checked_add","","Tries to add an offset to a PhysicalAddress, returning a…",97,[[["self"],["usize"]],["result",["physicaladdress","kernelerror"]]]],[11,"floor","","Rounds down to PAGE_SIZE.",97,[[["self"]],["physicaladdress"]]],[11,"ceil","","Rounds up PAGE_SIZE.",97,[[["self"]],["physicaladdress"]]],[11,"checked_add","","Tries to add an offset to a VirtualAddress, returning a…",98,[[["self"],["usize"]],["result",["virtualaddress","kernelerror"]]]],[11,"floor","","Rounds down to PAGE_SIZE.",98,[[["self"]],["virtualaddress"]]],[11,"ceil","","Rounds up PAGE_SIZE.",98,[[["self"]],["virtualaddress"]]],[11,"from_raw_parts","","Forms a UserSpacePtr slice from a pointer and a length.…",99,N],[11,"from_raw_parts_mut","","Forms a UserSpacePtrMut slice from a pointer and a length.…",100,N],[0,"ipc","kfs_kernel","IPC primitives",N,N],[3,"NAMED_PORTS","kfs_kernel::ipc","",N,N],[12,"__private_field","","",102,N],[5,"create_named_port","","Creates a named port.",N,N],[5,"connect_to_named_port","","Connects to a named port.",N,N],[0,"session","","IPC Sessions",N,N],[3,"InternalSession","kfs_kernel::ipc::session","",N,N],[12,"active_request","","",103,N],[12,"incoming_requests","","",103,N],[3,"Session","","",N,N],[12,"internal","","",104,N],[12,"accepters","","",104,N],[12,"servercount","","",104,N],[3,"ClientSession","","The client side of a Session.",N,N],[12,"0","","",105,N],[3,"ServerSession","","The server side of a Session.",N,N],[12,"0","","",106,N],[3,"MsgPackedHdr","","Represenens the header of an HIPC command.",N,N],[12,"0","","",107,N],[3,"HandleDescriptorHeader","","Part of an HIPC command. Sent only when…",N,N],[12,"0","","",108,N],[3,"Request","","",N,N],[12,"sender_buf","","",109,N],[12,"sender_bufsize","","",109,N],[12,"sender","","",109,N],[12,"answered","","",109,N],[5,"new","","Create a new Session pair. Those sessions are linked to…",N,N],[5,"buf_map","","",N,N],[5,"pass_message","","",N,N],[11,"ty","","",107,[[["self"]],["u16"]]],[11,"num_x_descriptors","","",107,[[["self"]],["u8"]]],[11,"set_num_x_descriptors","","",107,[[["self"],["u8"]]]],[11,"num_a_descriptors","","",107,[[["self"]],["u8"]]],[11,"set_num_a_descriptors","","",107,[[["self"],["u8"]]]],[11,"num_b_descriptors","","",107,[[["self"]],["u8"]]],[11,"set_num_b_descriptors","","",107,[[["self"],["u8"]]]],[11,"num_w_descriptors","","",107,[[["self"]],["u8"]]],[11,"set_num_w_descriptors","","",107,[[["self"],["u8"]]]],[11,"raw_section_size","","",107,[[["self"]],["u16"]]],[11,"set_raw_section_size","","",107,[[["self"],["u16"]]]],[11,"c_descriptor_flags","","",107,[[["self"]],["u8"]]],[11,"set_c_descriptor_flags","","",107,[[["self"],["u8"]]]],[11,"enable_handle_descriptor","","",107,[[["self"]],["bool"]]],[11,"set_enable_handle_descriptor","","",107,[[["self"],["bool"]]]],[11,"send_pid","","",108,[[["self"]],["bool"]]],[11,"set_send_pid","","",108,[[["self"],["bool"]]]],[11,"num_copy_handles","","",108,[[["self"]],["u8"]]],[11,"set_num_copy_handles","","",108,[[["self"],["u8"]]]],[11,"num_move_handles","","",108,[[["self"]],["u8"]]],[11,"set_num_move_handles","","",108,[[["self"],["u8"]]]],[11,"new","","",104,N],[11,"client","","Returns a ClientPort from this Port.",104,[[["arc"]],["clientsession"]]],[11,"server","","Returns a ServerSession from this Port.",104,[[["arc"]],["serversession"]]],[11,"send_request","","Send an IPC request through the client pipe. Takes a…",105,[[["self"],["userspaceptrmut"]],["result",["userspaceerror"]]]],[11,"receive","","Receive an IPC request through the server pipe. Takes a…",106,[[["self"],["userspaceptrmut"]],["result",["userspaceerror"]]]],[11,"reply","","Replies to the currently active IPC request on the server…",106,[[["self"],["userspaceptr"]],["result",["userspaceerror"]]]],[0,"port","kfs_kernel::ipc","IPC Port",N,N],[3,"Port","kfs_kernel::ipc::port","An endpoint which can be connected to.",N,N],[12,"incoming_connections","","",110,N],[12,"accepters","","",110,N],[12,"servercount","","",110,N],[3,"ClientPort","","The client side of a Port.",N,N],[12,"0","","",111,N],[3,"ServerPort","","The server side of a Port.",N,N],[12,"0","","",112,N],[3,"IncomingConnection","","",N,N],[12,"session","","",113,N],[12,"creator","","",113,N],[5,"new","","Create a new Port pair. Those ports are linked to…",N,N],[11,"new","","Creates a new port. This port may only have _max_sessions…",110,N],[11,"client","","Returns a ClientPort from this Port.",110,[[["arc"]],["clientport"]]],[11,"server","","Returns a ServerPort from this Port.",110,[[["arc"]],["serverport"]]],[11,"accept","","Accept a new connection on the Port.",112,[[["self"]],["result",["serversession","userspaceerror"]]]],[11,"connect","","Connects to this port.",111,[[["self"]],["result",["clientsession","userspaceerror"]]]],[7,"NAMED_PORTS","kfs_kernel::ipc","",N,N],[0,"elf_loader","kfs_kernel","Loads Kernel Built-ins.",N,N],[3,"MappedGrubModule","kfs_kernel::elf_loader","Represents a grub module once mapped in kernel memory",N,N],[12,"mapping_addr","","The address of the mapping, in KernelLand.",114,N],[12,"start","","The start of the module in the mapping, if it was not page…",114,N],[12,"len","","The length of the module.",114,N],[12,"elf","","The module parsed as an ElfFile.",114,N],[5,"map_grub_module","","Maps a grub module, which already lives in reserved…",N,[[["moduletag"]],["mappedgrubmodule"]]],[5,"get_iopb","","Gets the desired iopb for a process based on the…",N,[[["mappedgrubmodule"]],["vec",["u16"]]]],[5,"load_builtin","","Loads the given kernel built-in into the given page table.…",N,[[["processmemory"],["mappedgrubmodule"]],["usize"]]],[5,"load_segment","","Loads an elf segment by coping file_size bytes to the…",N,[[["processmemory"],["programheader"],["elffile"]]]],[0,"utils","kfs_kernel","Generic useful functions",N,N],[0,"io","kfs_kernel::utils","The IO interface",N,N],[8,"Io","kfs_kernel::utils::io","The Io trait allows for accessing device IO in a generic…",N,N],[16,"Value","","The width of the IO access. Should be a primitive type…",115,N],[10,"read","","Reads from this Io.",115,N],[10,"write","","Writes `value` to this Io.",115,N],[11,"readf","","Read from this Io, and mask the value with `flags`.",115,N],[11,"writef","","Mask `value` with `flags`, and write it to this device…",115,N],[3,"ReadOnly","","A read-only wrapper around an IO device.",N,N],[12,"inner","","",116,N],[3,"WriteOnly","","An Io that we can only write to.",N,N],[12,"inner","","",117,N],[3,"Pio","","Port IO accessor.",N,N],[12,"port","","",58,N],[12,"value","","",58,N],[5,"align_up","kfs_kernel::utils","Align the address to the next alignment.",N,[[["t"],["t"]],["t"]]],[5,"align_down","","Align the address to the previous alignment.",N,[[["t"],["t"]],["t"]]],[5,"align_up_checked","","align_up, but checks if addr overflows",N,[[["usize"],["usize"]],["option",["usize"]]]],[5,"div_ceil","","Counts the numbers of `b` in `a`, rounding the result up.",N,[[["t"],["t"]],["t"]]],[5,"print_hexdump","","Displays memory as hexdump",N,N],[5,"print_hexdump_as_if_at_addr","","Makes a hexdump of a slice, but display different…",N,N],[8,"BitArrayExt","","Extension of the [BitField] trait, that adds the…",N,N],[11,"set_bits_area","","Sets a range of bits to `value` in the BitField.",118,N],[5,"bit_array_first_zero","","Returns the index of the first 0 in a bit array.",N,N],[5,"bit_array_first_one","","Returns the index of the first 1 in a bit array.",N,N],[5,"bit_array_first_count_one","","Returns the index of the first instance of count…",N,N],[3,"CursorWrite","","A minimal Cursor for writing, for use in libcore.",N,N],[12,"data","","",119,N],[12,"pos","","",119,N],[3,"CursorRead","","A minimal Cursor for writing, for use in libcore.",N,N],[12,"data","","",120,N],[12,"pos","","",120,N],[14,"enum_with_val","","Creates a fake C-like enum, where all bit values are…",N,N],[8,"Splittable","","A trait for things that can be splitted in two parts",N,N],[10,"split_at","","Split the given object in two at a given offset.",121,[[["self"],["usize"]],["result",["option","kernelerror"]]]],[11,"right_split","","Splits the given object in two at the given offset.",121,[[["self"],["usize"]],["result",["option","kernelerror"]]]],[0,"checks","kfs_kernel","Checked maths functions returning useful errors.",N,N],[5,"check_aligned","kfs_kernel::checks","checks that a certain value meets the given alignment.",N,[[["usize"],["usize"]],["result",["kernelerror"]]]],[5,"check_nonzero_length","","checks that a length is not 0.",N,[[["usize"]],["result",["kernelerror"]]]],[5,"add_or_error","","adds to usize, and returns an KernelError if it would…",N,[[["usize"],["usize"]],["result",["usize","kernelerror"]]]],[5,"sub_or_error","","subtracts to usize, and returns an KernelError if it would…",N,[[["usize"],["usize"]],["result",["usize","kernelerror"]]]],[0,"__rg_allocator_abi","kfs_kernel","",N,N],[5,"__rg_alloc","kfs_kernel::__rg_allocator_abi","",N,N],[5,"__rg_dealloc","","",N,N],[5,"__rg_realloc","","",N,N],[5,"__rg_alloc_zeroed","","",N,N],[7,"ALLOCATOR","kfs_kernel","",N,N],[11,"from","kfs_kernel::paging","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::paging::process_memory","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::paging::kernel_memory","",5,[[["t"]],["t"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::paging::lands","",8,[[["t"]],["t"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"from","","",9,[[["t"]],["t"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::paging::mapping","",10,[[["t"]],["t"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"from","","",11,[[["t"]],["t"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::paging::cross_process","",12,[[["t"]],["t"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::paging::error","",13,[[["t"]],["t"]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"into","","",13,[[["self"]],["u"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"to_string","","",13,[[["self"]],["string"]]],[11,"as_fail","","",13,[[["self"]],["fail"]]],[11,"from","kfs_kernel::paging::hierarchical_table","",122,[[["t"]],["t"]]],[11,"try_from","","",122,[[["u"]],["result"]]],[11,"try_into","","",122,[[["self"]],["result"]]],[11,"into","","",122,[[["self"]],["u"]]],[11,"borrow","","",122,[[["self"]],["t"]]],[11,"borrow_mut","","",122,[[["self"]],["t"]]],[11,"get_type_id","","",122,[[["self"]],["typeid"]]],[11,"from","","",14,[[["t"]],["t"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"try_into","","",14,[[["self"]],["result"]]],[11,"into","","",14,[[["self"]],["u"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"get_type_id","","",14,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::paging::arch::i386::entry","",20,[[["t"]],["t"]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"try_into","","",20,[[["self"]],["result"]]],[11,"into","","",20,[[["self"]],["u"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"get_type_id","","",20,[[["self"]],["typeid"]]],[11,"to_owned","","",20,[[["self"]],["t"]]],[11,"clone_into","","",20,N],[11,"from","","",21,[[["t"]],["t"]]],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"try_into","","",21,[[["self"]],["result"]]],[11,"into","","",21,[[["self"]],["u"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"get_type_id","","",21,[[["self"]],["typeid"]]],[11,"to_owned","","",21,[[["self"]],["t"]]],[11,"clone_into","","",21,N],[11,"from","kfs_kernel::paging::arch::i386::table","",22,[[["t"]],["t"]]],[11,"try_from","","",22,[[["u"]],["result"]]],[11,"try_into","","",22,[[["self"]],["result"]]],[11,"into","","",22,[[["self"]],["u"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"get_type_id","","",22,[[["self"]],["typeid"]]],[11,"from","","",23,[[["t"]],["t"]]],[11,"try_from","","",23,[[["u"]],["result"]]],[11,"try_into","","",23,[[["self"]],["result"]]],[11,"into","","",23,[[["self"]],["u"]]],[11,"borrow","","",23,[[["self"]],["t"]]],[11,"borrow_mut","","",23,[[["self"]],["t"]]],[11,"get_type_id","","",23,[[["self"]],["typeid"]]],[11,"from","","",24,[[["t"]],["t"]]],[11,"try_from","","",24,[[["u"]],["result"]]],[11,"try_into","","",24,[[["self"]],["result"]]],[11,"into","","",24,[[["self"]],["u"]]],[11,"borrow","","",24,[[["self"]],["t"]]],[11,"borrow_mut","","",24,[[["self"]],["t"]]],[11,"get_type_id","","",24,[[["self"]],["typeid"]]],[11,"from","","",123,[[["t"]],["t"]]],[11,"try_from","","",123,[[["u"]],["result"]]],[11,"try_into","","",123,[[["self"]],["result"]]],[11,"into","","",123,[[["self"]],["u"]]],[11,"borrow","","",123,[[["self"]],["t"]]],[11,"borrow_mut","","",123,[[["self"]],["t"]]],[11,"get_type_id","","",123,[[["self"]],["typeid"]]],[11,"from","","",25,[[["t"]],["t"]]],[11,"try_from","","",25,[[["u"]],["result"]]],[11,"try_into","","",25,[[["self"]],["result"]]],[11,"into","","",25,[[["self"]],["u"]]],[11,"borrow","","",25,[[["self"]],["t"]]],[11,"borrow_mut","","",25,[[["self"]],["t"]]],[11,"get_type_id","","",25,[[["self"]],["typeid"]]],[11,"from","","",26,[[["t"]],["t"]]],[11,"try_from","","",26,[[["u"]],["result"]]],[11,"try_into","","",26,[[["self"]],["result"]]],[11,"into","","",26,[[["self"]],["u"]]],[11,"borrow","","",26,[[["self"]],["t"]]],[11,"borrow_mut","","",26,[[["self"]],["t"]]],[11,"get_type_id","","",26,[[["self"]],["typeid"]]],[11,"from","","",27,[[["t"]],["t"]]],[11,"try_from","","",27,[[["u"]],["result"]]],[11,"try_into","","",27,[[["self"]],["result"]]],[11,"into","","",27,[[["self"]],["u"]]],[11,"borrow","","",27,[[["self"]],["t"]]],[11,"borrow_mut","","",27,[[["self"]],["t"]]],[11,"get_type_id","","",27,[[["self"]],["typeid"]]],[11,"from","","",124,[[["t"]],["t"]]],[11,"try_from","","",124,[[["u"]],["result"]]],[11,"try_into","","",124,[[["self"]],["result"]]],[11,"into","","",124,[[["self"]],["u"]]],[11,"borrow","","",124,[[["self"]],["t"]]],[11,"borrow_mut","","",124,[[["self"]],["t"]]],[11,"get_type_id","","",124,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::paging::bookkeeping","",28,[[["t"]],["t"]]],[11,"try_from","","",28,[[["u"]],["result"]]],[11,"try_into","","",28,[[["self"]],["result"]]],[11,"into","","",28,[[["self"]],["u"]]],[11,"borrow","","",28,[[["self"]],["t"]]],[11,"borrow_mut","","",28,[[["self"]],["t"]]],[11,"get_type_id","","",28,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::event","",29,[[["t"]],["t"]]],[11,"try_from","","",29,[[["u"]],["result"]]],[11,"try_into","","",29,[[["self"]],["result"]]],[11,"into","","",29,[[["self"]],["u"]]],[11,"borrow","","",29,[[["self"]],["t"]]],[11,"borrow_mut","","",29,[[["self"]],["t"]]],[11,"get_type_id","","",29,[[["self"]],["typeid"]]],[11,"from","","",30,[[["t"]],["t"]]],[11,"try_from","","",30,[[["u"]],["result"]]],[11,"try_into","","",30,[[["self"]],["result"]]],[11,"into","","",30,[[["self"]],["u"]]],[11,"borrow","","",30,[[["self"]],["t"]]],[11,"borrow_mut","","",30,[[["self"]],["t"]]],[11,"get_type_id","","",30,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::error","",32,[[["t"]],["t"]]],[11,"try_from","","",32,[[["u"]],["result"]]],[11,"try_into","","",32,[[["self"]],["result"]]],[11,"into","","",32,[[["self"]],["u"]]],[11,"borrow","","",32,[[["self"]],["t"]]],[11,"borrow_mut","","",32,[[["self"]],["t"]]],[11,"get_type_id","","",32,[[["self"]],["typeid"]]],[11,"to_owned","","",32,[[["self"]],["t"]]],[11,"clone_into","","",32,N],[11,"to_string","","",32,[[["self"]],["string"]]],[11,"from","","",33,[[["t"]],["t"]]],[11,"try_from","","",33,[[["u"]],["result"]]],[11,"try_into","","",33,[[["self"]],["result"]]],[11,"into","","",33,[[["self"]],["u"]]],[11,"borrow","","",33,[[["self"]],["t"]]],[11,"borrow_mut","","",33,[[["self"]],["t"]]],[11,"get_type_id","","",33,[[["self"]],["typeid"]]],[11,"to_owned","","",33,[[["self"]],["t"]]],[11,"clone_into","","",33,N],[11,"to_string","","",33,[[["self"]],["string"]]],[11,"from","","",34,[[["t"]],["t"]]],[11,"try_from","","",34,[[["u"]],["result"]]],[11,"try_into","","",34,[[["self"]],["result"]]],[11,"into","","",34,[[["self"]],["u"]]],[11,"borrow","","",34,[[["self"]],["t"]]],[11,"borrow_mut","","",34,[[["self"]],["t"]]],[11,"get_type_id","","",34,[[["self"]],["typeid"]]],[11,"to_string","","",34,[[["self"]],["string"]]],[11,"as_fail","","",34,[[["self"]],["fail"]]],[11,"from","kfs_kernel::log_impl","",35,[[["t"]],["t"]]],[11,"try_from","","",35,[[["u"]],["result"]]],[11,"try_into","","",35,[[["self"]],["result"]]],[11,"into","","",35,[[["self"]],["u"]]],[11,"borrow","","",35,[[["self"]],["t"]]],[11,"borrow_mut","","",35,[[["self"]],["t"]]],[11,"get_type_id","","",35,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::log_impl::filter","",36,[[["t"]],["t"]]],[11,"try_from","","",36,[[["u"]],["result"]]],[11,"try_into","","",36,[[["self"]],["result"]]],[11,"into","","",36,[[["self"]],["u"]]],[11,"borrow","","",36,[[["self"]],["t"]]],[11,"borrow_mut","","",36,[[["self"]],["t"]]],[11,"get_type_id","","",36,[[["self"]],["typeid"]]],[11,"from","","",37,[[["t"]],["t"]]],[11,"try_from","","",37,[[["u"]],["result"]]],[11,"try_into","","",37,[[["self"]],["result"]]],[11,"into","","",37,[[["self"]],["u"]]],[11,"borrow","","",37,[[["self"]],["t"]]],[11,"borrow_mut","","",37,[[["self"]],["t"]]],[11,"get_type_id","","",37,[[["self"]],["typeid"]]],[11,"from","","",38,[[["t"]],["t"]]],[11,"try_from","","",38,[[["u"]],["result"]]],[11,"try_into","","",38,[[["self"]],["result"]]],[11,"into","","",38,[[["self"]],["u"]]],[11,"borrow","","",38,[[["self"]],["t"]]],[11,"borrow_mut","","",38,[[["self"]],["t"]]],[11,"get_type_id","","",38,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::log_impl::filter::inner","",39,[[["t"]],["t"]]],[11,"try_from","","",39,[[["u"]],["result"]]],[11,"try_into","","",39,[[["self"]],["result"]]],[11,"into","","",39,[[["self"]],["u"]]],[11,"borrow","","",39,[[["self"]],["t"]]],[11,"borrow_mut","","",39,[[["self"]],["t"]]],[11,"get_type_id","","",39,[[["self"]],["typeid"]]],[11,"to_string","","",39,[[["self"]],["string"]]],[11,"from","kfs_kernel::i386","",40,[[["t"]],["t"]]],[11,"try_from","","",40,[[["u"]],["result"]]],[11,"try_into","","",40,[[["self"]],["result"]]],[11,"into","","",40,[[["self"]],["u"]]],[11,"borrow","","",40,[[["self"]],["t"]]],[11,"borrow_mut","","",40,[[["self"]],["t"]]],[11,"get_type_id","","",40,[[["self"]],["typeid"]]],[11,"to_owned","","",40,[[["self"]],["t"]]],[11,"clone_into","","",40,N],[11,"from","","",41,[[["t"]],["t"]]],[11,"try_from","","",41,[[["u"]],["result"]]],[11,"try_into","","",41,[[["self"]],["result"]]],[11,"into","","",41,[[["self"]],["u"]]],[11,"borrow","","",41,[[["self"]],["t"]]],[11,"borrow_mut","","",41,[[["self"]],["t"]]],[11,"get_type_id","","",41,[[["self"]],["typeid"]]],[11,"from","","",42,[[["t"]],["t"]]],[11,"try_from","","",42,[[["u"]],["result"]]],[11,"try_into","","",42,[[["self"]],["result"]]],[11,"into","","",42,[[["self"]],["u"]]],[11,"borrow","","",42,[[["self"]],["t"]]],[11,"borrow_mut","","",42,[[["self"]],["t"]]],[11,"get_type_id","","",42,[[["self"]],["typeid"]]],[11,"to_owned","","",42,[[["self"]],["t"]]],[11,"clone_into","","",42,N],[11,"from","kfs_kernel::i386::registers::eflags","",43,[[["t"]],["t"]]],[11,"try_from","","",43,[[["u"]],["result"]]],[11,"try_into","","",43,[[["self"]],["result"]]],[11,"into","","",43,[[["self"]],["u"]]],[11,"borrow","","",43,[[["self"]],["t"]]],[11,"borrow_mut","","",43,[[["self"]],["t"]]],[11,"get_type_id","","",43,[[["self"]],["typeid"]]],[11,"to_owned","","",43,[[["self"]],["t"]]],[11,"clone_into","","",43,N],[11,"from","kfs_kernel::i386::stack","",44,[[["t"]],["t"]]],[11,"try_from","","",44,[[["u"]],["result"]]],[11,"try_into","","",44,[[["self"]],["result"]]],[11,"into","","",44,[[["self"]],["u"]]],[11,"borrow","","",44,[[["self"]],["t"]]],[11,"borrow_mut","","",44,[[["self"]],["t"]]],[11,"get_type_id","","",44,[[["self"]],["typeid"]]],[11,"from","","",45,[[["t"]],["t"]]],[11,"try_from","","",45,[[["u"]],["result"]]],[11,"try_into","","",45,[[["self"]],["result"]]],[11,"into","","",45,[[["self"]],["u"]]],[11,"borrow","","",45,[[["self"]],["t"]]],[11,"borrow_mut","","",45,[[["self"]],["t"]]],[11,"get_type_id","","",45,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::i386::structures::gdt","",46,[[["t"]],["t"]]],[11,"try_from","","",46,[[["u"]],["result"]]],[11,"try_into","","",46,[[["self"]],["result"]]],[11,"into","","",46,[[["self"]],["u"]]],[11,"borrow","","",46,[[["self"]],["t"]]],[11,"borrow_mut","","",46,[[["self"]],["t"]]],[11,"get_type_id","","",46,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::i386::structures::idt","",47,[[["t"]],["t"]]],[11,"try_from","","",47,[[["u"]],["result"]]],[11,"try_into","","",47,[[["self"]],["result"]]],[11,"into","","",47,[[["self"]],["u"]]],[11,"borrow","","",47,[[["self"]],["t"]]],[11,"borrow_mut","","",47,[[["self"]],["t"]]],[11,"get_type_id","","",47,[[["self"]],["typeid"]]],[11,"from","","",48,[[["t"]],["t"]]],[11,"try_from","","",48,[[["u"]],["result"]]],[11,"try_into","","",48,[[["self"]],["result"]]],[11,"into","","",48,[[["self"]],["u"]]],[11,"borrow","","",48,[[["self"]],["t"]]],[11,"borrow_mut","","",48,[[["self"]],["t"]]],[11,"get_type_id","","",48,[[["self"]],["typeid"]]],[11,"to_owned","","",48,[[["self"]],["t"]]],[11,"clone_into","","",48,N],[11,"from","","",49,[[["t"]],["t"]]],[11,"try_from","","",49,[[["u"]],["result"]]],[11,"try_into","","",49,[[["self"]],["result"]]],[11,"into","","",49,[[["self"]],["u"]]],[11,"borrow","","",49,[[["self"]],["t"]]],[11,"borrow_mut","","",49,[[["self"]],["t"]]],[11,"get_type_id","","",49,[[["self"]],["typeid"]]],[11,"to_owned","","",49,[[["self"]],["t"]]],[11,"clone_into","","",49,N],[11,"from","","",50,[[["t"]],["t"]]],[11,"try_from","","",50,[[["u"]],["result"]]],[11,"try_into","","",50,[[["self"]],["result"]]],[11,"into","","",50,[[["self"]],["u"]]],[11,"borrow","","",50,[[["self"]],["t"]]],[11,"borrow_mut","","",50,[[["self"]],["t"]]],[11,"get_type_id","","",50,[[["self"]],["typeid"]]],[11,"from","","",51,[[["t"]],["t"]]],[11,"try_from","","",51,[[["u"]],["result"]]],[11,"try_into","","",51,[[["self"]],["result"]]],[11,"into","","",51,[[["self"]],["u"]]],[11,"borrow","","",51,[[["self"]],["t"]]],[11,"borrow_mut","","",51,[[["self"]],["t"]]],[11,"get_type_id","","",51,[[["self"]],["typeid"]]],[11,"to_owned","","",51,[[["self"]],["t"]]],[11,"clone_into","","",51,N],[11,"from","kfs_kernel::i386::process_switch","",52,[[["t"]],["t"]]],[11,"try_from","","",52,[[["u"]],["result"]]],[11,"try_into","","",52,[[["self"]],["result"]]],[11,"into","","",52,[[["self"]],["u"]]],[11,"borrow","","",52,[[["self"]],["t"]]],[11,"borrow_mut","","",52,[[["self"]],["t"]]],[11,"get_type_id","","",52,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::i386::gdt","",53,[[["t"]],["t"]]],[11,"try_from","","",53,[[["u"]],["result"]]],[11,"try_into","","",53,[[["self"]],["result"]]],[11,"into","","",53,[[["self"]],["u"]]],[11,"borrow","","",53,[[["self"]],["t"]]],[11,"borrow_mut","","",53,[[["self"]],["t"]]],[11,"get_type_id","","",53,[[["self"]],["typeid"]]],[11,"from","","",54,[[["t"]],["t"]]],[11,"try_from","","",54,[[["u"]],["result"]]],[11,"try_into","","",54,[[["self"]],["result"]]],[11,"into","","",54,[[["self"]],["u"]]],[11,"borrow","","",54,[[["self"]],["t"]]],[11,"borrow_mut","","",54,[[["self"]],["t"]]],[11,"get_type_id","","",54,[[["self"]],["typeid"]]],[11,"from","","",55,[[["t"]],["t"]]],[11,"try_from","","",55,[[["u"]],["result"]]],[11,"try_into","","",55,[[["self"]],["result"]]],[11,"into","","",55,[[["self"]],["u"]]],[11,"borrow","","",55,[[["self"]],["t"]]],[11,"borrow_mut","","",55,[[["self"]],["t"]]],[11,"get_type_id","","",55,[[["self"]],["typeid"]]],[11,"to_owned","","",55,[[["self"]],["t"]]],[11,"clone_into","","",55,N],[11,"from","","",56,[[["t"]],["t"]]],[11,"try_from","","",56,[[["u"]],["result"]]],[11,"try_into","","",56,[[["self"]],["result"]]],[11,"into","","",56,[[["self"]],["u"]]],[11,"borrow","","",56,[[["self"]],["t"]]],[11,"borrow_mut","","",56,[[["self"]],["t"]]],[11,"get_type_id","","",56,[[["self"]],["typeid"]]],[11,"to_owned","","",56,[[["self"]],["t"]]],[11,"clone_into","","",56,N],[11,"from","","",57,[[["t"]],["t"]]],[11,"try_from","","",57,[[["u"]],["result"]]],[11,"try_into","","",57,[[["self"]],["result"]]],[11,"into","","",57,[[["self"]],["u"]]],[11,"borrow","","",57,[[["self"]],["t"]]],[11,"borrow_mut","","",57,[[["self"]],["t"]]],[11,"get_type_id","","",57,[[["self"]],["typeid"]]],[11,"to_owned","","",57,[[["self"]],["t"]]],[11,"clone_into","","",57,N],[11,"from","kfs_kernel::utils::io","",58,[[["t"]],["t"]]],[11,"try_from","","",58,[[["u"]],["result"]]],[11,"try_into","","",58,[[["self"]],["result"]]],[11,"into","","",58,[[["self"]],["u"]]],[11,"borrow","","",58,[[["self"]],["t"]]],[11,"borrow_mut","","",58,[[["self"]],["t"]]],[11,"get_type_id","","",58,[[["self"]],["typeid"]]],[11,"to_owned","","",58,[[["self"]],["t"]]],[11,"clone_into","","",58,N],[11,"from","kfs_kernel::i386::instructions::tables","",59,[[["t"]],["t"]]],[11,"try_from","","",59,[[["u"]],["result"]]],[11,"try_into","","",59,[[["self"]],["result"]]],[11,"into","","",59,[[["self"]],["u"]]],[11,"borrow","","",59,[[["self"]],["t"]]],[11,"borrow_mut","","",59,[[["self"]],["t"]]],[11,"get_type_id","","",59,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::interrupts","",60,[[["t"]],["t"]]],[11,"try_from","","",60,[[["u"]],["result"]]],[11,"try_into","","",60,[[["self"]],["result"]]],[11,"into","","",60,[[["self"]],["u"]]],[11,"borrow","","",60,[[["self"]],["t"]]],[11,"borrow_mut","","",60,[[["self"]],["t"]]],[11,"get_type_id","","",60,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::interrupts::syscalls","",61,[[["t"]],["t"]]],[11,"try_from","","",61,[[["u"]],["result"]]],[11,"try_into","","",61,[[["self"]],["result"]]],[11,"into","","",61,[[["self"]],["u"]]],[11,"borrow","","",61,[[["self"]],["t"]]],[11,"borrow_mut","","",61,[[["self"]],["t"]]],[11,"get_type_id","","",61,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::frame_allocator","",125,[[["t"]],["t"]]],[11,"try_from","","",125,[[["u"]],["result"]]],[11,"try_into","","",125,[[["self"]],["result"]]],[11,"into","","",125,[[["self"]],["u"]]],[11,"borrow","","",125,[[["self"]],["t"]]],[11,"borrow_mut","","",125,[[["self"]],["t"]]],[11,"get_type_id","","",125,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::frame_allocator::physical_mem_region","",62,[[["t"]],["t"]]],[11,"try_from","","",62,[[["u"]],["result"]]],[11,"try_into","","",62,[[["self"]],["result"]]],[11,"into","","",62,[[["self"]],["u"]]],[11,"borrow","","",62,[[["self"]],["t"]]],[11,"borrow_mut","","",62,[[["self"]],["t"]]],[11,"get_type_id","","",62,[[["self"]],["typeid"]]],[11,"into_iter","","",63,[[["self"]],["i"]]],[11,"from","","",63,[[["t"]],["t"]]],[11,"try_from","","",63,[[["u"]],["result"]]],[11,"try_into","","",63,[[["self"]],["result"]]],[11,"into","","",63,[[["self"]],["u"]]],[11,"borrow","","",63,[[["self"]],["t"]]],[11,"borrow_mut","","",63,[[["self"]],["t"]]],[11,"get_type_id","","",63,[[["self"]],["typeid"]]],[11,"to_owned","","",63,[[["self"]],["t"]]],[11,"clone_into","","",63,N],[11,"from","kfs_kernel::frame_allocator::i386","",64,[[["t"]],["t"]]],[11,"try_from","","",64,[[["u"]],["result"]]],[11,"try_into","","",64,[[["self"]],["result"]]],[11,"into","","",64,[[["self"]],["u"]]],[11,"borrow","","",64,[[["self"]],["t"]]],[11,"borrow_mut","","",64,[[["self"]],["t"]]],[11,"get_type_id","","",64,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::heap_allocator","",67,[[["t"]],["t"]]],[11,"try_from","","",67,[[["u"]],["result"]]],[11,"try_into","","",67,[[["self"]],["result"]]],[11,"into","","",67,[[["self"]],["u"]]],[11,"borrow","","",67,[[["self"]],["t"]]],[11,"borrow_mut","","",67,[[["self"]],["t"]]],[11,"get_type_id","","",67,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::devices::rs232","",68,[[["t"]],["t"]]],[11,"try_from","","",68,[[["u"]],["result"]]],[11,"try_into","","",68,[[["self"]],["result"]]],[11,"into","","",68,[[["self"]],["u"]]],[11,"borrow","","",68,[[["self"]],["t"]]],[11,"borrow_mut","","",68,[[["self"]],["t"]]],[11,"get_type_id","","",68,[[["self"]],["typeid"]]],[11,"to_owned","","",68,[[["self"]],["t"]]],[11,"clone_into","","",68,N],[11,"from","","",69,[[["t"]],["t"]]],[11,"try_from","","",69,[[["u"]],["result"]]],[11,"try_into","","",69,[[["self"]],["result"]]],[11,"into","","",69,[[["self"]],["u"]]],[11,"borrow","","",69,[[["self"]],["t"]]],[11,"borrow_mut","","",69,[[["self"]],["t"]]],[11,"get_type_id","","",69,[[["self"]],["typeid"]]],[11,"to_owned","","",69,[[["self"]],["t"]]],[11,"clone_into","","",69,N],[11,"to_string","","",69,[[["self"]],["string"]]],[11,"from","","",70,[[["t"]],["t"]]],[11,"try_from","","",70,[[["u"]],["result"]]],[11,"try_into","","",70,[[["self"]],["result"]]],[11,"into","","",70,[[["self"]],["u"]]],[11,"borrow","","",70,[[["self"]],["t"]]],[11,"borrow_mut","","",70,[[["self"]],["t"]]],[11,"get_type_id","","",70,[[["self"]],["typeid"]]],[11,"from","","",72,[[["t"]],["t"]]],[11,"try_from","","",72,[[["u"]],["result"]]],[11,"try_into","","",72,[[["self"]],["result"]]],[11,"into","","",72,[[["self"]],["u"]]],[11,"borrow","","",72,[[["self"]],["t"]]],[11,"borrow_mut","","",72,[[["self"]],["t"]]],[11,"get_type_id","","",72,[[["self"]],["typeid"]]],[11,"from","","",71,[[["t"]],["t"]]],[11,"try_from","","",71,[[["u"]],["result"]]],[11,"try_into","","",71,[[["self"]],["result"]]],[11,"into","","",71,[[["self"]],["u"]]],[11,"borrow","","",71,[[["self"]],["t"]]],[11,"borrow_mut","","",71,[[["self"]],["t"]]],[11,"get_type_id","","",71,[[["self"]],["typeid"]]],[11,"to_owned","","",71,[[["self"]],["t"]]],[11,"clone_into","","",71,N],[11,"from","kfs_kernel::devices::pit","",73,[[["t"]],["t"]]],[11,"try_from","","",73,[[["u"]],["result"]]],[11,"try_into","","",73,[[["self"]],["result"]]],[11,"into","","",73,[[["self"]],["u"]]],[11,"borrow","","",73,[[["self"]],["t"]]],[11,"borrow_mut","","",73,[[["self"]],["t"]]],[11,"get_type_id","","",73,[[["self"]],["typeid"]]],[11,"from","","",74,[[["t"]],["t"]]],[11,"try_from","","",74,[[["u"]],["result"]]],[11,"try_into","","",74,[[["self"]],["result"]]],[11,"into","","",74,[[["self"]],["u"]]],[11,"borrow","","",74,[[["self"]],["t"]]],[11,"borrow_mut","","",74,[[["self"]],["t"]]],[11,"get_type_id","","",74,[[["self"]],["typeid"]]],[11,"to_owned","","",74,[[["self"]],["t"]]],[11,"clone_into","","",74,N],[11,"from","","",75,[[["t"]],["t"]]],[11,"try_from","","",75,[[["u"]],["result"]]],[11,"try_into","","",75,[[["self"]],["result"]]],[11,"into","","",75,[[["self"]],["u"]]],[11,"borrow","","",75,[[["self"]],["t"]]],[11,"borrow_mut","","",75,[[["self"]],["t"]]],[11,"get_type_id","","",75,[[["self"]],["typeid"]]],[11,"from","","",76,[[["t"]],["t"]]],[11,"try_from","","",76,[[["u"]],["result"]]],[11,"try_into","","",76,[[["self"]],["result"]]],[11,"into","","",76,[[["self"]],["u"]]],[11,"borrow","","",76,[[["self"]],["t"]]],[11,"borrow_mut","","",76,[[["self"]],["t"]]],[11,"get_type_id","","",76,[[["self"]],["typeid"]]],[11,"from","","",77,[[["t"]],["t"]]],[11,"try_from","","",77,[[["u"]],["result"]]],[11,"try_into","","",77,[[["self"]],["result"]]],[11,"into","","",77,[[["self"]],["u"]]],[11,"borrow","","",77,[[["self"]],["t"]]],[11,"borrow_mut","","",77,[[["self"]],["t"]]],[11,"get_type_id","","",77,[[["self"]],["typeid"]]],[11,"from","","",78,[[["t"]],["t"]]],[11,"try_from","","",78,[[["u"]],["result"]]],[11,"try_into","","",78,[[["self"]],["result"]]],[11,"into","","",78,[[["self"]],["u"]]],[11,"borrow","","",78,[[["self"]],["t"]]],[11,"borrow_mut","","",78,[[["self"]],["t"]]],[11,"get_type_id","","",78,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::devices::pic","",79,[[["t"]],["t"]]],[11,"try_from","","",79,[[["u"]],["result"]]],[11,"try_into","","",79,[[["self"]],["result"]]],[11,"into","","",79,[[["self"]],["u"]]],[11,"borrow","","",79,[[["self"]],["t"]]],[11,"borrow_mut","","",79,[[["self"]],["t"]]],[11,"get_type_id","","",79,[[["self"]],["typeid"]]],[11,"to_owned","","",79,[[["self"]],["t"]]],[11,"clone_into","","",79,N],[11,"from","","",80,[[["t"]],["t"]]],[11,"try_from","","",80,[[["u"]],["result"]]],[11,"try_into","","",80,[[["self"]],["result"]]],[11,"into","","",80,[[["self"]],["u"]]],[11,"borrow","","",80,[[["self"]],["t"]]],[11,"borrow_mut","","",80,[[["self"]],["t"]]],[11,"get_type_id","","",80,[[["self"]],["typeid"]]],[11,"from","","",81,[[["t"]],["t"]]],[11,"try_from","","",81,[[["u"]],["result"]]],[11,"try_into","","",81,[[["self"]],["result"]]],[11,"into","","",81,[[["self"]],["u"]]],[11,"borrow","","",81,[[["self"]],["t"]]],[11,"borrow_mut","","",81,[[["self"]],["t"]]],[11,"get_type_id","","",81,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::sync","",82,[[["t"]],["t"]]],[11,"try_from","","",82,[[["u"]],["result"]]],[11,"try_into","","",82,[[["self"]],["result"]]],[11,"into","","",82,[[["self"]],["u"]]],[11,"borrow","","",82,[[["self"]],["t"]]],[11,"borrow_mut","","",82,[[["self"]],["t"]]],[11,"get_type_id","","",82,[[["self"]],["typeid"]]],[11,"from","","",83,[[["t"]],["t"]]],[11,"try_from","","",83,[[["u"]],["result"]]],[11,"try_into","","",83,[[["self"]],["result"]]],[11,"into","","",83,[[["self"]],["u"]]],[11,"borrow","","",83,[[["self"]],["t"]]],[11,"borrow_mut","","",83,[[["self"]],["t"]]],[11,"get_type_id","","",83,[[["self"]],["typeid"]]],[11,"from","","",84,[[["t"]],["t"]]],[11,"try_from","","",84,[[["u"]],["result"]]],[11,"try_into","","",84,[[["self"]],["result"]]],[11,"into","","",84,[[["self"]],["u"]]],[11,"borrow","","",84,[[["self"]],["t"]]],[11,"borrow_mut","","",84,[[["self"]],["t"]]],[11,"get_type_id","","",84,[[["self"]],["typeid"]]],[11,"from","","",85,[[["t"]],["t"]]],[11,"try_from","","",85,[[["u"]],["result"]]],[11,"try_into","","",85,[[["self"]],["result"]]],[11,"into","","",85,[[["self"]],["u"]]],[11,"borrow","","",85,[[["self"]],["t"]]],[11,"borrow_mut","","",85,[[["self"]],["t"]]],[11,"get_type_id","","",85,[[["self"]],["typeid"]]],[11,"from","","",86,[[["t"]],["t"]]],[11,"try_from","","",86,[[["u"]],["result"]]],[11,"try_into","","",86,[[["self"]],["result"]]],[11,"into","","",86,[[["self"]],["u"]]],[11,"borrow","","",86,[[["self"]],["t"]]],[11,"borrow_mut","","",86,[[["self"]],["t"]]],[11,"get_type_id","","",86,[[["self"]],["typeid"]]],[11,"from","","",87,[[["t"]],["t"]]],[11,"try_from","","",87,[[["u"]],["result"]]],[11,"try_into","","",87,[[["self"]],["result"]]],[11,"into","","",87,[[["self"]],["u"]]],[11,"borrow","","",87,[[["self"]],["t"]]],[11,"borrow_mut","","",87,[[["self"]],["t"]]],[11,"get_type_id","","",87,[[["self"]],["typeid"]]],[11,"from","","",88,[[["t"]],["t"]]],[11,"try_from","","",88,[[["u"]],["result"]]],[11,"try_into","","",88,[[["self"]],["result"]]],[11,"into","","",88,[[["self"]],["u"]]],[11,"borrow","","",88,[[["self"]],["t"]]],[11,"borrow_mut","","",88,[[["self"]],["t"]]],[11,"get_type_id","","",88,[[["self"]],["typeid"]]],[11,"from","","",89,[[["t"]],["t"]]],[11,"try_from","","",89,[[["u"]],["result"]]],[11,"try_into","","",89,[[["self"]],["result"]]],[11,"into","","",89,[[["self"]],["u"]]],[11,"borrow","","",89,[[["self"]],["t"]]],[11,"borrow_mut","","",89,[[["self"]],["t"]]],[11,"get_type_id","","",89,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::process","",91,[[["t"]],["t"]]],[11,"try_from","","",91,[[["u"]],["result"]]],[11,"try_into","","",91,[[["self"]],["result"]]],[11,"into","","",91,[[["self"]],["u"]]],[11,"borrow","","",91,[[["self"]],["t"]]],[11,"borrow_mut","","",91,[[["self"]],["t"]]],[11,"get_type_id","","",91,[[["self"]],["typeid"]]],[11,"from","","",92,[[["t"]],["t"]]],[11,"try_from","","",92,[[["u"]],["result"]]],[11,"try_into","","",92,[[["self"]],["result"]]],[11,"into","","",92,[[["self"]],["u"]]],[11,"borrow","","",92,[[["self"]],["t"]]],[11,"borrow_mut","","",92,[[["self"]],["t"]]],[11,"get_type_id","","",92,[[["self"]],["typeid"]]],[11,"from","","",93,[[["t"]],["t"]]],[11,"try_from","","",93,[[["u"]],["result"]]],[11,"try_into","","",93,[[["self"]],["result"]]],[11,"into","","",93,[[["self"]],["u"]]],[11,"borrow","","",93,[[["self"]],["t"]]],[11,"borrow_mut","","",93,[[["self"]],["t"]]],[11,"get_type_id","","",93,[[["self"]],["typeid"]]],[11,"from","","",94,[[["t"]],["t"]]],[11,"try_from","","",94,[[["u"]],["result"]]],[11,"try_into","","",94,[[["self"]],["result"]]],[11,"into","","",94,[[["self"]],["u"]]],[11,"borrow","","",94,[[["self"]],["t"]]],[11,"borrow_mut","","",94,[[["self"]],["t"]]],[11,"get_type_id","","",94,[[["self"]],["typeid"]]],[11,"from","","",95,[[["t"]],["t"]]],[11,"try_from","","",95,[[["u"]],["result"]]],[11,"try_into","","",95,[[["self"]],["result"]]],[11,"into","","",95,[[["self"]],["u"]]],[11,"borrow","","",95,[[["self"]],["t"]]],[11,"borrow_mut","","",95,[[["self"]],["t"]]],[11,"get_type_id","","",95,[[["self"]],["typeid"]]],[11,"from","","",96,[[["t"]],["t"]]],[11,"try_from","","",96,[[["u"]],["result"]]],[11,"try_into","","",96,[[["self"]],["result"]]],[11,"into","","",96,[[["self"]],["u"]]],[11,"borrow","","",96,[[["self"]],["t"]]],[11,"borrow_mut","","",96,[[["self"]],["t"]]],[11,"get_type_id","","",96,[[["self"]],["typeid"]]],[11,"to_owned","","",96,[[["self"]],["t"]]],[11,"clone_into","","",96,N],[11,"from","kfs_kernel::mem","",97,[[["t"]],["t"]]],[11,"try_from","","",97,[[["u"]],["result"]]],[11,"try_into","","",97,[[["self"]],["result"]]],[11,"into","","",97,[[["self"]],["u"]]],[11,"borrow","","",97,[[["self"]],["t"]]],[11,"borrow_mut","","",97,[[["self"]],["t"]]],[11,"get_type_id","","",97,[[["self"]],["typeid"]]],[11,"to_owned","","",97,[[["self"]],["t"]]],[11,"clone_into","","",97,N],[11,"to_string","","",97,[[["self"]],["string"]]],[11,"from","","",98,[[["t"]],["t"]]],[11,"try_from","","",98,[[["u"]],["result"]]],[11,"try_into","","",98,[[["self"]],["result"]]],[11,"into","","",98,[[["self"]],["u"]]],[11,"borrow","","",98,[[["self"]],["t"]]],[11,"borrow_mut","","",98,[[["self"]],["t"]]],[11,"get_type_id","","",98,[[["self"]],["typeid"]]],[11,"to_owned","","",98,[[["self"]],["t"]]],[11,"clone_into","","",98,N],[11,"to_string","","",98,[[["self"]],["string"]]],[11,"from","","",99,[[["t"]],["t"]]],[11,"try_from","","",99,[[["u"]],["result"]]],[11,"try_into","","",99,[[["self"]],["result"]]],[11,"into","","",99,[[["self"]],["u"]]],[11,"borrow","","",99,[[["self"]],["t"]]],[11,"borrow_mut","","",99,[[["self"]],["t"]]],[11,"get_type_id","","",99,[[["self"]],["typeid"]]],[11,"to_owned","","",99,[[["self"]],["t"]]],[11,"clone_into","","",99,N],[11,"from","","",100,[[["t"]],["t"]]],[11,"try_from","","",100,[[["u"]],["result"]]],[11,"try_into","","",100,[[["self"]],["result"]]],[11,"into","","",100,[[["self"]],["u"]]],[11,"borrow","","",100,[[["self"]],["t"]]],[11,"borrow_mut","","",100,[[["self"]],["t"]]],[11,"get_type_id","","",100,[[["self"]],["typeid"]]],[11,"to_owned","","",100,[[["self"]],["t"]]],[11,"clone_into","","",100,N],[11,"from","","",101,[[["t"]],["t"]]],[11,"try_from","","",101,[[["u"]],["result"]]],[11,"try_into","","",101,[[["self"]],["result"]]],[11,"into","","",101,[[["self"]],["u"]]],[11,"borrow","","",101,[[["self"]],["t"]]],[11,"borrow_mut","","",101,[[["self"]],["t"]]],[11,"get_type_id","","",101,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::ipc","",102,[[["t"]],["t"]]],[11,"try_from","","",102,[[["u"]],["result"]]],[11,"try_into","","",102,[[["self"]],["result"]]],[11,"into","","",102,[[["self"]],["u"]]],[11,"borrow","","",102,[[["self"]],["t"]]],[11,"borrow_mut","","",102,[[["self"]],["t"]]],[11,"get_type_id","","",102,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::ipc::session","",103,[[["t"]],["t"]]],[11,"try_from","","",103,[[["u"]],["result"]]],[11,"try_into","","",103,[[["self"]],["result"]]],[11,"into","","",103,[[["self"]],["u"]]],[11,"borrow","","",103,[[["self"]],["t"]]],[11,"borrow_mut","","",103,[[["self"]],["t"]]],[11,"get_type_id","","",103,[[["self"]],["typeid"]]],[11,"from","","",104,[[["t"]],["t"]]],[11,"try_from","","",104,[[["u"]],["result"]]],[11,"try_into","","",104,[[["self"]],["result"]]],[11,"into","","",104,[[["self"]],["u"]]],[11,"borrow","","",104,[[["self"]],["t"]]],[11,"borrow_mut","","",104,[[["self"]],["t"]]],[11,"get_type_id","","",104,[[["self"]],["typeid"]]],[11,"from","","",105,[[["t"]],["t"]]],[11,"try_from","","",105,[[["u"]],["result"]]],[11,"try_into","","",105,[[["self"]],["result"]]],[11,"into","","",105,[[["self"]],["u"]]],[11,"borrow","","",105,[[["self"]],["t"]]],[11,"borrow_mut","","",105,[[["self"]],["t"]]],[11,"get_type_id","","",105,[[["self"]],["typeid"]]],[11,"to_owned","","",105,[[["self"]],["t"]]],[11,"clone_into","","",105,N],[11,"from","","",106,[[["t"]],["t"]]],[11,"try_from","","",106,[[["u"]],["result"]]],[11,"try_into","","",106,[[["self"]],["result"]]],[11,"into","","",106,[[["self"]],["u"]]],[11,"borrow","","",106,[[["self"]],["t"]]],[11,"borrow_mut","","",106,[[["self"]],["t"]]],[11,"get_type_id","","",106,[[["self"]],["typeid"]]],[11,"to_owned","","",106,[[["self"]],["t"]]],[11,"clone_into","","",106,N],[11,"from","","",107,[[["t"]],["t"]]],[11,"try_from","","",107,[[["u"]],["result"]]],[11,"try_into","","",107,[[["self"]],["result"]]],[11,"into","","",107,[[["self"]],["u"]]],[11,"borrow","","",107,[[["self"]],["t"]]],[11,"borrow_mut","","",107,[[["self"]],["t"]]],[11,"get_type_id","","",107,[[["self"]],["typeid"]]],[11,"bit","","",107,[[["self"],["usize"]],["bool"]]],[11,"set_bit","","",107,N],[11,"from","","",108,[[["t"]],["t"]]],[11,"try_from","","",108,[[["u"]],["result"]]],[11,"try_into","","",108,[[["self"]],["result"]]],[11,"into","","",108,[[["self"]],["u"]]],[11,"borrow","","",108,[[["self"]],["t"]]],[11,"borrow_mut","","",108,[[["self"]],["t"]]],[11,"get_type_id","","",108,[[["self"]],["typeid"]]],[11,"bit","","",108,[[["self"],["usize"]],["bool"]]],[11,"set_bit","","",108,N],[11,"from","","",109,[[["t"]],["t"]]],[11,"try_from","","",109,[[["u"]],["result"]]],[11,"try_into","","",109,[[["self"]],["result"]]],[11,"into","","",109,[[["self"]],["u"]]],[11,"borrow","","",109,[[["self"]],["t"]]],[11,"borrow_mut","","",109,[[["self"]],["t"]]],[11,"get_type_id","","",109,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::ipc::port","",110,[[["t"]],["t"]]],[11,"try_from","","",110,[[["u"]],["result"]]],[11,"try_into","","",110,[[["self"]],["result"]]],[11,"into","","",110,[[["self"]],["u"]]],[11,"borrow","","",110,[[["self"]],["t"]]],[11,"borrow_mut","","",110,[[["self"]],["t"]]],[11,"get_type_id","","",110,[[["self"]],["typeid"]]],[11,"from","","",111,[[["t"]],["t"]]],[11,"try_from","","",111,[[["u"]],["result"]]],[11,"try_into","","",111,[[["self"]],["result"]]],[11,"into","","",111,[[["self"]],["u"]]],[11,"borrow","","",111,[[["self"]],["t"]]],[11,"borrow_mut","","",111,[[["self"]],["t"]]],[11,"get_type_id","","",111,[[["self"]],["typeid"]]],[11,"to_owned","","",111,[[["self"]],["t"]]],[11,"clone_into","","",111,N],[11,"from","","",112,[[["t"]],["t"]]],[11,"try_from","","",112,[[["u"]],["result"]]],[11,"try_into","","",112,[[["self"]],["result"]]],[11,"into","","",112,[[["self"]],["u"]]],[11,"borrow","","",112,[[["self"]],["t"]]],[11,"borrow_mut","","",112,[[["self"]],["t"]]],[11,"get_type_id","","",112,[[["self"]],["typeid"]]],[11,"to_owned","","",112,[[["self"]],["t"]]],[11,"clone_into","","",112,N],[11,"from","","",113,[[["t"]],["t"]]],[11,"try_from","","",113,[[["u"]],["result"]]],[11,"try_into","","",113,[[["self"]],["result"]]],[11,"into","","",113,[[["self"]],["u"]]],[11,"borrow","","",113,[[["self"]],["t"]]],[11,"borrow_mut","","",113,[[["self"]],["t"]]],[11,"get_type_id","","",113,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::elf_loader","",114,[[["t"]],["t"]]],[11,"try_from","","",114,[[["u"]],["result"]]],[11,"try_into","","",114,[[["self"]],["result"]]],[11,"into","","",114,[[["self"]],["u"]]],[11,"borrow","","",114,[[["self"]],["t"]]],[11,"borrow_mut","","",114,[[["self"]],["t"]]],[11,"get_type_id","","",114,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::utils::io","",116,[[["t"]],["t"]]],[11,"try_from","","",116,[[["u"]],["result"]]],[11,"try_into","","",116,[[["self"]],["result"]]],[11,"into","","",116,[[["self"]],["u"]]],[11,"borrow","","",116,[[["self"]],["t"]]],[11,"borrow_mut","","",116,[[["self"]],["t"]]],[11,"get_type_id","","",116,[[["self"]],["typeid"]]],[11,"from","","",117,[[["t"]],["t"]]],[11,"try_from","","",117,[[["u"]],["result"]]],[11,"try_into","","",117,[[["self"]],["result"]]],[11,"into","","",117,[[["self"]],["u"]]],[11,"borrow","","",117,[[["self"]],["t"]]],[11,"borrow_mut","","",117,[[["self"]],["t"]]],[11,"get_type_id","","",117,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::utils","",119,[[["t"]],["t"]]],[11,"try_from","","",119,[[["u"]],["result"]]],[11,"try_into","","",119,[[["self"]],["result"]]],[11,"into","","",119,[[["self"]],["u"]]],[11,"borrow","","",119,[[["self"]],["t"]]],[11,"borrow_mut","","",119,[[["self"]],["t"]]],[11,"get_type_id","","",119,[[["self"]],["typeid"]]],[11,"from","","",120,[[["t"]],["t"]]],[11,"try_from","","",120,[[["u"]],["result"]]],[11,"try_into","","",120,[[["self"]],["result"]]],[11,"into","","",120,[[["self"]],["u"]]],[11,"borrow","","",120,[[["self"]],["t"]]],[11,"borrow_mut","","",120,[[["self"]],["t"]]],[11,"get_type_id","","",120,[[["self"]],["typeid"]]],[11,"fmt","kfs_kernel::error","",32,[[["self"],["formatter"]],["result",["error"]]]],[11,"clone","","",32,[[["self"]],["kernelerror"]]],[11,"eq","","",32,[[["self"],["kernelerror"]],["bool"]]],[11,"ne","","",32,[[["self"],["kernelerror"]],["bool"]]],[11,"fmt","","",32,[[["self"],["formatter"]],["result",["error"]]]],[11,"assert_receiver_is_total_eq","","",32,N],[11,"clone","kfs_kernel::utils::io","",58,[[["self"]],["pio"]]],[11,"read","","Read",58,[[["self"]],["u8"]]],[11,"write","","Write",58,N],[11,"read","","Read",58,[[["self"]],["u16"]]],[11,"write","","Write",58,N],[11,"read","","Read",58,[[["self"]],["u32"]]],[11,"write","","Write",58,N],[11,"fmt","kfs_kernel::sync","",86,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",84,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",82,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",85,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",87,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",83,[[["self"],["formatter"]],["result",["error"]]]],[11,"drop","","",85,N],[11,"drop","","The dropping of the MutexGuard will release the lock it…",87,N],[11,"drop","","",84,N],[11,"deref","","",85,[[["self"]],["t"]]],[11,"deref","","",84,[[["self"]],["t"]]],[11,"deref","","",87,[[["self"]],["t"]]],[11,"deref_mut","","",85,[[["self"]],["t"]]],[11,"deref_mut","","",87,[[["self"]],["t"]]],[11,"default","","",83,[[],["rwlock"]]],[11,"default","","",86,[[],["mutex"]]],[11,"start_addr","kfs_kernel::paging::lands","",8,[[],["virtualaddress"]]],[11,"end_addr","","",8,[[],["virtualaddress"]]],[11,"start_addr","","",7,[[],["virtualaddress"]]],[11,"end_addr","","",7,[[],["virtualaddress"]]],[11,"start_addr","","",9,[[],["virtualaddress"]]],[11,"end_addr","","",9,[[],["virtualaddress"]]],[11,"is_unused","kfs_kernel::paging::arch::i386::entry","Is the entry unused ?",21,[[["self"]],["bool"]]],[11,"set_unused","","Clear the entry",21,[[["self"]],["pagestate",["physicaladdress"]]]],[11,"is_guard","","Is the entry a page guard ?",21,[[["self"]],["bool"]]],[11,"flags","","Get the current entry flags",21,[[["self"]],["i386entryflags"]]],[11,"pointed_frame","","Get the associated physical address, if available",21,[[["self"]],["pagestate",["physicaladdress"]]]],[11,"set","","Sets the entry",21,[[["self"],["physicaladdress"],["i386entryflags"]]]],[11,"set_guard","","Make this entry a page guard",21,[[["self"]]]],[11,"entries","kfs_kernel::paging::arch::i386::table","",23,N],[11,"table_level","","",23,[[],["usize"]]],[11,"get_child_table","","",23,[[["self"],["usize"]],["pagestate",["smarthierarchicaltable"]]]],[11,"create_child_table","","",23,[[["self"],["usize"]],["smarthierarchicaltable"]]],[11,"entries","","",24,N],[11,"table_level","","",24,[[],["usize"]]],[11,"get_child_table","","",24,[[["self"],["usize"]],["pagestate",["smarthierarchicaltable"]]]],[11,"create_child_table","","",24,[[["self"],["usize"]],["smarthierarchicaltable",["activepagetable"]]]],[11,"entries","","",25,N],[11,"table_level","","",25,[[],["usize"]]],[11,"get_child_table","","",25,[[["self"],["usize"]],["pagestate",["smarthierarchicaltable"]]]],[11,"create_child_table","","",25,[[["self"],["usize"]],["smarthierarchicaltable"]]],[11,"entries","","",26,N],[11,"table_level","","",26,[[],["usize"]]],[11,"get_child_table","","",26,[[["self"],["usize"]],["pagestate",["smarthierarchicaltable"]]]],[11,"create_child_table","","",26,[[["self"],["usize"]],["smarthierarchicaltable",["inactivepagetable"]]]],[11,"flush_whole_cache","kfs_kernel::paging::hierarchical_table","",122,[[]]],[11,"flush_whole_cache","kfs_kernel::paging::arch::i386::table","",124,[[]]],[11,"get_top_level_table","kfs_kernel::paging::process_memory","",4,[[["self"]],["smarthierarchicaltable"]]],[11,"map_to_from_iterator","","",4,[[["self"],["i"],["virtualaddress"],["mappingflags"]]]],[11,"guard","","",4,[[["self"],["virtualaddress"],["usize"]]]],[11,"unmap","","",4,[[["self"],["virtualaddress"],["usize"],["c"]]]],[11,"for_every_entry","","",4,[[["self"],["virtualaddress"],["usize"],["c"]]]],[11,"find_available_virtual_space_aligned","","",4,[[["self"],["usize"],["virtualaddress"],["virtualaddress"],["usize"]],["option",["virtualaddress"]]]],[11,"get_top_level_table","kfs_kernel::paging::arch::i386::table","",123,[[["self"]],["smarthierarchicaltable",["activepagedirectory"]]]],[11,"get_top_level_table","","",27,[[["self"]],["smarthierarchicaltable",["inactivepagedirectory"]]]],[11,"new","","",27,[[],["self"]]],[11,"switch_to","","",27,[[["self"]]]],[11,"copy_active_kernel_space","","",27,[[["self"]]]],[11,"is_currently_active","","",27,[[["self"]],["bool"]]],[11,"from_currently_active","","",27,[[],["self"]]],[11,"is_signaled","kfs_kernel::event","",29,[[["self"]],["bool"]]],[11,"register","","",29,[[["self"]]]],[11,"register","kfs_kernel::devices::pit","",77,[[["self"]]]],[11,"is_signaled","","",77,[[["self"]],["bool"]]],[11,"is_signaled","kfs_kernel::ipc::session","",106,[[["self"]],["bool"]]],[11,"register","","",106,[[["self"]]]],[11,"is_signaled","kfs_kernel::ipc::port","",112,[[["self"]],["bool"]]],[11,"register","","",112,[[["self"]]]],[11,"allocate_region","kfs_kernel::frame_allocator","Allocates a single [PhysicalMemRegion]. Frames are…",125,[[["usize"]],["result",["physicalmemregion","kernelerror"]]]],[11,"allocate_frames_fragmented","","Allocates physical frames, possibly fragmented across…",125,[[["usize"]],["result",["vec","kernelerror"]]]],[11,"free_region","","Frees an allocated physical region.",125,[[["physicalmemregion"]]]],[11,"check_is_allocated","","Checks that a physical region is marked allocated.",125,[[["physicaladdress"],["usize"]],["bool"]]],[11,"check_is_reserved","","Checks that a physical region is marked reserved. This…",125,[[["physicaladdress"],["usize"]],["bool"]]],[11,"lock","kfs_kernel::sync","",86,[[["self"]],["spinlockguard"]]],[11,"lock","","",88,[[["self"]],["spinlockirqguard"]]],[11,"lock","","",83,[[["self"]],["rwlockreadguard"]]],[11,"lock","","",83,[[["self"]],["rwlockwriteguard"]]],[11,"split_at","kfs_kernel::paging::mapping","Splits a mapping at a given offset.",10,[[["self"],["usize"]],["result",["option","kernelerror"]]]],[11,"split_at","kfs_kernel::frame_allocator::physical_mem_region","Splits the given PhysicalMemRegion in two parts, at the…",62,[[["self"],["usize"]],["result",["option","kernelerror"]]]],[11,"PRESENT","kfs_kernel::paging::arch::i386::entry","",20,[[["self"]],["bool"]]],[11,"WRITABLE","","",20,[[["self"]],["bool"]]],[11,"USER_ACCESSIBLE","","",20,[[["self"]],["bool"]]],[11,"WRITE_THROUGH","","",20,[[["self"]],["bool"]]],[11,"NO_CACHE","","",20,[[["self"]],["bool"]]],[11,"ACCESSED","","",20,[[["self"]],["bool"]]],[11,"DIRTY","","",20,[[["self"]],["bool"]]],[11,"HUGE_PAGE","","",20,[[["self"]],["bool"]]],[11,"GLOBAL","","",20,[[["self"]],["bool"]]],[11,"GUARD_PAGE","","",20,[[["self"]],["bool"]]],[11,"USER_DEFINED_2","","",20,[[["self"]],["bool"]]],[11,"USER_DEFINED_3","","",20,[[["self"]],["bool"]]],[11,"PRESENT","","",20,[[],["u32"]]],[11,"WRITABLE","","",20,[[],["u32"]]],[11,"USER_ACCESSIBLE","","",20,[[],["u32"]]],[11,"WRITE_THROUGH","","",20,[[],["u32"]]],[11,"NO_CACHE","","",20,[[],["u32"]]],[11,"ACCESSED","","",20,[[],["u32"]]],[11,"DIRTY","","",20,[[],["u32"]]],[11,"HUGE_PAGE","","",20,[[],["u32"]]],[11,"GLOBAL","","",20,[[],["u32"]]],[11,"GUARD_PAGE","","",20,[[],["u32"]]],[11,"USER_DEFINED_2","","",20,[[],["u32"]]],[11,"USER_DEFINED_3","","",20,[[],["u32"]]],[11,"READABLE","kfs_kernel::paging","",0,[[["self"]],["bool"]]],[11,"WRITABLE","","",0,[[["self"]],["bool"]]],[11,"EXECUTABLE","","",0,[[["self"]],["bool"]]],[11,"USER_ACCESSIBLE","","",0,[[["self"]],["bool"]]],[11,"READABLE","","",0,[[],["u32"]]],[11,"WRITABLE","","",0,[[],["u32"]]],[11,"EXECUTABLE","","",0,[[],["u32"]]],[11,"USER_ACCESSIBLE","","",0,[[],["u32"]]],[11,"ID","kfs_kernel::i386::registers::eflags","",43,[[["self"]],["bool"]]],[11,"VIRTUAL_INTERRUPT_PENDING","","",43,[[["self"]],["bool"]]],[11,"VIRTUAL_INTERRUPT","","",43,[[["self"]],["bool"]]],[11,"ALIGNMENT_CHECK","","",43,[[["self"]],["bool"]]],[11,"VIRTUAL_8086_MODE","","",43,[[["self"]],["bool"]]],[11,"RESUME_FLAG","","",43,[[["self"]],["bool"]]],[11,"NESTED_TASK","","",43,[[["self"]],["bool"]]],[11,"IOPL_HIGH","","",43,[[["self"]],["bool"]]],[11,"IOPL_LOW","","",43,[[["self"]],["bool"]]],[11,"OVERFLOW_FLAG","","",43,[[["self"]],["bool"]]],[11,"DIRECTION_FLAG","","",43,[[["self"]],["bool"]]],[11,"INTERRUPT_FLAG","","",43,[[["self"]],["bool"]]],[11,"TRAP_FLAG","","",43,[[["self"]],["bool"]]],[11,"SIGN_FLAG","","",43,[[["self"]],["bool"]]],[11,"ZERO_FLAG","","",43,[[["self"]],["bool"]]],[11,"AUXILIARY_CARRY_FLAG","","",43,[[["self"]],["bool"]]],[11,"PARITY_FLAG","","",43,[[["self"]],["bool"]]],[11,"CARRY_FLAG","","",43,[[["self"]],["bool"]]],[11,"ID","","",43,[[],["u32"]]],[11,"VIRTUAL_INTERRUPT_PENDING","","",43,[[],["u32"]]],[11,"VIRTUAL_INTERRUPT","","",43,[[],["u32"]]],[11,"ALIGNMENT_CHECK","","",43,[[],["u32"]]],[11,"VIRTUAL_8086_MODE","","",43,[[],["u32"]]],[11,"RESUME_FLAG","","",43,[[],["u32"]]],[11,"NESTED_TASK","","",43,[[],["u32"]]],[11,"IOPL_HIGH","","",43,[[],["u32"]]],[11,"IOPL_LOW","","",43,[[],["u32"]]],[11,"OVERFLOW_FLAG","","",43,[[],["u32"]]],[11,"DIRECTION_FLAG","","",43,[[],["u32"]]],[11,"INTERRUPT_FLAG","","",43,[[],["u32"]]],[11,"TRAP_FLAG","","",43,[[],["u32"]]],[11,"SIGN_FLAG","","",43,[[],["u32"]]],[11,"ZERO_FLAG","","",43,[[],["u32"]]],[11,"AUXILIARY_CARRY_FLAG","","",43,[[],["u32"]]],[11,"PARITY_FLAG","","",43,[[],["u32"]]],[11,"CARRY_FLAG","","",43,[[],["u32"]]],[11,"PROTECTION_VIOLATION","kfs_kernel::i386::structures::idt","",51,[[["self"]],["bool"]]],[11,"CAUSED_BY_WRITE","","",51,[[["self"]],["bool"]]],[11,"USER_MODE","","",51,[[["self"]],["bool"]]],[11,"MALFORMED_TABLE","","",51,[[["self"]],["bool"]]],[11,"INSTRUCTION_FETCH","","",51,[[["self"]],["bool"]]],[11,"PROTECTION_VIOLATION","","",51,[[],["u32"]]],[11,"CAUSED_BY_WRITE","","",51,[[],["u32"]]],[11,"USER_MODE","","",51,[[],["u32"]]],[11,"MALFORMED_TABLE","","",51,[[],["u32"]]],[11,"INSTRUCTION_FETCH","","",51,[[],["u32"]]],[11,"SPKR_CONTROL","kfs_kernel::devices::pit","",74,[[["self"]],["bool"]]],[11,"OUT2_STATUS","","",74,[[["self"]],["bool"]]],[11,"GATE_2","","",74,[[["self"]],["bool"]]],[11,"OUT1_STATUS","","",74,[[["self"]],["bool"]]],[11,"OTHER_2","","",74,[[["self"]],["bool"]]],[11,"OTHER_3","","",74,[[["self"]],["bool"]]],[11,"OTHER_6","","",74,[[["self"]],["bool"]]],[11,"OTHER_7","","",74,[[["self"]],["bool"]]],[11,"SPKR_CONTROL","","",74,[[],["u8"]]],[11,"OUT2_STATUS","","",74,[[],["u8"]]],[11,"GATE_2","","",74,[[],["u8"]]],[11,"OUT1_STATUS","","",74,[[],["u8"]]],[11,"OTHER_2","","",74,[[],["u8"]]],[11,"OTHER_3","","",74,[[],["u8"]]],[11,"OTHER_6","","",74,[[],["u8"]]],[11,"OTHER_7","","",74,[[],["u8"]]],[11,"ICW4","kfs_kernel::devices::pic","",79,[[["self"]],["bool"]]],[11,"SINGLE","","",79,[[["self"]],["bool"]]],[11,"INTERVAL4","","",79,[[["self"]],["bool"]]],[11,"LEVEL","","",79,[[["self"]],["bool"]]],[11,"INIT","","",79,[[["self"]],["bool"]]],[11,"ICW4","","",79,[[],["u8"]]],[11,"SINGLE","","",79,[[],["u8"]]],[11,"INTERVAL4","","",79,[[],["u8"]]],[11,"LEVEL","","",79,[[],["u8"]]],[11,"INIT","","",79,[[],["u8"]]],[11,"fmt","kfs_kernel::paging::error","",13,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::error","",33,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",34,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::log_impl::filter::inner","",39,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::devices::rs232","",69,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","kfs_kernel::mem","",97,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",98,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","kfs_kernel::paging::process_memory","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging::mapping","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging::error","",13,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging::arch::i386::entry","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",21,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","kfs_kernel::paging::arch::i386::table","",27,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging::bookkeeping","",28,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging::process_memory","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::event","",29,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",30,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::error","",33,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",34,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::log_impl::filter::inner","",39,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::log_impl::filter","",38,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",36,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",37,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::registers::eflags","",43,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::stack","",44,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::structures::gdt","",46,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::structures::idt","",48,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",49,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",50,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",51,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::process_switch","",52,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::gdt","",55,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",57,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",56,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","kfs_kernel::i386","",42,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",40,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::frame_allocator::physical_mem_region","",63,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",62,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","kfs_kernel::devices::rs232","",68,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",71,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",69,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::devices::pit","",74,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",77,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::devices::pic","",79,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::sync","",88,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",89,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::process","",91,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",92,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",95,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",93,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",96,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",94,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::mem","",97,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",98,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",99,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",100,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::ipc::session","",103,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",104,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",105,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",106,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",107,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",108,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",109,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::ipc::port","",110,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",111,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",112,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",113,[[["self"],["formatter"]],["result"]]],[11,"eq","kfs_kernel::paging::arch::i386::entry","",20,[[["self"],["i386entryflags"]],["bool"]]],[11,"ne","","",20,[[["self"],["i386entryflags"]],["bool"]]],[11,"eq","kfs_kernel::paging","",0,[[["self"],["mappingflags"]],["bool"]]],[11,"ne","","",0,[[["self"],["mappingflags"]],["bool"]]],[11,"eq","kfs_kernel::i386::registers::eflags","",43,[[["self"],["eflags"]],["bool"]]],[11,"ne","","",43,[[["self"],["eflags"]],["bool"]]],[11,"eq","kfs_kernel::i386::structures::idt","",51,[[["self"],["pagefaulterrorcode"]],["bool"]]],[11,"ne","","",51,[[["self"],["pagefaulterrorcode"]],["bool"]]],[11,"eq","kfs_kernel::i386","",42,[[["self"],["privilegelevel"]],["bool"]]],[11,"eq","kfs_kernel::devices::pit","",74,[[["self"],["port61flags"]],["bool"]]],[11,"ne","","",74,[[["self"],["port61flags"]],["bool"]]],[11,"eq","kfs_kernel::devices::pic","",79,[[["self"],["icw1"]],["bool"]]],[11,"ne","","",79,[[["self"],["icw1"]],["bool"]]],[11,"eq","kfs_kernel::process","",96,[[["self"],["threadstate"]],["bool"]]],[11,"eq","kfs_kernel::mem","",97,[[["self"],["physicaladdress"]],["bool"]]],[11,"ne","","",97,[[["self"],["physicaladdress"]],["bool"]]],[11,"eq","","",98,[[["self"],["virtualaddress"]],["bool"]]],[11,"ne","","",98,[[["self"],["virtualaddress"]],["bool"]]],[11,"assert_receiver_is_total_eq","kfs_kernel::paging::arch::i386::entry","",20,N],[11,"assert_receiver_is_total_eq","kfs_kernel::paging","",0,N],[11,"assert_receiver_is_total_eq","kfs_kernel::i386::registers::eflags","",43,N],[11,"assert_receiver_is_total_eq","kfs_kernel::i386::structures::idt","",51,N],[11,"assert_receiver_is_total_eq","kfs_kernel::i386","",42,N],[11,"assert_receiver_is_total_eq","kfs_kernel::devices::pit","",74,N],[11,"assert_receiver_is_total_eq","kfs_kernel::devices::pic","",79,N],[11,"assert_receiver_is_total_eq","kfs_kernel::process","",96,N],[11,"assert_receiver_is_total_eq","kfs_kernel::mem","",97,N],[11,"assert_receiver_is_total_eq","","",98,N],[11,"cmp","kfs_kernel::paging::arch::i386::entry","",20,[[["self"],["i386entryflags"]],["ordering"]]],[11,"cmp","kfs_kernel::paging","",0,[[["self"],["mappingflags"]],["ordering"]]],[11,"cmp","kfs_kernel::i386::registers::eflags","",43,[[["self"],["eflags"]],["ordering"]]],[11,"cmp","kfs_kernel::i386::structures::idt","",51,[[["self"],["pagefaulterrorcode"]],["ordering"]]],[11,"cmp","kfs_kernel::devices::pit","",74,[[["self"],["port61flags"]],["ordering"]]],[11,"cmp","kfs_kernel::devices::pic","",79,[[["self"],["icw1"]],["ordering"]]],[11,"cmp","kfs_kernel::mem","",97,[[["self"],["physicaladdress"]],["ordering"]]],[11,"cmp","","",98,[[["self"],["virtualaddress"]],["ordering"]]],[11,"partial_cmp","kfs_kernel::paging::arch::i386::entry","",20,[[["self"],["i386entryflags"]],["option",["ordering"]]]],[11,"lt","","",20,[[["self"],["i386entryflags"]],["bool"]]],[11,"le","","",20,[[["self"],["i386entryflags"]],["bool"]]],[11,"gt","","",20,[[["self"],["i386entryflags"]],["bool"]]],[11,"ge","","",20,[[["self"],["i386entryflags"]],["bool"]]],[11,"partial_cmp","kfs_kernel::paging","",0,[[["self"],["mappingflags"]],["option",["ordering"]]]],[11,"lt","","",0,[[["self"],["mappingflags"]],["bool"]]],[11,"le","","",0,[[["self"],["mappingflags"]],["bool"]]],[11,"gt","","",0,[[["self"],["mappingflags"]],["bool"]]],[11,"ge","","",0,[[["self"],["mappingflags"]],["bool"]]],[11,"partial_cmp","kfs_kernel::i386::registers::eflags","",43,[[["self"],["eflags"]],["option",["ordering"]]]],[11,"lt","","",43,[[["self"],["eflags"]],["bool"]]],[11,"le","","",43,[[["self"],["eflags"]],["bool"]]],[11,"gt","","",43,[[["self"],["eflags"]],["bool"]]],[11,"ge","","",43,[[["self"],["eflags"]],["bool"]]],[11,"partial_cmp","kfs_kernel::i386::structures::idt","",51,[[["self"],["pagefaulterrorcode"]],["option",["ordering"]]]],[11,"lt","","",51,[[["self"],["pagefaulterrorcode"]],["bool"]]],[11,"le","","",51,[[["self"],["pagefaulterrorcode"]],["bool"]]],[11,"gt","","",51,[[["self"],["pagefaulterrorcode"]],["bool"]]],[11,"ge","","",51,[[["self"],["pagefaulterrorcode"]],["bool"]]],[11,"partial_cmp","kfs_kernel::devices::pit","",74,[[["self"],["port61flags"]],["option",["ordering"]]]],[11,"lt","","",74,[[["self"],["port61flags"]],["bool"]]],[11,"le","","",74,[[["self"],["port61flags"]],["bool"]]],[11,"gt","","",74,[[["self"],["port61flags"]],["bool"]]],[11,"ge","","",74,[[["self"],["port61flags"]],["bool"]]],[11,"partial_cmp","kfs_kernel::devices::pic","",79,[[["self"],["icw1"]],["option",["ordering"]]]],[11,"lt","","",79,[[["self"],["icw1"]],["bool"]]],[11,"le","","",79,[[["self"],["icw1"]],["bool"]]],[11,"gt","","",79,[[["self"],["icw1"]],["bool"]]],[11,"ge","","",79,[[["self"],["icw1"]],["bool"]]],[11,"partial_cmp","kfs_kernel::mem","",97,[[["self"],["physicaladdress"]],["option",["ordering"]]]],[11,"lt","","",97,[[["self"],["physicaladdress"]],["bool"]]],[11,"le","","",97,[[["self"],["physicaladdress"]],["bool"]]],[11,"gt","","",97,[[["self"],["physicaladdress"]],["bool"]]],[11,"ge","","",97,[[["self"],["physicaladdress"]],["bool"]]],[11,"partial_cmp","","",98,[[["self"],["virtualaddress"]],["option",["ordering"]]]],[11,"lt","","",98,[[["self"],["virtualaddress"]],["bool"]]],[11,"le","","",98,[[["self"],["virtualaddress"]],["bool"]]],[11,"gt","","",98,[[["self"],["virtualaddress"]],["bool"]]],[11,"ge","","",98,[[["self"],["virtualaddress"]],["bool"]]],[11,"hash","kfs_kernel::paging::arch::i386::entry","",20,N],[11,"hash","kfs_kernel::paging","",0,N],[11,"hash","kfs_kernel::i386::registers::eflags","",43,N],[11,"hash","kfs_kernel::i386::structures::idt","",51,N],[11,"hash","kfs_kernel::devices::pit","",74,N],[11,"hash","kfs_kernel::devices::pic","",79,N],[11,"hash","kfs_kernel::mem","",97,N],[11,"hash","","",98,N],[11,"add","","Adding a length to an address gives another address",98,[[["self"],["usize"]],["virtualaddress"]]],[11,"add","","Adding a length to an address gives another address",97,[[["self"],["usize"]],["physicaladdress"]]],[11,"sub","kfs_kernel::paging::arch::i386::entry","Returns the set difference of the two sets of flags.",20,[[["self"],["i386entryflags"]],["i386entryflags"]]],[11,"sub","kfs_kernel::paging","Returns the set difference of the two sets of flags.",0,[[["self"],["mappingflags"]],["mappingflags"]]],[11,"sub","kfs_kernel::i386::registers::eflags","Returns the set difference of the two sets of flags.",43,[[["self"],["eflags"]],["eflags"]]],[11,"sub","kfs_kernel::i386::structures::idt","Returns the set difference of the two sets of flags.",51,[[["self"],["pagefaulterrorcode"]],["pagefaulterrorcode"]]],[11,"sub","kfs_kernel::devices::pit","Returns the set difference of the two sets of flags.",74,[[["self"],["port61flags"]],["port61flags"]]],[11,"sub","kfs_kernel::devices::pic","Returns the set difference of the two sets of flags.",79,[[["self"],["icw1"]],["icw1"]]],[11,"sub","kfs_kernel::mem","Subtracting a length from an address gives another address",98,[[["self"],["usize"]],["virtualaddress"]]],[11,"sub","","Subtracting a length from an address gives another address",97,[[["self"],["usize"]],["physicaladdress"]]],[11,"sub","","Subtracting two address gives their distance",98,[[["self"],["virtualaddress"]],["usize"]]],[11,"sub","","Subtracting two address gives their distance",97,[[["self"],["physicaladdress"]],["usize"]]],[11,"add_assign","","Adding a length to an address gives another address",98,[[["self"],["usize"]]]],[11,"add_assign","","Adding a length to an address gives another address",97,[[["self"],["usize"]]]],[11,"sub_assign","kfs_kernel::paging::arch::i386::entry","Disables all flags enabled in the set.",20,[[["self"],["i386entryflags"]]]],[11,"sub_assign","kfs_kernel::paging","Disables all flags enabled in the set.",0,[[["self"],["mappingflags"]]]],[11,"sub_assign","kfs_kernel::i386::registers::eflags","Disables all flags enabled in the set.",43,[[["self"],["eflags"]]]],[11,"sub_assign","kfs_kernel::i386::structures::idt","Disables all flags enabled in the set.",51,[[["self"],["pagefaulterrorcode"]]]],[11,"sub_assign","kfs_kernel::devices::pit","Disables all flags enabled in the set.",74,[[["self"],["port61flags"]]]],[11,"sub_assign","kfs_kernel::devices::pic","Disables all flags enabled in the set.",79,[[["self"],["icw1"]]]],[11,"sub_assign","kfs_kernel::mem","Subtracting a length from an address gives another address",98,[[["self"],["usize"]]]],[11,"sub_assign","","Subtracting a length from an address gives another address",97,[[["self"],["usize"]]]],[11,"not","kfs_kernel::paging::arch::i386::entry","Returns the complement of this set of flags.",20,[[["self"]],["i386entryflags"]]],[11,"not","kfs_kernel::paging","Returns the complement of this set of flags.",0,[[["self"]],["mappingflags"]]],[11,"not","kfs_kernel::i386::registers::eflags","Returns the complement of this set of flags.",43,[[["self"]],["eflags"]]],[11,"not","kfs_kernel::i386::structures::idt","Returns the complement of this set of flags.",51,[[["self"]],["pagefaulterrorcode"]]],[11,"not","kfs_kernel::devices::pit","Returns the complement of this set of flags.",74,[[["self"]],["port61flags"]]],[11,"not","kfs_kernel::devices::pic","Returns the complement of this set of flags.",79,[[["self"]],["icw1"]]],[11,"bitand","kfs_kernel::paging::arch::i386::entry","Returns the intersection between the two sets of flags.",20,[[["self"],["i386entryflags"]],["i386entryflags"]]],[11,"bitand","kfs_kernel::paging","Returns the intersection between the two sets of flags.",0,[[["self"],["mappingflags"]],["mappingflags"]]],[11,"bitand","kfs_kernel::i386::registers::eflags","Returns the intersection between the two sets of flags.",43,[[["self"],["eflags"]],["eflags"]]],[11,"bitand","kfs_kernel::i386::structures::idt","Returns the intersection between the two sets of flags.",51,[[["self"],["pagefaulterrorcode"]],["pagefaulterrorcode"]]],[11,"bitand","kfs_kernel::devices::pit","Returns the intersection between the two sets of flags.",74,[[["self"],["port61flags"]],["port61flags"]]],[11,"bitand","kfs_kernel::devices::pic","Returns the intersection between the two sets of flags.",79,[[["self"],["icw1"]],["icw1"]]],[11,"bitor","kfs_kernel::paging::arch::i386::entry","Returns the union of the two sets of flags.",20,[[["self"],["i386entryflags"]],["i386entryflags"]]],[11,"bitor","kfs_kernel::paging","Returns the union of the two sets of flags.",0,[[["self"],["mappingflags"]],["mappingflags"]]],[11,"bitor","kfs_kernel::i386::registers::eflags","Returns the union of the two sets of flags.",43,[[["self"],["eflags"]],["eflags"]]],[11,"bitor","kfs_kernel::i386::structures::idt","Returns the union of the two sets of flags.",51,[[["self"],["pagefaulterrorcode"]],["pagefaulterrorcode"]]],[11,"bitor","kfs_kernel::devices::pit","Returns the union of the two sets of flags.",74,[[["self"],["port61flags"]],["port61flags"]]],[11,"bitor","kfs_kernel::devices::pic","Returns the union of the two sets of flags.",79,[[["self"],["icw1"]],["icw1"]]],[11,"bitxor","kfs_kernel::paging::arch::i386::entry","Returns the left flags, but with all the right flags…",20,[[["self"],["i386entryflags"]],["i386entryflags"]]],[11,"bitxor","kfs_kernel::paging","Returns the left flags, but with all the right flags…",0,[[["self"],["mappingflags"]],["mappingflags"]]],[11,"bitxor","kfs_kernel::i386::registers::eflags","Returns the left flags, but with all the right flags…",43,[[["self"],["eflags"]],["eflags"]]],[11,"bitxor","kfs_kernel::i386::structures::idt","Returns the left flags, but with all the right flags…",51,[[["self"],["pagefaulterrorcode"]],["pagefaulterrorcode"]]],[11,"bitxor","kfs_kernel::devices::pit","Returns the left flags, but with all the right flags…",74,[[["self"],["port61flags"]],["port61flags"]]],[11,"bitxor","kfs_kernel::devices::pic","Returns the left flags, but with all the right flags…",79,[[["self"],["icw1"]],["icw1"]]],[11,"bitand_assign","kfs_kernel::paging::arch::i386::entry","Disables all flags disabled in the set.",20,[[["self"],["i386entryflags"]]]],[11,"bitand_assign","kfs_kernel::paging","Disables all flags disabled in the set.",0,[[["self"],["mappingflags"]]]],[11,"bitand_assign","kfs_kernel::i386::registers::eflags","Disables all flags disabled in the set.",43,[[["self"],["eflags"]]]],[11,"bitand_assign","kfs_kernel::i386::structures::idt","Disables all flags disabled in the set.",51,[[["self"],["pagefaulterrorcode"]]]],[11,"bitand_assign","kfs_kernel::devices::pit","Disables all flags disabled in the set.",74,[[["self"],["port61flags"]]]],[11,"bitand_assign","kfs_kernel::devices::pic","Disables all flags disabled in the set.",79,[[["self"],["icw1"]]]],[11,"bitor_assign","kfs_kernel::paging::arch::i386::entry","Adds the set of flags.",20,[[["self"],["i386entryflags"]]]],[11,"bitor_assign","kfs_kernel::paging","Adds the set of flags.",0,[[["self"],["mappingflags"]]]],[11,"bitor_assign","kfs_kernel::i386::registers::eflags","Adds the set of flags.",43,[[["self"],["eflags"]]]],[11,"bitor_assign","kfs_kernel::i386::structures::idt","Adds the set of flags.",51,[[["self"],["pagefaulterrorcode"]]]],[11,"bitor_assign","kfs_kernel::devices::pit","Adds the set of flags.",74,[[["self"],["port61flags"]]]],[11,"bitor_assign","kfs_kernel::devices::pic","Adds the set of flags.",79,[[["self"],["icw1"]]]],[11,"bitxor_assign","kfs_kernel::paging::arch::i386::entry","Toggles the set of flags.",20,[[["self"],["i386entryflags"]]]],[11,"bitxor_assign","kfs_kernel::paging","Toggles the set of flags.",0,[[["self"],["mappingflags"]]]],[11,"bitxor_assign","kfs_kernel::i386::registers::eflags","Toggles the set of flags.",43,[[["self"],["eflags"]]]],[11,"bitxor_assign","kfs_kernel::i386::structures::idt","Toggles the set of flags.",51,[[["self"],["pagefaulterrorcode"]]]],[11,"bitxor_assign","kfs_kernel::devices::pit","Toggles the set of flags.",74,[[["self"],["port61flags"]]]],[11,"bitxor_assign","kfs_kernel::devices::pic","Toggles the set of flags.",79,[[["self"],["icw1"]]]],[11,"deref","kfs_kernel::paging::hierarchical_table","",14,[[["self"]],["t"]]],[11,"deref","kfs_kernel::i386::gdt","",53,[[["self"]],["descriptortable"]]],[11,"deref","","",54,[[["self"]],["virtualaddress"]]],[11,"deref","kfs_kernel::i386","",41,[[["self"]],["tssstruct"]]],[11,"deref","kfs_kernel::interrupts","",60,[[["self"]],["spinlock"]]],[11,"deref","kfs_kernel::heap_allocator","",67,[[["self"]],["spinlock"]]],[11,"deref","kfs_kernel::devices::pit","",73,[[["self"]],["spinlock"]]],[11,"deref","kfs_kernel::sync","",89,[[["self"]],["t"]]],[11,"deref","kfs_kernel::mem","",99,[[["self"]],["t"]]],[11,"deref","","",100,[[["self"]],["t"]]],[11,"deref","kfs_kernel::ipc","",102,[[["self"]],["rwlock"]]],[11,"deref_mut","kfs_kernel::paging::hierarchical_table","",14,[[["self"]],["t"]]],[11,"deref_mut","kfs_kernel::i386::gdt","",53,[[["self"]],["descriptortable"]]],[11,"deref_mut","kfs_kernel::i386","",41,[[["self"]],["tssstruct"]]],[11,"deref_mut","kfs_kernel::sync","",89,[[["self"]],["t"]]],[11,"deref_mut","kfs_kernel::mem","",100,[[["self"]],["t"]]],[11,"drop","kfs_kernel::paging::cross_process","Unmaps itself from KernelLand when dropped.",12,[[["self"]]]],[11,"drop","kfs_kernel::paging::hierarchical_table","",14,[[["self"]]]],[11,"drop","kfs_kernel::paging::arch::i386::table","",26,[[["self"]]]],[11,"drop","","",25,[[["self"]]]],[11,"drop","kfs_kernel::i386::stack","We deallocate the stack when it is dropped",44,[[["self"]]]],[11,"drop","kfs_kernel::frame_allocator::physical_mem_region","Dropping a `PhysicalMemRegion` may free its frames.",62,[[["self"]]]],[11,"drop","kfs_kernel::sync","",89,[[["self"]]]],[11,"drop","kfs_kernel::process","",91,[[["self"]]]],[11,"drop","","",92,[[["self"]]]],[11,"drop","kfs_kernel::ipc::session","",106,[[["self"]]]],[11,"drop","kfs_kernel::ipc::port","",112,[[["self"]]]],[11,"drop","kfs_kernel::elf_loader","Unmap the module, but do not deallocate physical memory",114,[[["self"]]]],[11,"index","kfs_kernel::i386::structures::idt","",47,N],[11,"index_mut","","",47,N],[11,"next","kfs_kernel::frame_allocator::physical_mem_region","",63,[[["self"]],["option",["physicaladdress"]]]],[11,"steps_between","kfs_kernel::mem","",97,[[["self"],["self"]],["option",["usize"]]]],[11,"replace_one","","",97,[[["self"]],["self"]]],[11,"replace_zero","","",97,[[["self"]],["self"]]],[11,"add_one","","",97,[[["self"]],["self"]]],[11,"sub_one","","",97,[[["self"]],["self"]]],[11,"add_usize","","",97,[[["self"],["usize"]],["option"]]],[11,"steps_between","","",98,[[["self"],["self"]],["option",["usize"]]]],[11,"replace_one","","",98,[[["self"]],["self"]]],[11,"replace_zero","","",98,[[["self"]],["self"]]],[11,"add_one","","",98,[[["self"]],["self"]]],[11,"sub_one","","",98,[[["self"]],["self"]]],[11,"add_usize","","",98,[[["self"],["usize"]],["option"]]],[11,"extend","kfs_kernel::paging::arch::i386::entry","",20,[[["self"],["t"]]]],[11,"extend","kfs_kernel::paging","",0,[[["self"],["t"]]]],[11,"extend","kfs_kernel::i386::registers::eflags","",43,[[["self"],["t"]]]],[11,"extend","kfs_kernel::i386::structures::idt","",51,[[["self"],["t"]]]],[11,"extend","kfs_kernel::devices::pit","",74,[[["self"],["t"]]]],[11,"extend","kfs_kernel::devices::pic","",79,[[["self"],["t"]]]],[11,"from_iter","kfs_kernel::paging::arch::i386::entry","",20,[[["t"]],["i386entryflags"]]],[11,"from_iter","kfs_kernel::paging","",0,[[["t"]],["mappingflags"]]],[11,"from_iter","kfs_kernel::i386::registers::eflags","",43,[[["t"]],["eflags"]]],[11,"from_iter","kfs_kernel::i386::structures::idt","",51,[[["t"]],["pagefaulterrorcode"]]],[11,"from_iter","kfs_kernel::devices::pit","",74,[[["t"]],["port61flags"]]],[11,"from_iter","kfs_kernel::devices::pic","",79,[[["t"]],["icw1"]]],[11,"from","kfs_kernel::error","",32,[[["mmerror"]],["self"]]],[11,"from","kfs_kernel::paging::arch::i386::entry","",20,[[["mappingflags"]],["i386entryflags"]]],[11,"from","kfs_kernel::paging","",0,[[["memorypermissions"]],["self"]]],[11,"from","kfs_kernel::error","",32,[[["kernelerror"]],["userspaceerror"]]],[11,"write_str","kfs_kernel::devices::rs232","Writes a string to COM1.",72,[[["self"],["str"]],["result",["error"]]]],[11,"fmt","kfs_kernel::paging::arch::i386::entry","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::registers::eflags","",43,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::structures::idt","",51,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::devices::pit","",74,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::devices::pic","",79,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging::arch::i386::entry","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::registers::eflags","",43,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::structures::idt","",51,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::devices::pit","",74,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::devices::pic","",79,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging::arch::i386::entry","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::registers::eflags","",43,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::structures::idt","",51,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::devices::pit","",74,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::devices::pic","",79,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::mem","",97,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",98,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","kfs_kernel::paging::arch::i386::entry","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::registers::eflags","",43,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::structures::idt","",51,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::devices::pit","",74,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::devices::pic","",79,[[["self"],["formatter"]],["result"]]],[11,"clone","kfs_kernel::paging::arch::i386::entry","",20,[[["self"]],["i386entryflags"]]],[11,"clone","","",21,[[["self"]],["i386entry"]]],[11,"clone","kfs_kernel::paging","",0,[[["self"]],["mappingflags"]]],[11,"clone","kfs_kernel::error","",33,[[["self"]],["arithmeticoperation"]]],[11,"clone","kfs_kernel::i386::registers::eflags","",43,[[["self"]],["eflags"]]],[11,"clone","kfs_kernel::i386::structures::idt","",48,[[["self"]],["idtentry"]]],[11,"clone","","",49,[[["self"]],["entryoptions"]]],[11,"clone","","",51,[[["self"]],["pagefaulterrorcode"]]],[11,"clone","kfs_kernel::i386::gdt","",55,[[["self"]],["descriptortable"]]],[11,"clone","","",57,[[["self"]],["systemdescriptortypes"]]],[11,"clone","","",56,[[["self"]],["descriptortableentry"]]],[11,"clone","kfs_kernel::i386","",42,[[["self"]],["privilegelevel"]]],[11,"clone","","",40,[[["self"]],["tssstruct"]]],[11,"clone","kfs_kernel::frame_allocator::physical_mem_region","",63,[[["self"]],["physicalmemregioniter"]]],[11,"clone","kfs_kernel::devices::rs232","",68,[[["self"]],["comport"]]],[11,"clone","","",71,[[["self"]],["serialcolor"]]],[11,"clone","","",69,[[["self"]],["serialattributes"]]],[11,"clone","kfs_kernel::devices::pit","",74,[[["self"]],["port61flags"]]],[11,"clone","kfs_kernel::devices::pic","",79,[[["self"]],["icw1"]]],[11,"clone","kfs_kernel::process","",96,[[["self"]],["threadstate"]]],[11,"clone","kfs_kernel::mem","",97,[[["self"]],["physicaladdress"]]],[11,"clone","","",98,[[["self"]],["virtualaddress"]]],[11,"clone","","",99,[[["self"]],["userspaceptr"]]],[11,"clone","","",100,[[["self"]],["userspaceptrmut"]]],[11,"clone","kfs_kernel::ipc::session","",105,[[["self"]],["clientsession"]]],[11,"clone","","",106,[[["self"]],["self"]]],[11,"clone","kfs_kernel::ipc::port","",111,[[["self"]],["clientport"]]],[11,"clone","","",112,[[["self"]],["self"]]],[11,"into","kfs_kernel::mem","",100,[[["self"]],["userspaceptr"]]],[11,"default","kfs_kernel::log_impl::filter","",37,[[],["self"]]],[11,"default","kfs_kernel::i386","",40,[[],["tssstruct"]]],[11,"alloc","kfs_kernel::heap_allocator","",67,N],[11,"dealloc","","",67,N],[11,"initialize","kfs_kernel::i386::gdt","",54,[[["self"]]]],[11,"initialize","kfs_kernel::interrupts","",60,[[["self"]]]],[11,"initialize","kfs_kernel::devices::pit","",73,[[["self"]]]],[11,"initialize","kfs_kernel::ipc","",102,[[["self"]]]],[11,"enabled","kfs_kernel::log_impl","",35,[[["self"],["metadata"]],["bool"]]],[11,"log","","",35,[[["self"],["record"]]]],[11,"flush","","",35,[[["self"]]]],[11,"name","kfs_kernel::paging::error","",13,[[["self"]],["option",["str"]]]],[11,"cause","","",13,[[["self"]],["option",["fail"]]]],[11,"backtrace","","",13,[[["self"]],["option",["backtrace"]]]],[11,"name","kfs_kernel::error","",34,[[["self"]],["option",["str"]]]],[11,"cause","","",34,[[["self"]],["option",["fail"]]]],[11,"backtrace","","",34,[[["self"]],["option",["backtrace"]]]],[11,"bit_range","kfs_kernel::ipc::session","",107,[[["self"],["usize"],["usize"]],["t"]]],[11,"set_bit_range","","",107,[[["self"],["usize"],["usize"],["t"]]]],[11,"bit_range","","",108,[[["self"],["usize"],["usize"]],["t"]]],[11,"set_bit_range","","",108,[[["self"],["usize"],["usize"],["t"]]]],[11,"make_ret","kfs_kernel::error","Transforms a KernelError into the encoding acceptable for…",32,[[["self"]],["usize"]]],[11,"from_syscall_ret","","Turns a syscall return value into a Kernel Error.",32,[[["u32"]],["kernelerror"]]],[11,"from_description","","Turns a kernel error description into a KernelError.",32,[[["u32"]],["kernelerror"]]],[11,"description","","Gets the underlying KernelError description.",32,[[["self"]],["u32"]]],[18,"InvalidKernelCaps","","Kernel capabilities are invalid.",32,N],[18,"NotImplemented","","This function is not implemented.",32,N],[18,"InvalidSize","","The size argument is invalid.",32,N],[18,"InvalidAddress","","The passed address is invalid.",32,N],[18,"MemoryFull","","The virtual address space was exhausted.",32,N],[18,"HandleTableFull","","The process' handle table is full.",32,N],[18,"InvalidMemPerms","","The memory permissions passed are wrong.",32,N],[18,"InvalidHandle","","Passed handle is invalid.",32,N],[18,"CopyFromUserFailed","","Attempt to copy the userspace address failed.",32,N],[18,"InvalidCombination","","The combination of argument is invalid.",32,N],[18,"Timeout","","A timeout was reached.",32,N],[18,"Canceled","","The syscall was cancelled through cancel_synchronization.",32,N],[18,"ExceedingMaximum","","A size was given exceeding the maximum allowed value.",32,N],[18,"NoSuchEntry","","The given entry does not exist.",32,N],[18,"PortRemoteDead","","The remote part of the session was closed.",32,N],[18,"ProcessAlreadyStarted","","Attempted to start a process that was already started.",32,N],[11,"new","kfs_kernel::utils::io","Create a PIO from a given port",58,[[["u16"]],["pio"]]],[18,"INIT","kfs_kernel::sync","Initialization constant of `Once`.",82,N],[11,"new","","Creates a new `Once` value.",82,[[],["once"]]],[11,"call_once","","Performs an initialization routine once and only once. The…",82,[[["self"],["f"]],["t"]]],[11,"try","","Returns a pointer iff the `Once` was previously initialized",82,[[["self"]],["option"]]],[11,"wait","","Like try, but will spin if the `Once` is in the process of…",82,[[["self"]],["option"]]],[11,"new","","Creates a new spinlock wrapping the supplied data.",83,[[["t"]],["rwlock"]]],[11,"into_inner","","Consumes this `RwLock`, returning the underlying data.",83,[[["self"]],["t"]]],[11,"read","","Locks this rwlock with shared read access, blocking the…",83,[[["self"]],["rwlockreadguard"]]],[11,"try_read","","Attempt to acquire this lock with shared read access.",83,[[["self"]],["option",["rwlockreadguard"]]]],[11,"force_read_decrement","","Force decrement the reader count.",83,N],[11,"force_write_unlock","","Force unlock exclusive write access.",83,N],[11,"write","","Lock this rwlock with exclusive write access, blocking the…",83,[[["self"]],["rwlockwriteguard"]]],[11,"try_write","","Attempt to lock this rwlock with exclusive write access.",83,[[["self"]],["option",["rwlockwriteguard"]]]],[11,"new","","Creates a new spinlock wrapping the supplied data.",86,[[["t"]],["mutex"]]],[11,"into_inner","","Consumes this mutex, returning the underlying data.",86,[[["self"]],["t"]]],[11,"lock","","Locks the spinlock and returns a guard.",86,[[["self"]],["mutexguard"]]],[11,"force_unlock","","Force unlock the spinlock.",86,N],[11,"try_lock","","Tries to lock the mutex. If it is already locked, it will…",86,[[["self"]],["option",["mutexguard"]]]],[11,"new","kfs_kernel::utils::io","Create a read-only wrapper around the IO device address.",116,[[["i"]],["readonly"]]],[11,"read","","Reads from this Io.",116,N],[11,"readf","","Read from this Io, and mask the value with `flags`.",116,N],[11,"new","","Creates a WriteOnly Io.",117,[[["i"]],["writeonly"]]],[11,"write","","Writes `value` to this Io.",117,N],[11,"new","kfs_kernel::utils","Creates a new cursor wrapping the provided underlying…",119,N],[11,"pos","","Returns the current position of this cursor.",119,[[["self"]],["usize"]]],[11,"skip_write","","Skip the given amount of bytes, returning a mutable slice…",119,N],[11,"write_u8","","Writes an u8 in the given byte ordering.",119,N],[11,"write_u16","","Writes a u16 in the given byte ordering.",119,N],[11,"write_u32","","Writes a u32 in the given byte ordering.",119,N],[11,"write_u64","","Writes a u64 in the given byte ordering.",119,N],[11,"write","","Writes the given byte slice entirely.",119,N],[11,"write_raw","","Writes the given structure.",119,N],[11,"new","","Creates a new cursor wrapping the provided underlying…",120,N],[11,"pos","","Returns the current position of this cursor.",120,[[["self"]],["usize"]]],[11,"read_u8","","Reads an u8 in the given byteorder.",120,[[["self"]],["u8"]]],[11,"read_u16","","Reads an u16 in the given byteorder.",120,[[["self"]],["u16"]]],[11,"read_u32","","Reads an u32 in the given byteorder.",120,[[["self"]],["u32"]]],[11,"read_u64","","Reads an u64 in the given byteorder.",120,[[["self"]],["u64"]]],[11,"assert","","Reads `v.len()` bytes from the stream, and asserts that it…",120,N],[11,"skip_read","","Skips `bytelen` bytes, returning a slice to them for…",120,N],[11,"read_raw","","Reads the given structure from the bytestream.",120,[[["self"]],["t"]]]],"paths":[[3,"MappingFlags"],[4,"PageState"],[3,"ProcessMemory"],[4,"QueryMemory"],[4,"DynamicHierarchy"],[3,"KernelMemory"],[8,"VirtualSpaceLand"],[3,"UserLand"],[3,"KernelLand"],[3,"RecursiveTablesLand"],[3,"Mapping"],[4,"MappingType"],[3,"CrossProcessMapping"],[4,"MmError"],[3,"SmartHierarchicalTable"],[8,"HierarchicalEntry"],[8,"HierarchicalTable"],[8,"PagingCacheFlusher"],[8,"TableHierarchy"],[8,"InactiveHierarchyTrait"],[3,"I386EntryFlags"],[3,"I386Entry"],[3,"Table"],[3,"ActivePageTable"],[3,"ActivePageDirectory"],[3,"InactivePageTable"],[3,"InactivePageDirectory"],[3,"InactiveHierarchy"],[3,"UserspaceBookkeeping"],[3,"IRQEvent"],[3,"IRQState"],[8,"Waitable"],[3,"UserspaceError"],[4,"ArithmeticOperation"],[4,"KernelError"],[3,"Logger"],[3,"Filter"],[3,"Builder"],[3,"Directive"],[3,"Filter"],[3,"TssStruct"],[3,"AlignedTssStruct"],[4,"PrivilegeLevel"],[3,"EFlags"],[3,"KernelStack"],[3,"StackDumpSource"],[3,"SegmentSelector"],[3,"Idt"],[3,"IdtEntry"],[3,"EntryOptions"],[3,"ExceptionStackFrame"],[3,"PageFaultErrorCode"],[3,"ThreadHardwareContext"],[3,"GdtManager"],[3,"MAIN_TASK"],[3,"DescriptorTable"],[3,"DescriptorTableEntry"],[4,"SystemDescriptorTypes"],[3,"Pio"],[3,"DescriptorTablePointer"],[3,"IDT"],[3,"Registers"],[3,"PhysicalMemRegion"],[3,"PhysicalMemRegionIter"],[3,"FrameAllocatori386"],[8,"FrameAllocatorTraitPrivate"],[8,"FrameAllocatorTrait"],[3,"Allocator"],[3,"ComPort"],[3,"SerialAttributes"],[3,"SerialInternal"],[4,"SerialColor"],[3,"SerialLogger"],[3,"PIT_PORTS"],[3,"Port61Flags"],[3,"PITPorts"],[3,"PITChannel2"],[3,"WaitFor"],[4,"ChannelSelector"],[3,"ICW1"],[3,"InternalPic"],[3,"Pic"],[3,"Once"],[3,"RwLock"],[3,"RwLockReadGuard"],[3,"RwLockWriteGuard"],[3,"SpinLock"],[3,"SpinLockGuard"],[3,"SpinLockIRQ"],[3,"SpinLockIRQGuard"],[8,"Lock"],[3,"ProcessStruct"],[3,"ThreadStruct"],[3,"HandleTable"],[3,"ThreadStateAtomic"],[4,"Handle"],[4,"ThreadState"],[3,"PhysicalAddress"],[3,"VirtualAddress"],[3,"UserSpacePtr"],[3,"UserSpacePtrMut"],[3,"FatPtr"],[3,"NAMED_PORTS"],[3,"InternalSession"],[3,"Session"],[3,"ClientSession"],[3,"ServerSession"],[3,"MsgPackedHdr"],[3,"HandleDescriptorHeader"],[3,"Request"],[3,"Port"],[3,"ClientPort"],[3,"ServerPort"],[3,"IncomingConnection"],[3,"MappedGrubModule"],[8,"Io"],[3,"ReadOnly"],[3,"WriteOnly"],[8,"BitArrayExt"],[3,"CursorWrite"],[3,"CursorRead"],[8,"Splittable"],[3,"NoFlush"],[3,"ActiveHierarchy"],[3,"TlbFlush"],[3,"FrameAllocator"]]};
searchIndex["kfs_libkern"]={"doc":"Types shared by user and kernel","items":[[3,"MemoryType","kfs_libkern","The type of this memory area.",N,N],[12,"0","","",0,N],[3,"MemoryAttributes","","Low-level attributes of a memory mapping.",N,N],[12,"bits","","",1,N],[3,"MemoryPermissions","","Memory permissions of a memory area.",N,N],[12,"bits","","",2,N],[3,"MemoryInfo","","The structure returned by the `query_memory` syscall.",N,N],[12,"baseaddr","","The base address of this memory region.",3,N],[12,"size","","The size of this memory region, from the base address.",3,N],[12,"memtype","","The type of this mapping.",3,N],[12,"memattr","","The attributes of this mapping.",3,N],[12,"perms","","The permissions of this mapping.",3,N],[12,"ipc_ref_count","","Counts how many IPC service requests have an IPC buffer in…",3,N],[12,"device_ref_count","","Unknown.",3,N],[3,"SYSCALL_NAMES","","A table associating a syscall name string for every…",N,N],[12,"__private_field","","",4,N],[0,"error","","Kernel errors",N,N],[3,"KernelError","kfs_libkern::error","Kernel syscall error codes.",N,N],[12,"0","","",5,N],[18,"InvalidKernelCaps","","Kernel capabilities are invalid.",5,N],[18,"NotImplemented","","This function is not implemented.",5,N],[18,"InvalidSize","","The size argument is invalid.",5,N],[18,"InvalidAddress","","The passed address is invalid.",5,N],[18,"MemoryFull","","The virtual address space was exhausted.",5,N],[18,"HandleTableFull","","The process' handle table is full.",5,N],[18,"InvalidMemPerms","","The memory permissions passed are wrong.",5,N],[18,"InvalidHandle","","Passed handle is invalid.",5,N],[18,"CopyFromUserFailed","","Attempt to copy the userspace address failed.",5,N],[18,"InvalidCombination","","The combination of argument is invalid.",5,N],[18,"Timeout","","A timeout was reached.",5,N],[18,"Canceled","","The syscall was cancelled through cancel_synchronization.",5,N],[18,"ExceedingMaximum","","A size was given exceeding the maximum allowed value.",5,N],[18,"NoSuchEntry","","The given entry does not exist.",5,N],[18,"PortRemoteDead","","The remote part of the session was closed.",5,N],[18,"ProcessAlreadyStarted","","Attempted to start a process that was already started.",5,N],[11,"make_ret","","Transforms a KernelError into the encoding acceptable for…",5,[[["self"]],["usize"]]],[11,"from_syscall_ret","","Turns a syscall return value into a Kernel Error.",5,[[["u32"]],["kernelerror"]]],[11,"from_description","","Turns a kernel error description into a KernelError.",5,[[["u32"]],["kernelerror"]]],[11,"description","","Gets the underlying KernelError description.",5,[[["self"]],["u32"]]],[0,"nr","kfs_libkern","Syscall numbers",N,N],[17,"SetHeapSize","kfs_libkern::nr","",N,N],[17,"SetMemoryPermission","","",N,N],[17,"SetMemoryAttribute","","",N,N],[17,"MapMemory","","",N,N],[17,"UnmapMemory","","",N,N],[17,"QueryMemory","","",N,N],[17,"ExitProcess","","",N,N],[17,"CreateThread","","",N,N],[17,"StartThread","","",N,N],[17,"ExitThread","","",N,N],[17,"SleepThread","","",N,N],[17,"GetThreadPriority","","",N,N],[17,"SetThreadPriority","","",N,N],[17,"GetThreadCoreMask","","",N,N],[17,"SetThreadCoreMask","","",N,N],[17,"GetCurrentProcessorNumber","","",N,N],[17,"SignalEvent","","",N,N],[17,"ClearEvent","","",N,N],[17,"MapSharedMemory","","",N,N],[17,"UnmapSharedMemory","","",N,N],[17,"CreateTransferMemory","","",N,N],[17,"CloseHandle","","",N,N],[17,"ResetSignal","","",N,N],[17,"WaitSynchronization","","",N,N],[17,"CancelSynchronization","","",N,N],[17,"ArbitrateLock","","",N,N],[17,"ArbitrateUnlock","","",N,N],[17,"WaitProcessWideKeyAtomic","","",N,N],[17,"SignalProcessWideKey","","",N,N],[17,"GetSystemTick","","",N,N],[17,"ConnectToNamedPort","","",N,N],[17,"SendSyncRequestLight","","",N,N],[17,"SendSyncRequest","","",N,N],[17,"SendSyncRequestWithUserBuffer","","",N,N],[17,"SendAsyncRequestWithUserBuffer","","",N,N],[17,"GetProcessId","","",N,N],[17,"GetThreadId","","",N,N],[17,"Break","","",N,N],[17,"OutputDebugString","","",N,N],[17,"ReturnFromException","","",N,N],[17,"GetInfo","","",N,N],[17,"FlushEntireDataCache","","",N,N],[17,"FlushDataCache","","",N,N],[17,"MapPhysicalMemory","","",N,N],[17,"UnmapPhysicalMemory","","",N,N],[17,"GetFutureThreadInfo","","",N,N],[17,"GetLastThreadInfo","","",N,N],[17,"GetResourceLimitLimitValue","","",N,N],[17,"GetResourceLimitCurrentValue","","",N,N],[17,"SetThreadActivity","","",N,N],[17,"GetThreadContext3","","",N,N],[17,"WaitForAddress","","",N,N],[17,"SignalToAddress","","",N,N],[17,"DumpInfo","","",N,N],[17,"DumpInfoNew","","",N,N],[17,"CreateSession","","",N,N],[17,"AcceptSession","","",N,N],[17,"ReplyAndReceiveLight","","",N,N],[17,"ReplyAndReceive","","",N,N],[17,"ReplyAndReceiveWithUserBuffer","","",N,N],[17,"CreateEvent","","",N,N],[17,"MapPhysicalMemoryUnsafe","","",N,N],[17,"UnmapPhysicalMemoryUnsafe","","",N,N],[17,"SetUnsafeLimit","","",N,N],[17,"CreateCodeMemory","","",N,N],[17,"ControlCodeMemory","","",N,N],[17,"SleepSystem","","",N,N],[17,"ReadWriteRegister","","",N,N],[17,"SetProcessActivity","","",N,N],[17,"CreateSharedMemory","","",N,N],[17,"MapTransferMemory","","",N,N],[17,"UnmapTransferMemory","","",N,N],[17,"CreateInterruptEvent","","",N,N],[17,"QueryPhysicalAddress","","",N,N],[17,"QueryIoMapping","","",N,N],[17,"CreateDeviceAddressSpace","","",N,N],[17,"AttachDeviceAddressSpace","","",N,N],[17,"DetachDeviceAddressSpace","","",N,N],[17,"MapDeviceAddressSpaceByForce","","",N,N],[17,"MapDeviceAddressSpaceAligned","","",N,N],[17,"MapDeviceAddressSpace","","",N,N],[17,"UnmapDeviceAddressSpace","","",N,N],[17,"InvalidateProcessDataCache","","",N,N],[17,"StoreProcessDataCache","","",N,N],[17,"FlushProcessDataCache","","",N,N],[17,"DebugActiveProcess","","",N,N],[17,"BreakDebugProcess","","",N,N],[17,"TerminateDebugProcess","","",N,N],[17,"GetDebugEvent","","",N,N],[17,"ContinueDebugEvent","","",N,N],[17,"GetProcessList","","",N,N],[17,"GetThreadList","","",N,N],[17,"GetDebugThreadContext","","",N,N],[17,"SetDebugThreadContext","","",N,N],[17,"QueryDebugProcessMemory","","",N,N],[17,"ReadDebugProcessMemory","","",N,N],[17,"WriteDebugProcessMemory","","",N,N],[17,"SetHardwareBreakPoint","","",N,N],[17,"GetDebugThreadParam","","",N,N],[17,"GetSystemInfo","","",N,N],[17,"CreatePort","","",N,N],[17,"ManageNamedPort","","",N,N],[17,"ConnectToPort","","",N,N],[17,"SetProcessMemoryPermission","","",N,N],[17,"MapProcessMemory","","",N,N],[17,"UnmapProcessMemory","","",N,N],[17,"QueryProcessMemory","","",N,N],[17,"MapProcessCodeMemory","","",N,N],[17,"UnmapProcessCodeMemory","","",N,N],[17,"CreateProcess","","",N,N],[17,"StartProcess","","",N,N],[17,"TerminateProcess","","",N,N],[17,"GetProcessInfo","","",N,N],[17,"CreateResourceLimit","","",N,N],[17,"SetResourceLimitLimitValue","","",N,N],[17,"CallSecureMonitor","","",N,N],[17,"MapFramebuffer","","",N,N],[17,"StartProcessEntrypoint","","",N,N],[7,"SYSCALL_NAMES","kfs_libkern","",N,N],[18,"Unmapped","","An unmapped memory region. Reading will lead to a data…",0,N],[18,"Io","","Mapped by kernel capability parsing in `create_process`…",0,N],[18,"Normal","","Mapped by kernel capability parsing in `create_process`…",0,N],[18,"CodeStatic","","Mapped during create_process",0,N],[18,"CodeMutable","","Transition from MemoryType::CodeStatic performed by…",0,N],[18,"Heap","","Mapped using `set_heap_size` syscall.",0,N],[18,"SharedMemory","","Mapped using `map_shared_memory` syscall.",0,N],[18,"Alias","","Mapped using `map_memory` syscall.",0,N],[18,"ModuleCodeStatic","","Mapped using `map_process_code_memory` syscall.",0,N],[18,"ModuleCodeMutable","","Transition from MemoryType::ModuleCodeStatic by…",0,N],[18,"IpcBuffer0","","IPC buffers with descriptor flags=0.",0,N],[18,"Stack","","Mapped using `map_memory` syscall.",0,N],[18,"ThreadLocal","","Mapped during `create_thread` syscall.",0,N],[18,"TransferMemoryIsolated","","Mapped using `map_transfer_memory` syscall when the owning…",0,N],[18,"TransferMemory","","Mapped using `map_transfer_memory` syscall when the owning…",0,N],[18,"ProcessMemory","","Mapped using `map_process_memory` syscall.",0,N],[18,"Reserved","","Reserved memory area, used internally by kernel, should…",0,N],[18,"IpcBuffer1","","IPC buffers with descriptor flags=1.",0,N],[18,"IpcBuffer3","","IPC buffers with descriptor flags=3.",0,N],[18,"KernelStack","","Mapped in kernel during `create_thread`. Should not be…",0,N],[18,"CodeReadOnly","","Mapped using `control_code_memory` syscall.",0,N],[18,"CodeWritable","","Mapped using `control_code_memory` syscall.",0,N],[18,"BORROWED","","Is mapped in more than one area.",1,N],[18,"IPC_MAPPED","","Is mapped through an IPC request.",1,N],[18,"DEVICE_MAPPED","","Is a device mapping.",1,N],[18,"UNCACHED","","Is caching disabled in the MMU.",1,N],[11,"empty","","Returns an empty set of flags.",1,[[],["memoryattributes"]]],[11,"all","","Returns the set containing all flags.",1,[[],["memoryattributes"]]],[11,"bits","","Returns the raw value of the flags currently stored.",1,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",1,[[["u32"]],["option",["memoryattributes"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",1,[[["u32"]],["memoryattributes"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",1,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",1,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",1,[[["self"],["memoryattributes"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",1,[[["self"],["memoryattributes"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",1,[[["self"],["memoryattributes"]]]],[11,"remove","","Removes the specified flags in-place.",1,[[["self"],["memoryattributes"]]]],[11,"toggle","","Toggles the specified flags in-place.",1,[[["self"],["memoryattributes"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",1,[[["self"],["memoryattributes"],["bool"]]]],[18,"READABLE","","The area is readable.",2,N],[18,"WRITABLE","","The area is writable.",2,N],[18,"EXECUTABLE","","The area is executable.",2,N],[11,"empty","","Returns an empty set of flags.",2,[[],["memorypermissions"]]],[11,"all","","Returns the set containing all flags.",2,[[],["memorypermissions"]]],[11,"bits","","Returns the raw value of the flags currently stored.",2,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",2,[[["u32"]],["option",["memorypermissions"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",2,[[["u32"]],["memorypermissions"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",2,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",2,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",2,[[["self"],["memorypermissions"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",2,[[["self"],["memorypermissions"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",2,[[["self"],["memorypermissions"]]]],[11,"remove","","Removes the specified flags in-place.",2,[[["self"],["memorypermissions"]]]],[11,"toggle","","Toggles the specified flags in-place.",2,[[["self"],["memorypermissions"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",2,[[["self"],["memorypermissions"],["bool"]]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"from","kfs_libkern::error","",5,[[["t"]],["t"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"BORROWED","kfs_libkern","",1,[[["self"]],["bool"]]],[11,"IPC_MAPPED","","",1,[[["self"]],["bool"]]],[11,"DEVICE_MAPPED","","",1,[[["self"]],["bool"]]],[11,"UNCACHED","","",1,[[["self"]],["bool"]]],[11,"BORROWED","","",1,[[],["u32"]]],[11,"IPC_MAPPED","","",1,[[],["u32"]]],[11,"DEVICE_MAPPED","","",1,[[],["u32"]]],[11,"UNCACHED","","",1,[[],["u32"]]],[11,"READABLE","","",2,[[["self"]],["bool"]]],[11,"WRITABLE","","",2,[[["self"]],["bool"]]],[11,"EXECUTABLE","","",2,[[["self"]],["bool"]]],[11,"READABLE","","",2,[[],["u32"]]],[11,"WRITABLE","","",2,[[],["u32"]]],[11,"EXECUTABLE","","",2,[[],["u32"]]],[11,"fmt","kfs_libkern::error","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_libkern","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"eq","kfs_libkern::error","",5,[[["self"],["kernelerror"]],["bool"]]],[11,"ne","","",5,[[["self"],["kernelerror"]],["bool"]]],[11,"eq","kfs_libkern","",0,[[["self"],["memorytype"]],["bool"]]],[11,"ne","","",0,[[["self"],["memorytype"]],["bool"]]],[11,"eq","","",1,[[["self"],["memoryattributes"]],["bool"]]],[11,"ne","","",1,[[["self"],["memoryattributes"]],["bool"]]],[11,"eq","","",2,[[["self"],["memorypermissions"]],["bool"]]],[11,"ne","","",2,[[["self"],["memorypermissions"]],["bool"]]],[11,"assert_receiver_is_total_eq","kfs_libkern::error","",5,N],[11,"assert_receiver_is_total_eq","kfs_libkern","",0,N],[11,"assert_receiver_is_total_eq","","",1,N],[11,"assert_receiver_is_total_eq","","",2,N],[11,"cmp","","",1,[[["self"],["memoryattributes"]],["ordering"]]],[11,"cmp","","",2,[[["self"],["memorypermissions"]],["ordering"]]],[11,"partial_cmp","","",1,[[["self"],["memoryattributes"]],["option",["ordering"]]]],[11,"lt","","",1,[[["self"],["memoryattributes"]],["bool"]]],[11,"le","","",1,[[["self"],["memoryattributes"]],["bool"]]],[11,"gt","","",1,[[["self"],["memoryattributes"]],["bool"]]],[11,"ge","","",1,[[["self"],["memoryattributes"]],["bool"]]],[11,"partial_cmp","","",2,[[["self"],["memorypermissions"]],["option",["ordering"]]]],[11,"lt","","",2,[[["self"],["memorypermissions"]],["bool"]]],[11,"le","","",2,[[["self"],["memorypermissions"]],["bool"]]],[11,"gt","","",2,[[["self"],["memorypermissions"]],["bool"]]],[11,"ge","","",2,[[["self"],["memorypermissions"]],["bool"]]],[11,"hash","","",1,N],[11,"hash","","",2,N],[11,"sub","","Returns the set difference of the two sets of flags.",1,[[["self"],["memoryattributes"]],["memoryattributes"]]],[11,"sub","","Returns the set difference of the two sets of flags.",2,[[["self"],["memorypermissions"]],["memorypermissions"]]],[11,"sub_assign","","Disables all flags enabled in the set.",1,[[["self"],["memoryattributes"]]]],[11,"sub_assign","","Disables all flags enabled in the set.",2,[[["self"],["memorypermissions"]]]],[11,"not","","Returns the complement of this set of flags.",1,[[["self"]],["memoryattributes"]]],[11,"not","","Returns the complement of this set of flags.",2,[[["self"]],["memorypermissions"]]],[11,"bitand","","Returns the intersection between the two sets of flags.",1,[[["self"],["memoryattributes"]],["memoryattributes"]]],[11,"bitand","","Returns the intersection between the two sets of flags.",2,[[["self"],["memorypermissions"]],["memorypermissions"]]],[11,"bitor","","Returns the union of the two sets of flags.",1,[[["self"],["memoryattributes"]],["memoryattributes"]]],[11,"bitor","","Returns the union of the two sets of flags.",2,[[["self"],["memorypermissions"]],["memorypermissions"]]],[11,"bitxor","","Returns the left flags, but with all the right flags…",1,[[["self"],["memoryattributes"]],["memoryattributes"]]],[11,"bitxor","","Returns the left flags, but with all the right flags…",2,[[["self"],["memorypermissions"]],["memorypermissions"]]],[11,"bitand_assign","","Disables all flags disabled in the set.",1,[[["self"],["memoryattributes"]]]],[11,"bitand_assign","","Disables all flags disabled in the set.",2,[[["self"],["memorypermissions"]]]],[11,"bitor_assign","","Adds the set of flags.",1,[[["self"],["memoryattributes"]]]],[11,"bitor_assign","","Adds the set of flags.",2,[[["self"],["memorypermissions"]]]],[11,"bitxor_assign","","Toggles the set of flags.",1,[[["self"],["memoryattributes"]]]],[11,"bitxor_assign","","Toggles the set of flags.",2,[[["self"],["memorypermissions"]]]],[11,"deref","","",4,N],[11,"extend","","",1,[[["self"],["t"]]]],[11,"extend","","",2,[[["self"],["t"]]]],[11,"from_iter","","",1,[[["t"]],["memoryattributes"]]],[11,"from_iter","","",2,[[["t"]],["memorypermissions"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"clone","kfs_libkern::error","",5,[[["self"]],["kernelerror"]]],[11,"clone","kfs_libkern","",0,[[["self"]],["memorytype"]]],[11,"clone","","",1,[[["self"]],["memoryattributes"]]],[11,"clone","","",2,[[["self"]],["memorypermissions"]]],[11,"default","","",0,[[],["memorytype"]]],[11,"default","","",1,[[],["memoryattributes"]]],[11,"default","","",2,[[],["memorypermissions"]]],[11,"default","","",3,[[],["memoryinfo"]]],[11,"initialize","","",4,[[["self"]]]]],"paths":[[3,"MemoryType"],[3,"MemoryAttributes"],[3,"MemoryPermissions"],[3,"MemoryInfo"],[3,"SYSCALL_NAMES"],[3,"KernelError"]]};
searchIndex["kfs_libuser"]={"doc":"Userspace library","items":[[0,"io","kfs_libuser","The IO interface",N,N],[8,"Io","kfs_libuser::io","The Io trait allows for accessing device IO in a generic…",N,N],[16,"Value","","The width of the IO access. Should be a primitive type…",0,N],[10,"read","","Reads from this Io.",0,N],[10,"write","","Writes `value` to this Io.",0,N],[11,"readf","","Read from this Io, and mask the value with `flags`.",0,N],[11,"writef","","Mask `value` with `flags`, and write it to this device…",0,N],[3,"ReadOnly","","A read-only wrapper around an IO device.",N,N],[12,"inner","","",1,N],[3,"WriteOnly","","An Io that we can only write to.",N,N],[12,"inner","","",2,N],[3,"Pio","","Port IO accessor.",N,N],[12,"port","","",3,N],[12,"value","","",3,N],[5,"find_free_address","kfs_libuser","Finds a free memory zone of the given size and alignment…",N,[[["usize"],["usize"]],["result",["usize","error"]]]],[5,"eh_personality","","The exception handling personality function for use in the…",N,[[]]],[5,"panic_fmt","","Function called on `panic!` invocation. Prints the panic…",N,N],[5,"rust_oom","","OOM handler. Causes a panic.",N,N],[5,"start","","Executable entrypoint. Zeroes out the BSS, calls main, and…",N,N],[5,"main","","",N,N],[0,"syscalls","","Syscall Wrappers",N,N],[3,"MemoryInfo","kfs_libuser::syscalls","The structure returned by the `query_memory` syscall.",N,N],[12,"baseaddr","","The base address of this memory region.",4,N],[12,"size","","The size of this memory region, from the base address.",4,N],[12,"memtype","","The type of this mapping.",4,N],[12,"memattr","","The attributes of this mapping.",4,N],[12,"perms","","The permissions of this mapping.",4,N],[12,"ipc_ref_count","","Counts how many IPC service requests have an IPC buffer in…",4,N],[12,"device_ref_count","","Unknown.",4,N],[3,"MemoryPermissions","","Memory permissions of a memory area.",N,N],[12,"bits","","",5,N],[3,"Registers","","",N,N],[12,"eax","","",6,N],[12,"ebx","","",6,N],[12,"ecx","","",6,N],[12,"edx","","",6,N],[12,"esi","","",6,N],[12,"edi","","",6,N],[12,"ebp","","",6,N],[5,"syscall","","",N,[[["usize"],["usize"],["usize"],["usize"],["usize"],["usize"],["usize"]],["result",["kernelerror"]]]],[5,"set_heap_size","","Resize the heap of a process, just like a brk. It can both…",N,[[["usize"]],["result",["usize","kernelerror"]]]],[5,"query_memory","","Query information about an address. Will fetch the…",N,[[["usize"]],["result",["kernelerror"]]]],[5,"exit_process","","Exits the process, killing all threads.",N,N],[5,"create_thread","","Creates a thread in the current process.",N,N],[5,"start_thread","","Starts the thread for the provided handle.",N,[[["thread"]],["result",["kernelerror"]]]],[5,"exit_thread","","Exits the current thread.",N,N],[5,"sleep_thread","","Sleeps for a specified amount of time, or yield thread.",N,[[["usize"]],["result",["kernelerror"]]]],[5,"create_shared_memory","","Creates a shared memory handle.",N,[[["usize"],["memorypermissions"],["memorypermissions"]],["result",["sharedmemory","kernelerror"]]]],[5,"map_shared_memory","","Maps a shared memory.",N,[[["sharedmemory"],["usize"],["usize"],["memorypermissions"]],["result",["kernelerror"]]]],[5,"unmap_shared_memory","","Unmaps a shared memory.",N,[[["sharedmemory"],["usize"],["usize"]],["result",["kernelerror"]]]],[5,"close_handle","","Close the given handle.",N,[[["u32"]],["result",["kernelerror"]]]],[5,"wait_synchronization","","Wait for an event on the given handles.",N,N],[5,"connect_to_named_port","","Creates a session to the given named port.",N,[[["str"]],["result",["clientsession","kernelerror"]]]],[5,"send_sync_request_with_user_buffer","","Send an IPC request through the given pipe.",N,N],[5,"output_debug_string","","Print the given string to the kernel's debug output.",N,[[["str"]],["result",["kernelerror"]]]],[5,"create_session","","Create an anonymous session.",N,[[["bool"],["usize"]],["result",["kernelerror"]]]],[5,"accept_session","","Accept a connection on the given port.",N,[[["serverport"]],["result",["serversession","kernelerror"]]]],[5,"reply_and_receive_with_user_buffer","","Reply and Receive IPC requests on the given handles.",N,N],[5,"create_interrupt_event","","Create a waitable object for the given IRQ number.",N,[[["usize"],["u32"]],["result",["readableevent","kernelerror"]]]],[5,"create_port","","Creates an anonymous port.",N,[[["u32"],["bool"],["str"]],["result",["kernelerror"]]]],[5,"manage_named_port","","Creates a named port.",N,[[["str"],["u32"]],["result",["serverport","kernelerror"]]]],[5,"connect_to_port","","Connects to the given named port.",N,[[["clientport"]],["result",["clientsession","kernelerror"]]]],[5,"map_framebuffer","","Maps the framebuffer to a kernel-chosen address.",N,[[],["result",["kernelerror"]]]],[5,"syscall_inner","","",N,N],[0,"types","kfs_libuser","Core kernel types.",N,N],[3,"Handle","kfs_libuser::types","A Handle is a sort of reference to a Kernel Object. Its…",N,N],[12,"0","","",7,N],[3,"HandleRef","","A fake reference to a Handle. Has the same representation…",N,N],[12,"inner","","",8,N],[12,"lifetime","","",8,N],[3,"ReadableEvent","","An awaitable event handle, such as an IRQ event.",N,N],[12,"0","","",9,N],[3,"ClientSession","","The client side of an IPC session.",N,N],[12,"0","","",10,N],[3,"ServerSession","","The server side of an IPC session.",N,N],[12,"0","","",11,N],[3,"ClientPort","","The client side of an IPC Port. Allows connecting to an…",N,N],[12,"0","","",12,N],[3,"ServerPort","","The server side of an IPC Port. Allows listening for…",N,N],[12,"0","","",13,N],[3,"Thread","","A Thread. Created with the [create_thread syscall].",N,N],[12,"0","","",14,N],[3,"SharedMemory","","A handle to memory that may be mapped in multiple…",N,N],[12,"0","","",15,N],[3,"MappedSharedMemory","","A mapping to a shared memory region.",N,N],[12,"handle","","",16,N],[12,"addr","","",16,N],[12,"size","","",16,N],[3,"Pid","","Process ID, as returned by IPC.",N,N],[12,"0","","",17,N],[11,"new","","Creates a new handle from the given number. This number…",7,[[["u32"]],["handle"]]],[11,"as_ref","","Creates a new reference to this handle. See the…",7,[[["self"]],["handleref"]]],[11,"send_sync_request_with_user_buffer","","Send an IPC request to the handle, and wait for a…",10,N],[11,"into_handle","","Consumes the session, returning the underlying handle.…",10,[[["self"]],["handle"]]],[11,"receive","","Receives an IPC request from the session, waiting if none…",11,N],[11,"reply","","Replies to an IPC request on the given session. If the…",11,N],[11,"connect","","Connects to a port, returning a session on which to send…",12,[[["self"]],["result",["clientsession","error"]]]],[11,"accept","","Accepts a connection to the port, returning a server…",13,[[["self"]],["result",["serversession","error"]]]],[11,"start","","Start the thread.",14,[[["self"]],["result",["error"]]]],[11,"new","","Creates a new Shared Memory handle. The physical memory…",15,[[["usize"],["memorypermissions"],["memorypermissions"]],["result",["sharedmemory","error"]]]],[11,"map","","Maps the current shared memory at the given address,…",15,[[["self"],["usize"],["usize"],["memorypermissions"]],["result",["mappedsharedmemory","error"]]]],[11,"get","","Get the underlying shared memory as a byte slice.",16,N],[11,"get_mut","","Get the underlying shared memory as a mutable byte slice.",16,N],[11,"as_ptr","","Gets a raw pointer to the underlying shared memory.",16,N],[11,"as_mut_ptr","","Gets a mutable raw pointer to the underlying shared memory.",16,N],[11,"len","","Gets the byte length of the mapped shared memory.",16,[[["self"]],["usize"]]],[11,"as_shared_mem","","Return a reference to the underlying shared memory. Useful…",16,[[["self"]],["sharedmemory"]]],[0,"ipc","kfs_libuser","Core IPC Routines",N,N],[3,"MsgPackedHdr","kfs_libuser::ipc","Represenens the header of an HIPC command.",N,N],[12,"0","","",18,N],[3,"HandleDescriptorHeader","","Part of an HIPC command. Sent only when…",N,N],[12,"0","","",19,N],[3,"IPCBuffer","","An IPC Buffer represents a section of memory to send to…",N,N],[12,"addr","","Address to the value",20,N],[12,"size","","Size of the value",20,N],[12,"ty","","Buffer type",20,N],[12,"phantom","","Tie the buffer's lifetime to the value's ! This is very…",20,N],[3,"Message","","A generic IPC message, representing either an IPC Request…",N,N],[12,"ty","","",21,N],[12,"pid","","",21,N],[12,"buffers","","",21,N],[12,"copy_handles","","",21,N],[12,"move_handles","","",21,N],[12,"is_request","","",21,N],[12,"cmdid_error","","",21,N],[12,"token","","",21,N],[12,"raw","","",21,N],[4,"IPCBufferType","","Type of an IPC Buffer. Depending on the type, the kernel…",N,N],[13,"A","","Send Buffer.",22,N],[12,"flags","kfs_libuser::ipc::IPCBufferType","Determines what MemoryState to use with the mapped memory…",22,N],[13,"B","kfs_libuser::ipc","Receive Buffer.",22,N],[12,"flags","kfs_libuser::ipc::IPCBufferType","Determines what MemoryState to use with the mapped memory…",22,N],[13,"X","kfs_libuser::ipc","Pointer.",22,N],[12,"counter","kfs_libuser::ipc::IPCBufferType","The index of the C buffer to copy this pointer into.",22,N],[13,"C","kfs_libuser::ipc","Receive List.",22,N],[12,"has_u16_size","kfs_libuser::ipc::IPCBufferType","If true, the size of the receive list should be written in…",22,N],[4,"MessageTy","kfs_libuser::ipc","Type of an IPC message.",N,N],[13,"Close","","Requests the other end to close the handle and any…",23,N],[13,"Request","","A normal request.",23,N],[13,"Control","","A request handled by the server handler. See [switchbrew]…",23,N],[5,"find_ty_cmdid","","Quickly find the type and cmdid of an IPC message for the…",N,N],[0,"macros","","IPC Macros",N,N],[0,"server","","IPC Server primitives",N,N],[3,"WaitableManager","kfs_libuser::ipc::server","The event loop manager. Waits on the waitable objects…",N,N],[12,"to_add_waitables","","",24,N],[3,"Align16","","",N,N],[12,"0","","",25,N],[3,"SessionWrapper","","A wrapper around an Object backed by an IPC Session that…",N,N],[12,"handle","","",26,N],[12,"object","","",26,N],[12,"buf","","",26,N],[3,"PortHandler","","A wrapper around a Server Port that implements the…",N,N],[12,"handle","","",27,N],[12,"phantom","","",27,N],[5,"encode_bytes","","",N,[[["str"]],["u64"]]],[8,"IWaitable","","A handle to a waitable object.",N,N],[10,"get_handle","","Gets the handleref for use in the `wait_synchronization`…",28,[[["self"]],["handleref"]]],[10,"handle_signaled","","Function the manager calls when this object gets signaled.",28,[[["self"],["waitablemanager"]],["result",["bool","error"]]]],[8,"Object","","An IPC object.",N,N],[10,"dispatch","","Handle a request with the given cmdid.",29,N],[11,"new","","Creates an empty waitable manager.",24,[[],["waitablemanager"]]],[11,"add_waitable","","Add a new handle for the waitable manager to wait on.",24,[[["self"],["box",["iwaitable"]]]]],[11,"run","","Run the event loop. This will call wait_synchronization on…",24,N],[11,"new","","Create a new SessionWrapper from an open ServerSession and…",26,[[["serversession"],["t"]],["sessionwrapper"]]],[11,"new","","Registers a new PortHandler of the given name to the sm:…",27,[[["str"]],["result",["porthandler","error"]]]],[11,"new_managed","","Registers a new PortHandler of the given name to the…",27,[[["str"]],["result",["porthandler","error"]]]],[11,"ty","kfs_libuser::ipc","",18,[[["self"]],["u16"]]],[11,"set_ty","","",18,[[["self"],["u16"]]]],[11,"num_x_descriptors","","",18,[[["self"]],["u8"]]],[11,"set_num_x_descriptors","","",18,[[["self"],["u8"]]]],[11,"num_a_descriptors","","",18,[[["self"]],["u8"]]],[11,"set_num_a_descriptors","","",18,[[["self"],["u8"]]]],[11,"num_b_descriptors","","",18,[[["self"]],["u8"]]],[11,"set_num_b_descriptors","","",18,[[["self"],["u8"]]]],[11,"num_w_descriptors","","",18,[[["self"]],["u8"]]],[11,"set_num_w_descriptors","","",18,[[["self"],["u8"]]]],[11,"raw_section_size","","",18,[[["self"]],["u16"]]],[11,"set_raw_section_size","","",18,[[["self"],["u16"]]]],[11,"c_descriptor_flags","","",18,[[["self"]],["u8"]]],[11,"set_c_descriptor_flags","","",18,[[["self"],["u8"]]]],[11,"enable_handle_descriptor","","",18,[[["self"]],["bool"]]],[11,"set_enable_handle_descriptor","","",18,[[["self"],["bool"]]]],[11,"send_pid","","",19,[[["self"]],["bool"]]],[11,"set_send_pid","","",19,[[["self"],["bool"]]]],[11,"num_copy_handles","","",19,[[["self"]],["u8"]]],[11,"set_num_copy_handles","","",19,[[["self"],["u8"]]]],[11,"num_move_handles","","",19,[[["self"]],["u8"]]],[11,"set_num_move_handles","","",19,[[["self"],["u8"]]]],[11,"from_mut_ref","","Creates an IPC buffer from a mutable reference and a type.…",20,[[["t"],["ipcbuffertype"]],["ipcbuffer"]]],[11,"from_ref","","Creates an IPC buffer from a reference and a type. The…",20,[[["t"],["ipcbuffertype"]],["ipcbuffer"]]],[11,"from_slice","","Creates an IPC buffer from a mutable slice and a type. The…",20,N],[11,"from_mut_slice","","Creates an IPC buffer from a slice and a type. The type…",20,N],[11,"from_ptr_len","","Creates an IPC buffer from a raw pointer, a len and a…",20,N],[11,"from_mut_ptr_len","","Creates an IPC buffer from a raw mut pointer, a len and a…",20,N],[11,"buftype","","",20,[[["self"]],["ipcbuffertype"]]],[11,"new_request","","Create a new request for the given cmdid. If a token is…",21,[[["option",["u32"]],["u32"]],["message"]]],[11,"new_response","","Create a new empty reply. If the request this reply is…",21,[[["option",["u32"]]],["message"]]],[11,"set_ty","","Sets the message type.",21,[[["self"],["messagety"]],["self"]]],[11,"set_error","","Set the error code from a reply.",21,[[["self"],["u32"]],["self"]]],[11,"error","","Get the error code from a reply.",21,[[["self"]],["result",["error"]]]],[11,"push_raw","","Sets the raw data of the message.",21,[[["self"],["raw"]],["self"]]],[11,"raw","","Gets the raw data of the message.",21,[[["self"]],["raw"]]],[11,"token","","Gets the token of a message. This token is used to track…",21,[[["self"]],["option",["u32"]]]],[11,"push_handle_move","","Move a handle over IPC. Once the message is sent, the…",21,[[["self"],["handle"]],["self"]]],[11,"push_handle_copy","","Copy a handle over IPC. The remote process will have a…",21,[[["self"],["handleref"]],["self"]]],[11,"pop_handle_move","","Retrieve a moved handle from this IPC message. Those are…",21,[[["self"]],["result",["handle","error"]]]],[11,"pop_handle_copy","","Retrieve a copied handle from this IPC message. Those are…",21,[[["self"]],["result",["handle","error"]]]],[11,"pop_pid","","Retrieve the PID of the remote process (if sent at all).…",21,[[["self"]],["result",["pid","error"]]]],[11,"pack","","Packs this IPC Message to an IPC buffer.",21,N],[11,"unpack","","Parse the passed buffer into an IPC Message.",21,N],[0,"sm","kfs_libuser","Service Manager",N,N],[3,"IUserInterface","kfs_libuser::sm","Main interface of the service manager. Allows registering…",N,N],[12,"0","","",30,N],[11,"raw_new","","Connects to the Service Manager.",30,[[],["result",["iuserinterface","error"]]]],[11,"get_service","","Retrieves a service registered in the service manager.",30,[[["self"],["u64"]],["result",["clientsession","error"]]]],[11,"register_service","","Registers a service registered in the service manager.",30,[[["self"],["u64"],["bool"],["u32"]],["result",["serverport","error"]]]],[0,"vi","kfs_libuser","Vi Compositor service",N,N],[3,"ViInterface","kfs_libuser::vi","Main compositor interface.",N,N],[12,"0","","",31,N],[3,"IBuffer","","A handle to a window. Created through the create_buffer…",N,N],[12,"0","","",32,N],[11,"raw_new","","Connects to the vi service.",31,[[],["result",["viinterface","error"]]]],[11,"create_buffer","","Create a new window of the given size at the given…",31,[[["self"],["sharedmemory"],["i32"],["i32"],["u32"],["u32"]],["result",["ibuffer","error"]]]],[11,"draw","","Ask the compositor to redraw the window. This will cause…",32,[[["self"]],["result",["error"]]]],[0,"error","kfs_libuser","Error handling",N,N],[3,"KernelError","kfs_libuser::error","Kernel syscall error codes.",N,N],[12,"0","","",33,N],[3,"Module","","",N,N],[12,"0","","",34,N],[3,"LibuserError","","Internal libuser errors.",N,N],[12,"0","","",35,N],[3,"SmError","","Service Manager errors.",N,N],[12,"0","","",36,N],[4,"Error","","The global error type. Every error defined here can be…",N,N],[13,"Kernel","","A Kernel Error. Usually returned by syscalls.",37,N],[13,"Sm","","Service Manager error.",37,N],[13,"Libuser","","Internal Libuser error.",37,N],[13,"Unknown","","An unknown error type. Either someone returned a custom…",37,N],[17,"_DERIVE_failure_Fail_FOR_Error","","",N,N],[11,"from_code","","Create an Error from a packed error code, creating a…",37,[[["u32"]],["error"]]],[11,"into_code","","Pack this error into an error code. Note that the returned…",37,[[["self"]],["u32"]]],[18,"Kernel","","",34,N],[18,"Sm","","",34,N],[18,"Vi","","",34,N],[18,"Libuser","","",34,N],[18,"AddressSpaceExhausted","","An attempt to find available space failed.",35,N],[18,"InvalidMoveHandleCount","","Too many move handles were passed to an IPC message.",35,N],[18,"InvalidCopyHandleCount","","Too many copy handles were passed to an IPC message.",35,N],[18,"PidMissing","","Attempted to read PID from an IPC message containing none.",35,N],[18,"OutOfProcesses","","Too many processes spawned.",36,N],[18,"NotInitialized","","Attempted to use the service manager without initializing…",36,N],[18,"MaxSessions","","This service already reached the maximum amount of…",36,N],[18,"ServiceAlreadyRegistered","","Attempted to register a service that already exists.",36,N],[18,"OutOfServices","","Too many services have been created.",36,N],[18,"InvalidName","","The name is too long. Make sure it's only 7 characters and…",36,N],[18,"ServiceNotRegistered","","Attempted to unregister a service that was not previously…",36,N],[18,"PermissionDenied","","Process SACs do not allow accessing or hosting this service.",36,N],[18,"ServiceAccessControlTooBig","","The provided SACs are too big.",36,N],[0,"allocator","kfs_libuser","Heap allocator.",N,N],[3,"Allocator","kfs_libuser::allocator","The libuser heap allocator.",N,N],[12,"0","","",38,N],[11,"expand","","Safely expands the heap if possible.",38,[[["mutexguard"],["usize"]],["result",["kernelerror"]]]],[11,"new","","Creates an empty heap.",38,[[],["allocator"]]],[0,"terminal","kfs_libuser","Terminal rendering APIs",N,N],[3,"Pos","kfs_libuser::terminal","Just an x and a y",N,N],[12,"x","","",39,N],[12,"y","","",39,N],[3,"Terminal","","A struct for logging text to the window. Renders…",N,N],[12,"framebuffer","","",40,N],[12,"cursor_pos","","",40,N],[12,"font","","",40,N],[12,"cached_glyphs","","",40,N],[12,"advance_width","","",40,N],[12,"linespace","","",40,N],[12,"ascent","","",40,N],[12,"descent","","",40,N],[4,"WindowSize","","Window creation requested size.",N,N],[13,"Fullscreen","","Takes the full screen.",41,N],[13,"FontLines","","Takes a given amount of lines.",41,N],[13,"Manual","","Manually position the window at the given x/y, with a…",41,N],[7,"FONT","","The font we choose to render in",N,N],[17,"FONT_SIZE","","The size we choose to render in",N,N],[11,"new","","Creates a new Window of the requested size for terminal…",40,[[["windowsize"]],["result",["error"]]]],[11,"draw","","Ask the compositor to redraw the window.",40,[[["self"]],["result",["error"]]]],[11,"carriage_return","","",40,[[["self"]]]],[11,"line_feed","","",40,[[["self"]]]],[11,"advance_pos","","",40,[[["self"]]]],[11,"move_pos_back","","",40,[[["self"]]]],[11,"scroll_screen","","scrolls the whole screen by one line. self.pos must be on…",40,[[["self"]]]],[11,"clear","","Clears the whole screen and reset cursor",40,[[["self"]]]],[11,"print_attr","","Prints a string to the screen with attributes",40,[[["self"],["str"],["color"],["color"]]]],[11,"display_glyph_in_box","","Copies a rendered character to the screen, displaying it…",40,[[["glyphbitmap"],["window"],["usize"],["usize"],["usize"],["color"],["color"],["pos"]]]],[0,"window","kfs_libuser","Window creation and drawing APIs",N,N],[3,"Color","kfs_libuser::window","A rgb color",N,N],[12,"b","","Blue component",42,N],[12,"g","","Green component",42,N],[12,"r","","Red component",42,N],[12,"a","","Alpha component",42,N],[3,"Window","","A managed window.",N,N],[12,"buf","","",43,N],[12,"handle","","",43,N],[12,"width","","",43,N],[12,"height","","",43,N],[12,"bpp","","",43,N],[11,"rgb","","Creates a color from the r/g/b components. Alpha will be…",42,[[["u8"],["u8"],["u8"]],["color"]]],[11,"new","","Creates a window in the vi compositor.",43,[[["i32"],["i32"],["u32"],["u32"]],["result",["window","error"]]]],[11,"draw","","Ask the compositor to redraw the window.",43,[[["self"]],["result",["error"]]]],[11,"width","","window width in pixels. Does not account for bpp",43,[[["self"]],["usize"]]],[11,"height","","window height in pixels. Does not account for bpp",43,[[["self"]],["usize"]]],[11,"bpp","","The number of bits that forms a pixel. Used to compute…",43,[[["self"]],["usize"]]],[11,"get_px_offset","","Gets the offset in memory of a pixel based on an x and y.",43,[[["self"],["usize"],["usize"]],["usize"]]],[11,"write_px","","Writes a pixel in the window respecting the bgr pattern",43,[[["self"],["usize"],["color"]]]],[11,"write_px_at","","Writes a pixel in the window respecting the bgr pattern…",43,[[["self"],["usize"],["usize"],["color"]]]],[11,"get_buffer","","Gets the underlying framebuffer",43,N],[11,"clear","","Clears the whole window, making it black.",43,[[["self"]]]],[0,"__rg_allocator_abi","kfs_libuser","",N,N],[5,"__rg_alloc","kfs_libuser::__rg_allocator_abi","",N,N],[5,"__rg_dealloc","","",N,N],[5,"__rg_realloc","","",N,N],[5,"__rg_alloc_zeroed","","",N,N],[7,"ALLOCATOR","kfs_libuser","",N,N],[8,"Termination","","",N,N],[10,"report","","",44,[[["self"]],["i32"]]],[14,"object","","Auto derive Object.",N,N],[11,"from","kfs_libuser::io","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"from","kfs_libuser::syscalls","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"from","","",6,[[["t"]],["t"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"from","kfs_libuser::types","",7,[[["t"]],["t"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"from","","",8,[[["t"]],["t"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"from","","",9,[[["t"]],["t"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"from","","",10,[[["t"]],["t"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"from","","",11,[[["t"]],["t"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"from","","",12,[[["t"]],["t"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"from","","",13,[[["t"]],["t"]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"into","","",13,[[["self"]],["u"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"from","","",14,[[["t"]],["t"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"try_into","","",14,[[["self"]],["result"]]],[11,"into","","",14,[[["self"]],["u"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"get_type_id","","",14,[[["self"]],["typeid"]]],[11,"from","","",15,[[["t"]],["t"]]],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"try_into","","",15,[[["self"]],["result"]]],[11,"into","","",15,[[["self"]],["u"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"get_type_id","","",15,[[["self"]],["typeid"]]],[11,"from","","",16,[[["t"]],["t"]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"into","","",16,[[["self"]],["u"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"from","","",17,[[["t"]],["t"]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"into","","",17,[[["self"]],["u"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"get_type_id","","",17,[[["self"]],["typeid"]]],[11,"to_owned","","",17,[[["self"]],["t"]]],[11,"clone_into","","",17,N],[11,"from","kfs_libuser::ipc","",18,[[["t"]],["t"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"into","","",18,[[["self"]],["u"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"get_type_id","","",18,[[["self"]],["typeid"]]],[11,"bit","","",18,[[["self"],["usize"]],["bool"]]],[11,"set_bit","","",18,N],[11,"from","","",19,[[["t"]],["t"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"try_into","","",19,[[["self"]],["result"]]],[11,"into","","",19,[[["self"]],["u"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"get_type_id","","",19,[[["self"]],["typeid"]]],[11,"bit","","",19,[[["self"],["usize"]],["bool"]]],[11,"set_bit","","",19,N],[11,"from","","",20,[[["t"]],["t"]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"try_into","","",20,[[["self"]],["result"]]],[11,"into","","",20,[[["self"]],["u"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"get_type_id","","",20,[[["self"]],["typeid"]]],[11,"to_owned","","",20,[[["self"]],["t"]]],[11,"clone_into","","",20,N],[11,"from","","",21,[[["t"]],["t"]]],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"try_into","","",21,[[["self"]],["result"]]],[11,"into","","",21,[[["self"]],["u"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"get_type_id","","",21,[[["self"]],["typeid"]]],[11,"from","","",22,[[["t"]],["t"]]],[11,"try_from","","",22,[[["u"]],["result"]]],[11,"try_into","","",22,[[["self"]],["result"]]],[11,"into","","",22,[[["self"]],["u"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"get_type_id","","",22,[[["self"]],["typeid"]]],[11,"to_owned","","",22,[[["self"]],["t"]]],[11,"clone_into","","",22,N],[11,"from","","",23,[[["t"]],["t"]]],[11,"try_from","","",23,[[["u"]],["result"]]],[11,"try_into","","",23,[[["self"]],["result"]]],[11,"into","","",23,[[["self"]],["u"]]],[11,"borrow","","",23,[[["self"]],["t"]]],[11,"borrow_mut","","",23,[[["self"]],["t"]]],[11,"get_type_id","","",23,[[["self"]],["typeid"]]],[11,"from","kfs_libuser::ipc::server","",24,[[["t"]],["t"]]],[11,"try_from","","",24,[[["u"]],["result"]]],[11,"try_into","","",24,[[["self"]],["result"]]],[11,"into","","",24,[[["self"]],["u"]]],[11,"borrow","","",24,[[["self"]],["t"]]],[11,"borrow_mut","","",24,[[["self"]],["t"]]],[11,"get_type_id","","",24,[[["self"]],["typeid"]]],[11,"from","","",25,[[["t"]],["t"]]],[11,"try_from","","",25,[[["u"]],["result"]]],[11,"try_into","","",25,[[["self"]],["result"]]],[11,"into","","",25,[[["self"]],["u"]]],[11,"borrow","","",25,[[["self"]],["t"]]],[11,"borrow_mut","","",25,[[["self"]],["t"]]],[11,"get_type_id","","",25,[[["self"]],["typeid"]]],[11,"from","","",26,[[["t"]],["t"]]],[11,"try_from","","",26,[[["u"]],["result"]]],[11,"try_into","","",26,[[["self"]],["result"]]],[11,"into","","",26,[[["self"]],["u"]]],[11,"borrow","","",26,[[["self"]],["t"]]],[11,"borrow_mut","","",26,[[["self"]],["t"]]],[11,"get_type_id","","",26,[[["self"]],["typeid"]]],[11,"from","","",27,[[["t"]],["t"]]],[11,"try_from","","",27,[[["u"]],["result"]]],[11,"try_into","","",27,[[["self"]],["result"]]],[11,"into","","",27,[[["self"]],["u"]]],[11,"borrow","","",27,[[["self"]],["t"]]],[11,"borrow_mut","","",27,[[["self"]],["t"]]],[11,"get_type_id","","",27,[[["self"]],["typeid"]]],[11,"from","kfs_libuser::sm","",30,[[["t"]],["t"]]],[11,"try_from","","",30,[[["u"]],["result"]]],[11,"try_into","","",30,[[["self"]],["result"]]],[11,"into","","",30,[[["self"]],["u"]]],[11,"borrow","","",30,[[["self"]],["t"]]],[11,"borrow_mut","","",30,[[["self"]],["t"]]],[11,"get_type_id","","",30,[[["self"]],["typeid"]]],[11,"from","kfs_libuser::vi","",31,[[["t"]],["t"]]],[11,"try_from","","",31,[[["u"]],["result"]]],[11,"try_into","","",31,[[["self"]],["result"]]],[11,"into","","",31,[[["self"]],["u"]]],[11,"borrow","","",31,[[["self"]],["t"]]],[11,"borrow_mut","","",31,[[["self"]],["t"]]],[11,"get_type_id","","",31,[[["self"]],["typeid"]]],[11,"from","","",32,[[["t"]],["t"]]],[11,"try_from","","",32,[[["u"]],["result"]]],[11,"try_into","","",32,[[["self"]],["result"]]],[11,"into","","",32,[[["self"]],["u"]]],[11,"borrow","","",32,[[["self"]],["t"]]],[11,"borrow_mut","","",32,[[["self"]],["t"]]],[11,"get_type_id","","",32,[[["self"]],["typeid"]]],[11,"from","kfs_libuser::error","",33,[[["t"]],["t"]]],[11,"try_from","","",33,[[["u"]],["result"]]],[11,"try_into","","",33,[[["self"]],["result"]]],[11,"into","","",33,[[["self"]],["u"]]],[11,"borrow","","",33,[[["self"]],["t"]]],[11,"borrow_mut","","",33,[[["self"]],["t"]]],[11,"get_type_id","","",33,[[["self"]],["typeid"]]],[11,"to_owned","","",33,[[["self"]],["t"]]],[11,"clone_into","","",33,N],[11,"to_string","","",33,[[["self"]],["string"]]],[11,"from","","",34,[[["t"]],["t"]]],[11,"try_from","","",34,[[["u"]],["result"]]],[11,"try_into","","",34,[[["self"]],["result"]]],[11,"into","","",34,[[["self"]],["u"]]],[11,"borrow","","",34,[[["self"]],["t"]]],[11,"borrow_mut","","",34,[[["self"]],["t"]]],[11,"get_type_id","","",34,[[["self"]],["typeid"]]],[11,"to_owned","","",34,[[["self"]],["t"]]],[11,"clone_into","","",34,N],[11,"from","","",35,[[["t"]],["t"]]],[11,"try_from","","",35,[[["u"]],["result"]]],[11,"try_into","","",35,[[["self"]],["result"]]],[11,"into","","",35,[[["self"]],["u"]]],[11,"borrow","","",35,[[["self"]],["t"]]],[11,"borrow_mut","","",35,[[["self"]],["t"]]],[11,"get_type_id","","",35,[[["self"]],["typeid"]]],[11,"to_owned","","",35,[[["self"]],["t"]]],[11,"clone_into","","",35,N],[11,"from","","",36,[[["t"]],["t"]]],[11,"try_from","","",36,[[["u"]],["result"]]],[11,"try_into","","",36,[[["self"]],["result"]]],[11,"into","","",36,[[["self"]],["u"]]],[11,"borrow","","",36,[[["self"]],["t"]]],[11,"borrow_mut","","",36,[[["self"]],["t"]]],[11,"get_type_id","","",36,[[["self"]],["typeid"]]],[11,"to_owned","","",36,[[["self"]],["t"]]],[11,"clone_into","","",36,N],[11,"from","","",37,[[["t"]],["t"]]],[11,"try_from","","",37,[[["u"]],["result"]]],[11,"try_into","","",37,[[["self"]],["result"]]],[11,"into","","",37,[[["self"]],["u"]]],[11,"borrow","","",37,[[["self"]],["t"]]],[11,"borrow_mut","","",37,[[["self"]],["t"]]],[11,"get_type_id","","",37,[[["self"]],["typeid"]]],[11,"to_string","","",37,[[["self"]],["string"]]],[11,"as_fail","","",37,[[["self"]],["fail"]]],[11,"from","kfs_libuser::allocator","",38,[[["t"]],["t"]]],[11,"try_from","","",38,[[["u"]],["result"]]],[11,"try_into","","",38,[[["self"]],["result"]]],[11,"into","","",38,[[["self"]],["u"]]],[11,"borrow","","",38,[[["self"]],["t"]]],[11,"borrow_mut","","",38,[[["self"]],["t"]]],[11,"get_type_id","","",38,[[["self"]],["typeid"]]],[11,"from","kfs_libuser::terminal","",39,[[["t"]],["t"]]],[11,"try_from","","",39,[[["u"]],["result"]]],[11,"try_into","","",39,[[["self"]],["result"]]],[11,"into","","",39,[[["self"]],["u"]]],[11,"borrow","","",39,[[["self"]],["t"]]],[11,"borrow_mut","","",39,[[["self"]],["t"]]],[11,"get_type_id","","",39,[[["self"]],["typeid"]]],[11,"to_owned","","",39,[[["self"]],["t"]]],[11,"clone_into","","",39,N],[11,"from","","",40,[[["t"]],["t"]]],[11,"try_from","","",40,[[["u"]],["result"]]],[11,"try_into","","",40,[[["self"]],["result"]]],[11,"into","","",40,[[["self"]],["u"]]],[11,"borrow","","",40,[[["self"]],["t"]]],[11,"borrow_mut","","",40,[[["self"]],["t"]]],[11,"get_type_id","","",40,[[["self"]],["typeid"]]],[11,"from","","",41,[[["t"]],["t"]]],[11,"try_from","","",41,[[["u"]],["result"]]],[11,"try_into","","",41,[[["self"]],["result"]]],[11,"into","","",41,[[["self"]],["u"]]],[11,"borrow","","",41,[[["self"]],["t"]]],[11,"borrow_mut","","",41,[[["self"]],["t"]]],[11,"get_type_id","","",41,[[["self"]],["typeid"]]],[11,"from","kfs_libuser::window","",42,[[["t"]],["t"]]],[11,"try_from","","",42,[[["u"]],["result"]]],[11,"try_into","","",42,[[["self"]],["result"]]],[11,"into","","",42,[[["self"]],["u"]]],[11,"borrow","","",42,[[["self"]],["t"]]],[11,"borrow_mut","","",42,[[["self"]],["t"]]],[11,"get_type_id","","",42,[[["self"]],["typeid"]]],[11,"to_owned","","",42,[[["self"]],["t"]]],[11,"clone_into","","",42,N],[11,"from","","",43,[[["t"]],["t"]]],[11,"try_from","","",43,[[["u"]],["result"]]],[11,"try_into","","",43,[[["self"]],["result"]]],[11,"into","","",43,[[["self"]],["u"]]],[11,"borrow","","",43,[[["self"]],["t"]]],[11,"borrow_mut","","",43,[[["self"]],["t"]]],[11,"get_type_id","","",43,[[["self"]],["typeid"]]],[11,"clone","kfs_libuser::io","",3,[[["self"]],["pio"]]],[11,"read","","Read",3,[[["self"]],["u8"]]],[11,"write","","Write",3,N],[11,"read","","Read",3,[[["self"]],["u16"]]],[11,"write","","Write",3,N],[11,"read","","Read",3,[[["self"]],["u32"]]],[11,"write","","Write",3,N],[11,"bitxor_assign","kfs_libuser::syscalls","Toggles the set of flags.",5,N],[11,"not","","Returns the complement of this set of flags.",5,[[["self"]],["memorypermissions"]]],[11,"fmt","kfs_libuser::error","",33,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","kfs_libuser::syscalls","",4,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result",["error"]]]],[11,"sub_assign","","Disables all flags enabled in the set.",5,N],[11,"hash","","",5,N],[11,"bitand_assign","","Disables all flags disabled in the set.",5,N],[11,"clone","","",5,[[["self"]],["memorypermissions"]]],[11,"clone","kfs_libuser::error","",33,[[["self"]],["kernelerror"]]],[11,"bitxor","kfs_libuser::syscalls","Returns the left flags, but with all the right flags…",5,[[["self"],["memorypermissions"]],["memorypermissions"]]],[11,"eq","kfs_libuser::error","",33,[[["self"],["kernelerror"]],["bool"]]],[11,"ne","","",33,[[["self"],["kernelerror"]],["bool"]]],[11,"eq","kfs_libuser::syscalls","",5,[[["self"],["memorypermissions"]],["bool"]]],[11,"ne","","",5,[[["self"],["memorypermissions"]],["bool"]]],[11,"bitor","","Returns the union of the two sets of flags.",5,[[["self"],["memorypermissions"]],["memorypermissions"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","kfs_libuser::error","",33,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","kfs_libuser::syscalls","",5,[[["self"],["formatter"]],["result",["error"]]]],[11,"from_iter","","",5,[[["t"]],["memorypermissions"]]],[11,"partial_cmp","","",5,[[["self"],["memorypermissions"]],["option",["ordering"]]]],[11,"lt","","",5,[[["self"],["memorypermissions"]],["bool"]]],[11,"le","","",5,[[["self"],["memorypermissions"]],["bool"]]],[11,"gt","","",5,[[["self"],["memorypermissions"]],["bool"]]],[11,"ge","","",5,[[["self"],["memorypermissions"]],["bool"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result",["error"]]]],[11,"bitor_assign","","Adds the set of flags.",5,N],[11,"fmt","","",5,[[["self"],["formatter"]],["result",["error"]]]],[11,"sub","","Returns the set difference of the two sets of flags.",5,[[["self"],["memorypermissions"]],["memorypermissions"]]],[11,"extend","","",5,N],[11,"assert_receiver_is_total_eq","","",5,N],[11,"assert_receiver_is_total_eq","kfs_libuser::error","",33,N],[11,"bitand","kfs_libuser::syscalls","Returns the intersection between the two sets of flags.",5,[[["self"],["memorypermissions"]],["memorypermissions"]]],[11,"default","","",4,[[],["memoryinfo"]]],[11,"default","","",5,[[],["memorypermissions"]]],[11,"cmp","","",5,[[["self"],["memorypermissions"]],["ordering"]]],[11,"get_handle","kfs_libuser::ipc::server","",26,[[["self"]],["handleref"]]],[11,"handle_signaled","","",26,[[["self"],["waitablemanager"]],["result",["bool","error"]]]],[11,"get_handle","","",27,[[["self"]],["handleref"]]],[11,"handle_signaled","","",27,[[["self"],["waitablemanager"]],["result",["bool","error"]]]],[11,"fmt","kfs_libuser::error","",37,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_libuser::types","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",14,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_libuser::ipc","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",22,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",21,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_libuser::error","",37,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",34,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",35,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",36,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_libuser::terminal","",39,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_libuser::window","",42,[[["self"],["formatter"]],["result"]]],[11,"eq","kfs_libuser::types","",17,[[["self"],["pid"]],["bool"]]],[11,"ne","","",17,[[["self"],["pid"]],["bool"]]],[11,"eq","kfs_libuser::error","",34,[[["self"],["module"]],["bool"]]],[11,"ne","","",34,[[["self"],["module"]],["bool"]]],[11,"eq","","",35,[[["self"],["libusererror"]],["bool"]]],[11,"ne","","",35,[[["self"],["libusererror"]],["bool"]]],[11,"eq","","",36,[[["self"],["smerror"]],["bool"]]],[11,"ne","","",36,[[["self"],["smerror"]],["bool"]]],[11,"assert_receiver_is_total_eq","kfs_libuser::types","",17,N],[11,"assert_receiver_is_total_eq","kfs_libuser::error","",34,N],[11,"assert_receiver_is_total_eq","","",35,N],[11,"assert_receiver_is_total_eq","","",36,N],[11,"deref","kfs_libuser::ipc::server","",25,[[["self"]],["t"]]],[11,"deref_mut","","",25,[[["self"]],["t"]]],[11,"drop","kfs_libuser::types","",7,[[["self"]]]],[11,"drop","","",10,[[["self"]]]],[11,"drop","","",16,[[["self"]]]],[11,"index","kfs_libuser::ipc::server","",25,N],[11,"from","kfs_libuser::error","",37,[[["kernelerror"]],["self"]]],[11,"from","","",37,[[["libusererror"]],["self"]]],[11,"from","","",37,[[["smerror"]],["self"]]],[11,"write_str","kfs_libuser::terminal","",40,[[["self"],["str"]],["result",["error"]]]],[11,"clone","kfs_libuser::types","",17,[[["self"]],["pid"]]],[11,"clone","kfs_libuser::ipc","",22,[[["self"]],["ipcbuffertype"]]],[11,"clone","","",20,[[["self"]],["ipcbuffer"]]],[11,"clone","kfs_libuser::error","",34,[[["self"]],["module"]]],[11,"clone","","",35,[[["self"]],["libusererror"]]],[11,"clone","","",36,[[["self"]],["smerror"]]],[11,"clone","kfs_libuser::terminal","",39,[[["self"]],["pos"]]],[11,"clone","kfs_libuser::window","",42,[[["self"]],["color"]]],[11,"alloc","kfs_libuser::allocator","",38,N],[11,"dealloc","","",38,N],[11,"bit_range","kfs_libuser::ipc","",18,[[["self"],["usize"],["usize"]],["t"]]],[11,"set_bit_range","","",18,[[["self"],["usize"],["usize"],["t"]]]],[11,"bit_range","","",19,[[["self"],["usize"],["usize"]],["t"]]],[11,"set_bit_range","","",19,[[["self"],["usize"],["usize"],["t"]]]],[11,"name","kfs_libuser::error","",37,[[["self"]],["option",["str"]]]],[11,"cause","","",37,[[["self"]],["option",["fail"]]]],[11,"backtrace","","",37,[[["self"]],["option",["backtrace"]]]],[11,"new","kfs_libuser::io","Create a read-only wrapper around the IO device address.",1,[[["i"]],["readonly"]]],[11,"read","","Reads from this Io.",1,N],[11,"readf","","Read from this Io, and mask the value with `flags`.",1,N],[11,"new","","Creates a WriteOnly Io.",2,[[["i"]],["writeonly"]]],[11,"write","","Writes `value` to this Io.",2,N],[11,"new","","Create a PIO from a given port",3,[[["u16"]],["pio"]]],[18,"READABLE","kfs_libuser::syscalls","The area is readable.",5,N],[18,"WRITABLE","","The area is writable.",5,N],[18,"EXECUTABLE","","The area is executable.",5,N],[11,"empty","","Returns an empty set of flags.",5,[[],["memorypermissions"]]],[11,"all","","Returns the set containing all flags.",5,[[],["memorypermissions"]]],[11,"bits","","Returns the raw value of the flags currently stored.",5,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",5,[[["u32"]],["option",["memorypermissions"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",5,[[["u32"]],["memorypermissions"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",5,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",5,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",5,[[["self"],["memorypermissions"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",5,[[["self"],["memorypermissions"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",5,N],[11,"remove","","Removes the specified flags in-place.",5,N],[11,"toggle","","Toggles the specified flags in-place.",5,N],[11,"set","","Inserts or removes the specified flags depending on the…",5,N],[11,"make_ret","kfs_libuser::error","Transforms a KernelError into the encoding acceptable for…",33,[[["self"]],["usize"]]],[11,"from_syscall_ret","","Turns a syscall return value into a Kernel Error.",33,[[["u32"]],["kernelerror"]]],[11,"from_description","","Turns a kernel error description into a KernelError.",33,[[["u32"]],["kernelerror"]]],[11,"description","","Gets the underlying KernelError description.",33,[[["self"]],["u32"]]],[18,"InvalidKernelCaps","","Kernel capabilities are invalid.",33,N],[18,"NotImplemented","","This function is not implemented.",33,N],[18,"InvalidSize","","The size argument is invalid.",33,N],[18,"InvalidAddress","","The passed address is invalid.",33,N],[18,"MemoryFull","","The virtual address space was exhausted.",33,N],[18,"HandleTableFull","","The process' handle table is full.",33,N],[18,"InvalidMemPerms","","The memory permissions passed are wrong.",33,N],[18,"InvalidHandle","","Passed handle is invalid.",33,N],[18,"CopyFromUserFailed","","Attempt to copy the userspace address failed.",33,N],[18,"InvalidCombination","","The combination of argument is invalid.",33,N],[18,"Timeout","","A timeout was reached.",33,N],[18,"Canceled","","The syscall was cancelled through cancel_synchronization.",33,N],[18,"ExceedingMaximum","","A size was given exceeding the maximum allowed value.",33,N],[18,"NoSuchEntry","","The given entry does not exist.",33,N],[18,"PortRemoteDead","","The remote part of the session was closed.",33,N],[18,"ProcessAlreadyStarted","","Attempted to start a process that was already started.",33,N]],"paths":[[8,"Io"],[3,"ReadOnly"],[3,"WriteOnly"],[3,"Pio"],[3,"MemoryInfo"],[3,"MemoryPermissions"],[3,"Registers"],[3,"Handle"],[3,"HandleRef"],[3,"ReadableEvent"],[3,"ClientSession"],[3,"ServerSession"],[3,"ClientPort"],[3,"ServerPort"],[3,"Thread"],[3,"SharedMemory"],[3,"MappedSharedMemory"],[3,"Pid"],[3,"MsgPackedHdr"],[3,"HandleDescriptorHeader"],[3,"IPCBuffer"],[3,"Message"],[4,"IPCBufferType"],[4,"MessageTy"],[3,"WaitableManager"],[3,"Align16"],[3,"SessionWrapper"],[3,"PortHandler"],[8,"IWaitable"],[8,"Object"],[3,"IUserInterface"],[3,"ViInterface"],[3,"IBuffer"],[3,"KernelError"],[3,"Module"],[3,"LibuserError"],[3,"SmError"],[4,"Error"],[3,"Allocator"],[3,"Pos"],[3,"Terminal"],[4,"WindowSize"],[3,"Color"],[3,"Window"],[8,"Termination"]]};
searchIndex["kfs_libutils"]={"doc":"A messy crate with various utilities shared between the…","items":[[3,"CursorWrite","kfs_libutils","A minimal Cursor for writing, for use in libcore.",N,N],[12,"data","","",0,N],[12,"pos","","",0,N],[3,"CursorRead","","A minimal Cursor for writing, for use in libcore.",N,N],[12,"data","","",1,N],[12,"pos","","",1,N],[5,"align_up","","Align the address to the next alignment.",N,[[["t"],["t"]],["t"]]],[5,"align_down","","Align the address to the previous alignment.",N,[[["t"],["t"]],["t"]]],[5,"align_up_checked","","align_up, but checks if addr overflows",N,[[["usize"],["usize"]],["option",["usize"]]]],[5,"div_ceil","","Counts the numbers of `b` in `a`, rounding the result up.",N,[[["t"],["t"]],["t"]]],[5,"print_hexdump","","Displays memory as hexdump",N,N],[5,"print_hexdump_as_if_at_addr","","Makes a hexdump of a slice, but display different…",N,N],[5,"bit_array_first_zero","","Returns the index of the first 0 in a bit array.",N,N],[5,"bit_array_first_one","","Returns the index of the first 1 in a bit array.",N,N],[5,"bit_array_first_count_one","","Returns the index of the first instance of count…",N,N],[0,"io","","The IO interface",N,N],[3,"ReadOnly","kfs_libutils::io","A read-only wrapper around an IO device.",N,N],[12,"inner","","",2,N],[3,"WriteOnly","","An Io that we can only write to.",N,N],[12,"inner","","",3,N],[3,"Pio","","Port IO accessor.",N,N],[12,"port","","",4,N],[12,"value","","",4,N],[8,"Io","","The Io trait allows for accessing device IO in a generic…",N,N],[16,"Value","","The width of the IO access. Should be a primitive type…",5,N],[10,"read","","Reads from this Io.",5,N],[10,"write","","Writes `value` to this Io.",5,N],[11,"readf","","Read from this Io, and mask the value with `flags`.",5,N],[11,"writef","","Mask `value` with `flags`, and write it to this device…",5,N],[11,"new","","Create a read-only wrapper around the IO device address.",2,[[["i"]],["readonly"]]],[11,"read","","Reads from this Io.",2,N],[11,"readf","","Read from this Io, and mask the value with `flags`.",2,N],[11,"new","","Creates a WriteOnly Io.",3,[[["i"]],["writeonly"]]],[11,"write","","Writes `value` to this Io.",3,N],[11,"new","","Create a PIO from a given port",4,[[["u16"]],["self"]]],[0,"cursor","kfs_libutils","",N,N],[3,"CursorWrite","kfs_libutils::cursor","A minimal Cursor for writing, for use in libcore.",N,N],[12,"data","","",0,N],[12,"pos","","",0,N],[3,"CursorRead","","A minimal Cursor for writing, for use in libcore.",N,N],[12,"data","","",1,N],[12,"pos","","",1,N],[11,"new","kfs_libutils","Creates a new cursor wrapping the provided underlying…",0,N],[11,"pos","","Returns the current position of this cursor.",0,[[["self"]],["usize"]]],[11,"skip_write","","Skip the given amount of bytes, returning a mutable slice…",0,N],[11,"write_u8","","Writes an u8 in the given byte ordering.",0,[[["self"],["u8"]]]],[11,"write_u16","","Writes a u16 in the given byte ordering.",0,[[["self"],["u16"]]]],[11,"write_u32","","Writes a u32 in the given byte ordering.",0,[[["self"],["u32"]]]],[11,"write_u64","","Writes a u64 in the given byte ordering.",0,[[["self"],["u64"]]]],[11,"write","","Writes the given byte slice entirely.",0,N],[11,"write_raw","","Writes the given structure.",0,[[["self"],["t"]]]],[11,"new","","Creates a new cursor wrapping the provided underlying…",1,N],[11,"pos","","Returns the current position of this cursor.",1,[[["self"]],["usize"]]],[11,"read_u8","","Reads an u8 in the given byteorder.",1,[[["self"]],["u8"]]],[11,"read_u16","","Reads an u16 in the given byteorder.",1,[[["self"]],["u16"]]],[11,"read_u32","","Reads an u32 in the given byteorder.",1,[[["self"]],["u32"]]],[11,"read_u64","","Reads an u64 in the given byteorder.",1,[[["self"]],["u64"]]],[11,"assert","","Reads `v.len()` bytes from the stream, and asserts that it…",1,N],[11,"skip_read","","Skips `bytelen` bytes, returning a slice to them for…",1,N],[11,"read_raw","","Reads the given structure from the bytestream.",1,[[["self"]],["t"]]],[8,"BitArrayExt","","Extension of the [BitField] trait, that adds the…",N,N],[11,"set_bits_area","","Sets a range of bits to `value` in the BitField.",6,[[["self"],["range",["usize"]],["bool"]]]],[14,"enum_with_val","","Creates a fake C-like enum, where all bit values are…",N,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"from","kfs_libutils::io","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"read","","Read",4,[[["self"]],["u8"]]],[11,"write","","Write",4,[[["self"],["u8"]]]],[11,"read","","Read",4,[[["self"]],["u16"]]],[11,"write","","Write",4,[[["self"],["u16"]]]],[11,"read","","Read",4,[[["self"]],["u32"]]],[11,"write","","Write",4,[[["self"],["u32"]]]],[11,"clone","","",4,[[["self"]],["pio"]]]],"paths":[[3,"CursorWrite"],[3,"CursorRead"],[3,"ReadOnly"],[3,"WriteOnly"],[3,"Pio"],[8,"Io"],[8,"BitArrayExt"]]};
searchIndex["kfs_shell"]={"doc":"Shell","items":[[5,"main","kfs_shell","",N,[[]]],[5,"show_gif","","",N,N],[5,"test_divide_by_zero","","",N,[[]]],[5,"test_page_fault","","",N,[[]]],[0,"ps2","","",N,N],[3,"PS2","kfs_shell::ps2","",N,N],[12,"status_port","","",0,N],[12,"data_port","","",0,N],[12,"event","","",0,N],[12,"is_capslocked","","",0,N],[12,"is_shift","","",0,N],[3,"LetterKey","","A non-control key (lowercase_ascii, uppercase_ascii)",N,N],[12,"lower_case","","",1,N],[12,"upper_case","","",1,N],[3,"ControlKey","","A control key (ctrl, shift, alt, arrows, end, ...)",N,N],[12,"0","","",2,N],[3,"KeyEvent","","A KeyEvent is the combination of a key and its state",N,N],[12,"key","","",3,N],[12,"state","","",3,N],[3,"PRIMARY_PS2","","",N,N],[12,"__private_field","","",4,N],[4,"Key","","A key is either a letter key, a control key, or not…",N,N],[13,"Letter","","",5,N],[13,"Control","","",5,N],[13,"Empty","","",5,N],[4,"State","","",N,N],[13,"Pressed","","",6,N],[13,"Released","","",6,N],[5,"read_key","","",N,[[],["char"]]],[5,"try_read_key","","",N,[[],["option",["char"]]]],[5,"get_next_line","","",N,[[["terminal"]],["string"]]],[5,"get_waitable","","",N,[[],["readableevent"]]],[7,"PRIMARY_PS2","","",N,N],[11,"ctrl","","",5,[[["str"]],["key"]]],[11,"letter","","",5,[[["char"],["char"]],["key"]]],[11,"read_key_event","","Reads one or more bytes from the port until it matches a…",3,[[["pio"]],["keyevent"]]],[11,"handle_control_key","","Handle a control key scancode",0,[[["self"],["controlkey"],["state"]]]],[11,"key_to_letter","","Gets the letter from the key, accounting for shift and…",0,[[["self"],["letterkey"]],["char"]]],[11,"read_key","","",0,[[["self"]],["char"]]],[11,"try_read_key","","",0,[[["self"]],["option",["char"]]]],[11,"event_irq","","",0,[[["self"]],["readableevent"]]],[7,"LOUIS3","kfs_shell","",N,N],[7,"LOUIS4","","",N,N],[7,"IOPORTS_PERMS","","Array of IO port this process is allowed to access.",N,N],[11,"from","kfs_shell::ps2","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"from","","",6,[[["t"]],["t"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"deref","","",4,[[["self"]],["ps2"]]],[11,"clone","","",1,[[["self"]],["letterkey"]]],[11,"clone","","",2,[[["self"]],["controlkey"]]],[11,"clone","","",5,[[["self"]],["key"]]],[11,"initialize","","",4,[[["self"]]]]],"paths":[[3,"PS2"],[3,"LetterKey"],[3,"ControlKey"],[3,"KeyEvent"],[3,"PRIMARY_PS2"],[4,"Key"],[4,"State"]]};
searchIndex["kfs_sm"]={"doc":"Service Manager","items":[[3,"UserInterface","kfs_sm","",N,N],[3,"SERVICES","","",N,N],[12,"__private_field","","",0,N],[5,"get_service_length","","",N,[[["u64"]],["usize"]]],[5,"get_service_str","","",N,[[["u64"]],["str"]]],[5,"main","","",N,[[]]],[7,"SERVICES","","",N,N],[11,"initialize","","",1,[[["self"],["pid"]],["result",["error"]]]],[11,"get_service","","",1,[[["self"],["u64"]],["result",["error"]]]],[11,"register_service","","",1,[[["self"],["u64"],["u8"],["u32"]],["result",["error"]]]],[11,"unregister_service","","",1,[[["self"],["u64"]],["result",["error"]]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"deref","","",0,[[["self"]],["mutex"]]],[11,"default","","",1,[[],["userinterface"]]],[11,"dispatch","","",1,N],[11,"initialize","","",0,[[["self"]]]]],"paths":[[3,"SERVICES"],[3,"UserInterface"]]};
searchIndex["kfs_vi"]={"doc":"Visual Compositor","items":[[3,"ViInterface","kfs_vi","Entry point interface.",N,N],[3,"Buffer","","Internal representation of a window.",N,N],[12,"top","","",0,N],[12,"left","","",0,N],[12,"width","","",0,N],[12,"height","","",0,N],[12,"mem","","",0,N],[3,"IBuffer","","IPC Window object",N,N],[12,"buffer","","",1,N],[5,"get_intersect","","Gets the intersection between two rectangles.",N,N],[5,"draw","","Draw a portion of a buffer onto the framebuffer.",N,[[["buffer"],["framebuffer"],["u32"],["u32"],["u32"],["u32"]]]],[5,"get_real_bounds","","See Buffer::get_real_bounds.",N,N],[5,"main","","",N,[[]]],[0,"vbe","","VESA Bios Extensions Framebuffer",N,N],[3,"VBEColor","kfs_vi::vbe","A rgb color",N,N],[12,"b","","",2,N],[12,"g","","",2,N],[12,"r","","",2,N],[12,"a","","",2,N],[3,"Framebuffer","","",N,N],[12,"buf","","",3,N],[12,"width","","",3,N],[12,"height","","",3,N],[12,"bpp","","",3,N],[3,"FRAMEBUFFER","","",N,N],[12,"__private_field","","",4,N],[7,"FRAMEBUFFER","","",N,N],[11,"rgb","","",2,[[["u8"],["u8"],["u8"]],["vbecolor"]]],[11,"new","","Creates an instance of the linear framebuffer.",3,[[],["result",["framebuffer","error"]]]],[11,"new_buffer","","Creates a backbuffer backed by an in-memory array.",3,N],[11,"width","","framebuffer width in pixels. Does not account for bpp",3,[[["self"]],["usize"]]],[11,"height","","framebuffer height in pixels. Does not account for bpp",3,[[["self"]],["usize"]]],[11,"bpp","","The number of bits that forms a pixel. Used to compute…",3,[[["self"]],["usize"]]],[11,"get_px_offset","","Gets the offset in memory of a pixel based on an x and y.",3,[[["self"],["usize"],["usize"]],["usize"]]],[11,"write_px","","Writes a pixel in the framebuffer respecting the bgr pattern",3,[[["self"],["usize"],["vbecolor"]]]],[11,"write_px_at","","Writes a pixel in the framebuffer respecting the bgr…",3,[[["self"],["usize"],["usize"],["vbecolor"]]]],[11,"get_fb","","Gets the underlying framebuffer",3,N],[11,"clear","","Clears the whole screen",3,[[["self"]]]],[11,"clear_at","","Clears a segment of the screen.",3,[[["self"],["usize"],["usize"],["usize"],["usize"]]]],[7,"BUFFERS","kfs_vi","A list of the buffers currently alive.",N,N],[7,"BACKBUFFER_ARR","","The backbuffer to draw into.",N,N],[11,"create_buffer","","Create a window.",5,[[["self"],["waitablemanager"],["handle"],["i32"],["i32"],["u32"],["u32"]],["result",["error"]]]],[11,"get_resolution","","Gets the screen resolution.",5,[[["self"]],["result",["error"]]]],[11,"get_real_bounds","","Returns the buffer's bounds within the given width/height,…",0,N],[11,"draw","","Blit the buffer to the framebuffer.",1,[[["self"]],["result",["error"]]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"from","kfs_vi::vbe","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_vi","",0,[[["self"],["formatter"]],["result"]]],[11,"deref","kfs_vi::vbe","",4,[[["self"]],["mutex"]]],[11,"drop","kfs_vi","Redraw the zone where the buffer was when dropping it, to…",1,[[["self"]]]],[11,"clone","kfs_vi::vbe","",2,[[["self"]],["vbecolor"]]],[11,"default","kfs_vi","",5,[[],["viinterface"]]],[11,"dispatch","","",5,N],[11,"dispatch","","",1,N],[11,"initialize","kfs_vi::vbe","",4,[[["self"]]]]],"paths":[[3,"Buffer"],[3,"IBuffer"],[3,"VBEColor"],[3,"Framebuffer"],[3,"FRAMEBUFFER"],[3,"ViInterface"]]};
initSearch(searchIndex);addSearchOptions(searchIndex);
