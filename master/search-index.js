var N = null;var searchIndex = {};
searchIndex["kfs_ahci"]={"doc":"","items":[[5,"main","kfs_ahci","",N,[[]]],[0,"pci","","PCI discovery",N,N],[3,"PciConfigPortsPair","kfs_ahci::pci","A struct tying the two pci config ports together.",N,N],[12,"address","","",0,N],[12,"data","","",0,N],[3,"PciDevice","","A pci device, addressed by its bus number, slot, and…",N,N],[12,"bus","","The device's bus number.",1,N],[12,"slot","","The device's slot number on its bus.",1,N],[12,"function","","The device's function number.",1,N],[12,"did","","Device id.",1,N],[12,"vid","","Vendor id.",1,N],[12,"class","","",1,N],[12,"subclass","","",1,N],[12,"prog_if","","",1,N],[12,"rev_id","","",1,N],[12,"header_type","","",1,N],[12,"latency_timer","","",1,N],[12,"cache_line_size","","",1,N],[12,"header","","Remaining registers values, based on header type.",1,N],[3,"PciHeader00","","Pci header when Header Type == 0x00 (General device).",N,N],[12,"bar0","","",2,N],[12,"bar1","","",2,N],[12,"bar2","","",2,N],[12,"bar3","","",2,N],[12,"bar4","","",2,N],[12,"bar5","","",2,N],[12,"cardbus_cis_ptr","","",2,N],[12,"subsystem_id","","",2,N],[12,"subsystem_vendor_id","","",2,N],[12,"expansion_rom_base_address","","",2,N],[12,"capabilities_ptr","","",2,N],[12,"max_latency","","",2,N],[12,"min_grant","","",2,N],[12,"interrupt_pin","","",2,N],[12,"interrupt_line","","",2,N],[4,"PciHeader","","Contents of pci config registers 0x4-0xf, structure varies…",N,N],[13,"GeneralDevice","","",3,N],[13,"PCItoPCIBridge","","",3,N],[13,"CardBus","","",3,N],[13,"UnknownHeaderType","","",3,N],[4,"BAR","","Base Address Registers. Minimal implementation, does not…",N,N],[13,"Memory","","",4,N],[13,"Io","","",4,N],[5,"pci_config_read_word","","Read one of the 64 32-bit registers of a pci…",N,[[["u8"],["u8"],["u8"],["u8"]],["u32"]]],[5,"pci_config_write_word","","Read one of the 64 32-bit registers of a pci…",N,[[["u8"],["u8"],["u8"],["u8"],["u32"]]]],[5,"discover","","Discover all pci devices, by probing the PID-VID of every…",N,[[],["vec",["pcidevice"]]]],[5,"get_ahci_controllers","","Gets the ahci controllers found by pci discovery.",N,[[],["vec"]]],[7,"PCI_CONFIG_PORTS","","A mutex around the two ports used to address pci…",N,N],[17,"CONFIG_ADDRESS","","The CONFIG_ADDRESS I/O location.",N,N],[17,"CONFIG_DATA","","The CONFIG_DATA I/O location.",N,N],[17,"MAX_BUS","","The highest addressable bus.",N,N],[17,"MAX_SLOT","","The highest addressable slot on a bus.",N,N],[17,"MAX_FUNC","","The highest addressable function on a slot on a bus.",N,N],[17,"MAX_REGISTER","","The highest addressable register on a function on a slot…",N,N],[11,"probe","","Checks if a device exists on given bus>slot>function.",1,[[["u8"],["u8"],["u8"]],["option"]]],[11,"read_config_register","","Reads a configuration space register.",1,[[["self"],["u8"]],["u32"]]],[11,"write_config_register","","Writes to a configuration space register.",1,[[["self"],["u8"],["u32"]]]],[11,"status","","Reads the status register.",1,[[["self"]],["u16"]]],[11,"command","","Reads the command register.",1,[[["self"]],["u16"]]],[7,"CAPABILITIES","kfs_ahci","",N,N],[11,"from","kfs_ahci::pci","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"clone","","",1,[[["self"]],["pcidevice"]]],[11,"clone","","",2,[[["self"]],["pciheader00"]]],[11,"clone","","",3,[[["self"]],["pciheader"]]],[11,"clone","","",4,[[["self"]],["bar"]]]],"paths":[[3,"PciConfigPortsPair"],[3,"PciDevice"],[3,"PciHeader00"],[4,"PciHeader"],[4,"BAR"]]};
searchIndex["kfs_bootstrap"]={"doc":"Bootstrap stage","items":[[3,"AlignedStack","kfs_bootstrap","4 pages, PAGE_SIZE aligned.",N,N],[12,"0","","",0,N],[3,"EndTag","","",N,N],[12,"tag","","",1,N],[12,"flag","","",1,N],[12,"size","","",1,N],[3,"FramebufferTag","","",N,N],[12,"tag","","",2,N],[12,"flags","","",2,N],[12,"size","","",2,N],[12,"width","","",2,N],[12,"height","","",2,N],[12,"depth","","",2,N],[3,"ModuleAlignmentTag","","",N,N],[12,"tag","","",3,N],[12,"flags","","",3,N],[12,"size","","",3,N],[3,"MultiBootHeader","","The multiboot header structure of our binary.",N,N],[12,"magic","","",4,N],[12,"architecture","","",4,N],[12,"header_length","","",4,N],[12,"checksum","","",4,N],[12,"framebuffer","","",4,N],[12,"end","","",4,N],[5,"print_stack","","Prints raw hexdump of the stack. Use this if everything…",N,[[]]],[5,"bootstrap_start","","The very start.",N,N],[5,"do_bootstrap","","bootstrap stage and call kernel",N,N],[5,"eh_personality","","The exception handling personality function for use in the…",N,[[]]],[5,"panic_fmt","","The bootstrap panic function.",N,N],[0,"bootstrap_logging","","bootstrap logging on rs232",N,N],[3,"Serial","kfs_bootstrap::bootstrap_logging","A logger that sends its output to COM1.",N,N],[5,"init_bootstrap_log","","Init the rs232 COM1. Must be called before logging anything.",N,[[]]],[5,"bootstrap_log","","Sends a string to COM1.",N,[[["str"]]]],[5,"bootstrap_inb","","",N,[[["u16"]],["u8"]]],[5,"bootstrap_outb","","",N,[[["u16"],["u8"]]]],[17,"COM1","","",N,N],[0,"gdt","kfs_bootstrap","GDT Handler",N,N],[3,"MAIN_TASK","kfs_bootstrap::gdt","",N,N],[12,"__private_field","","",5,N],[3,"FAULT_TASK","","",N,N],[12,"__private_field","","",6,N],[3,"DescriptorTable","","A structure containing our GDT. We can have at most 16…",N,N],[12,"table","","",7,N],[3,"DescriptorTableEntry","","",N,N],[12,"0","","",8,N],[4,"SystemDescriptorTypes","","",N,N],[13,"AvailableTss16","","",9,N],[13,"Ldt","","",9,N],[13,"BusyTss16","","",9,N],[13,"CallGate16","","",9,N],[13,"TaskGate","","",9,N],[13,"InterruptGate16","","",9,N],[13,"TrapGate16","","",9,N],[13,"AvailableTss32","","",9,N],[13,"BusyTss32","","",9,N],[13,"CallGate32","","",9,N],[13,"InterruptGate32","","",9,N],[13,"TrapGate32","","",9,N],[5,"init_gdt","","",N,[[]]],[0,"segment_selector","","Types for the Global Descriptor Table and segment selectors.",N,N],[3,"SegmentSelector","kfs_bootstrap::gdt::segment_selector","Specifies which element to load into a segment from…",N,N],[12,"0","","",10,N],[11,"new","","Creates a new SegmentSelector",10,[[["u16"],["privilegelevel"]],["segmentselector"]]],[11,"index","","Returns the GDT index.",10,[[["self"]],["u16"]]],[11,"rpl","","Returns the requested privilege level.",10,[[["self"]],["privilegelevel"]]],[0,"i386","kfs_bootstrap::gdt","This crate is x86_64's little brother. It provides i386…",N,N],[3,"TssStruct","kfs_bootstrap::gdt::i386","The Task State Segment (TSS) is a special data structure…",N,N],[12,"_reserved1","","",11,N],[12,"link","","",11,N],[12,"esp0","","",11,N],[12,"_reserved2","","",11,N],[12,"ss0","","",11,N],[12,"esp1","","",11,N],[12,"_reserved3","","",11,N],[12,"ss1","","",11,N],[12,"esp2","","",11,N],[12,"_reserved4","","",11,N],[12,"ss2","","",11,N],[12,"cr3","","",11,N],[12,"eip","","",11,N],[12,"eflags","","",11,N],[12,"eax","","",11,N],[12,"ecx","","",11,N],[12,"edx","","",11,N],[12,"ebx","","",11,N],[12,"esp","","",11,N],[12,"ebp","","",11,N],[12,"esi","","",11,N],[12,"edi","","",11,N],[12,"_reserved5","","",11,N],[12,"es","","",11,N],[12,"_reserved6","","",11,N],[12,"cs","","",11,N],[12,"_reserved7","","",11,N],[12,"ss","","",11,N],[12,"_reserved8","","",11,N],[12,"ds","","",11,N],[12,"_reserved9","","",11,N],[12,"fs","","",11,N],[12,"_reserveda","","",11,N],[12,"gs","","",11,N],[12,"_reservedb","","",11,N],[12,"ldt_selector","","",11,N],[12,"iopboffset","","",11,N],[12,"_reservedc","","",11,N],[4,"PrivilegeLevel","","Represents a protection ring level.",N,N],[13,"Ring0","","Privilege-level 0 (most privilege): This level is used by…",12,N],[13,"Ring1","","Privilege-level 1 (moderate privilege): This level is used…",12,N],[13,"Ring2","","Privilege-level 2 (moderate privilege): Like level 1, this…",12,N],[13,"Ring3","","Privilege-level 3 (least privilege): This level is used by…",12,N],[0,"instructions","","Low level functions for special i386 instructions.",N,N],[0,"tables","kfs_bootstrap::gdt::i386::instructions","Instructions for loading descriptor tables (GDT, IDT, etc.).",N,N],[3,"DescriptorTablePointer","kfs_bootstrap::gdt::i386::instructions::tables","A struct describing a pointer to a descriptor table (GDT /…",N,N],[12,"limit","","Size of the DT.",13,N],[12,"base","","Pointer to the memory region containing the DT.",13,N],[5,"lgdt","","Load GDT table.",N,[[["descriptortablepointer"]]]],[5,"lldt","","Load LDT table.",N,[[["segmentselector"]]]],[5,"ltr","","Sets the task register to the given TSS segment.",N,[[["segmentselector"]]]],[5,"lidt","","Load IDT table.",N,[[["descriptortablepointer"]]]],[0,"segmentation","kfs_bootstrap::gdt::i386::instructions","Provides functions to read and write segment registers.",N,N],[5,"set_cs","kfs_bootstrap::gdt::i386::instructions::segmentation","Reload code segment register. Note this is special since…",N,[[["segmentselector"]]]],[5,"load_ss","","Reload stack segment register.",N,[[["segmentselector"]]]],[5,"load_ds","","Reload data segment register.",N,[[["segmentselector"]]]],[5,"load_es","","Reload es segment register.",N,[[["segmentselector"]]]],[5,"load_fs","","Reload fs segment register.",N,[[["segmentselector"]]]],[5,"load_gs","","Reload gs segment register.",N,[[["segmentselector"]]]],[5,"cs","","Returns the current value of the code segment register.",N,[[],["segmentselector"]]],[0,"interrupts","kfs_bootstrap::gdt::i386::instructions","Interrupt disabling functionality.",N,N],[5,"sti","kfs_bootstrap::gdt::i386::instructions::interrupts","Enable interrupts",N,[[]]],[5,"cli","","Disable interrupts",N,[[]]],[11,"from_u16","kfs_bootstrap::gdt::i386","Creates a `PrivilegeLevel` from a numeric value. The value…",12,[[["u16"]],["privilegelevel"]]],[11,"new","","",11,N],[7,"GDT","kfs_bootstrap::gdt","",N,N],[7,"GLOBAL_LDT","","The global LDT used by all the processes.",N,N],[7,"MAIN_TASK","","",N,N],[7,"FAULT_TASK","","",N,N],[11,"new","","",7,[[],["descriptortable"]]],[11,"push","","",7,[[["self"],["descriptortableentry"]]]],[11,"load_global","","",7,[[["self"],["u16"],["u16"],["u16"]]]],[11,"null_descriptor","","",8,[[],["descriptortableentry"]]],[11,"new","","Creates an empty GDT descriptor, but with some flags set…",8,[[["u32"],["u32"],["bool"],["privilegelevel"]],["descriptortableentry"]]],[11,"new_system","","Creates an empty GDT descriptor, but with some flags set…",8,[[["systemdescriptortypes"],["u32"],["u32"],["privilegelevel"]],["descriptortableentry"]]],[11,"new_ldt","","Creates a new LDT descriptor.",8,[[["descriptortable"],["privilegelevel"]],["descriptortableentry"]]],[11,"new_tss","","Creates a GDT descriptor pointing to a TSS segment",8,[[["tssstruct"],["privilegelevel"]],["descriptortableentry"]]],[11,"get_limit","","",8,[[["self"]],["u32"]]],[11,"set_limit","","",8,[[["self"],["u32"]]]],[11,"get_base","","",8,[[["self"]],["u32"]]],[11,"set_base","","",8,[[["self"],["u32"]]]],[11,"get_accessed","","",8,[[["self"]],["bool"]]],[11,"is_readwrite_allowed","","",8,[[["self"]],["bool"]]],[11,"is_comformant","","",8,[[["self"]],["bool"]]],[11,"is_executable","","",8,[[["self"]],["bool"]]],[11,"get_ring_level","","",8,[[["self"]],["privilegelevel"]]],[11,"get_present","","",8,[[["self"]],["bool"]]],[11,"is_4k_granularity","","",8,[[["self"]],["bool"]]],[11,"set_4k_granularity","","",8,[[["self"],["bool"]]]],[11,"is_32bit","","",8,[[["self"]],["bool"]]],[0,"address","kfs_bootstrap","Physical and Virtual address wrappers",N,N],[3,"PhysicalAddress","kfs_bootstrap::address","Represents a Physical address",N,N],[12,"0","","",14,N],[3,"VirtualAddress","","Represents a Virtual address",N,N],[12,"0","","",15,N],[11,"addr","","Gets the address as a `usize`.",15,[[["self"]],["usize"]]],[11,"addr","","Gets the address as a `usize`.",14,[[["self"]],["usize"]]],[11,"floor","","Rounds down to PAGE_SIZE.",14,[[["self"]],["physicaladdress"]]],[11,"ceil","","Rounds up PAGE_SIZE.",14,[[["self"]],["physicaladdress"]]],[11,"floor","","Rounds down to PAGE_SIZE.",15,[[["self"]],["virtualaddress"]]],[11,"ceil","","Rounds up PAGE_SIZE.",15,[[["self"]],["virtualaddress"]]],[0,"paging","kfs_bootstrap","Paging on i386",N,N],[3,"ActivePageTables","kfs_bootstrap::paging","The page tables set currently in use.",N,N],[3,"InactivePageTables","","A set of PageTables that are not the ones currently in…",N,N],[12,"directory_physical_address","","",16,N],[3,"PagingOffPageSet","","Used at startup when paging is off to create and…",N,N],[12,"directory_physical_address","","",17,N],[3,"EntryFlags","","The flags of a table entry",N,N],[12,"bits","","",18,N],[3,"KernelLand","","The virtual memory belonging to kernel.",N,N],[3,"UserLand","","The virtual memory belonging to user.",N,N],[4,"MappingType","","The type of a Virtual Memory mapping. Can either be…",N,N],[13,"Present","","",19,N],[13,"Guard","","",19,N],[5,"is_paging_on","","Check if the paging is currently active.",N,[[],["bool"]]],[5,"enable_paging","","",N,[[["physicaladdress"]]]],[5,"flush_tlb","","Flush the Translation Lookaside Buffer…",N,[[]]],[5,"swap_cr3","","Changes the content of the cr3 register, and returns the…",N,[[["physicaladdress"]],["physicaladdress"]]],[5,"map_bootstrap","","Creates a set of page tables identity mapping the Bootstrap.",N,[[["bootinformation"]],["pagingoffpageset"]]],[5,"__land_assertions","","",N,[[]]],[5,"get_page","","Creates a mapping in the page tables with the given flags.…",N,[[],["virtualaddress"]]],[0,"entry","","i386 page table entry",N,N],[3,"EntryFlags","kfs_bootstrap::paging::entry","The flags of a table entry",N,N],[12,"bits","","",20,N],[3,"Entry","","An entry in a page table or page directory. An unused…",N,N],[12,"0","","",21,N],[4,"PageState","","Represent the current state of this Page Table Entry: It…",N,N],[13,"Available","","",22,N],[13,"Guarded","","",22,N],[13,"Present","","",22,N],[17,"ENTRY_PHYS_ADDRESS_MASK","","",N,N],[18,"PRESENT","","",20,N],[18,"WRITABLE","","",20,N],[18,"USER_ACCESSIBLE","","",20,N],[18,"WRITE_THROUGH","","",20,N],[18,"NO_CACHE","","",20,N],[18,"ACCESSED","","",20,N],[18,"DIRTY","","",20,N],[18,"HUGE_PAGE","","",20,N],[18,"GLOBAL","","",20,N],[18,"GUARD_PAGE","","",20,N],[18,"IS_FRAME_ALLOC","","",20,N],[18,"USER_DEFINED_3","","",20,N],[11,"empty","","Returns an empty set of flags.",20,[[],["entryflags"]]],[11,"all","","Returns the set containing all flags.",20,[[],["entryflags"]]],[11,"bits","","Returns the raw value of the flags currently stored.",20,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",20,[[["u32"]],["option",["entryflags"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",20,[[["u32"]],["entryflags"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",20,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",20,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",20,[[["self"],["entryflags"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",20,[[["self"],["entryflags"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",20,[[["self"],["entryflags"]]]],[11,"remove","","Removes the specified flags in-place.",20,[[["self"],["entryflags"]]]],[11,"toggle","","Toggles the specified flags in-place.",20,[[["self"],["entryflags"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",20,[[["self"],["entryflags"],["bool"]]]],[11,"is_unused","","Is the entry unused ?",21,[[["self"]],["bool"]]],[11,"set_unused","","Clear the entry",21,[[["self"]],["pagestate",["frame"]]]],[11,"is_guard","","Is the entry a page guard ?",21,[[["self"]],["bool"]]],[11,"flags","","Get the current entry flags",21,[[["self"]],["entryflags"]]],[11,"pointed_frame","","Get the associated physical address, if available",21,[[["self"]],["pagestate",["physicaladdress"]]]],[11,"set","","Sets the entry",21,[[["self"],["frame"],["entryflags"]]]],[11,"set_guard","","Make this entry a page guard",21,[[["self"]]]],[11,"unwrap","","Move the value T out of the PageState if it is Present(T).",22,[[["self"]],["t"]]],[11,"map","","Maps a PageState to PageState by applying a function to a…",22,[[["self"],["f"]],["pagestate"]]],[11,"as_option","","Turns the PageState into an Option, setting both Guarded…",22,[[["self"]],["option"]]],[0,"table","kfs_bootstrap::paging","i386 page table / directory",N,N],[3,"PageTable","kfs_bootstrap::paging::table","A page table",N,N],[12,"entries","","",23,N],[3,"PageDirectory","","A page directory",N,N],[12,"0","","",24,N],[3,"EntryFlags","","The flags of a table entry",N,N],[12,"bits","","",18,N],[3,"ActivePageTables","","The page tables set currently in use.",N,N],[3,"ActivePageDirectory","","The page directory currently in use.",N,N],[12,"0","","",25,N],[3,"ActivePageTable","","A page table currently in use.",N,N],[12,"0","","",26,N],[3,"SmartHierarchicalTable","","This is just a wrapper for a pointer to a Table or a…",N,N],[12,"0","","",27,N],[12,"1","","",27,N],[3,"InactivePageTables","","A set of PageTables that are not the ones currently in…",N,N],[12,"directory_physical_address","","",16,N],[3,"InactivePageDirectory","","A temporary mapped page directory.",N,N],[12,"0","","",28,N],[3,"InactivePageTable","","A temporary mapped page table.",N,N],[12,"0","","",29,N],[3,"PagingOffPageSet","","Used at startup when paging is off to create and…",N,N],[12,"directory_physical_address","","",17,N],[3,"PagingOffDirectory","","A directory we can modify by directly accessing physical…",N,N],[12,"0","","",30,N],[3,"PagingOffTable","","A table we can modify by directly accessing physical…",N,N],[12,"0","","",31,N],[3,"TlbFlush","","When passing this struct the TLB will be flushed. Used by…",N,N],[3,"NoFlush","","When passing this struct the TLB will not be flushed. Used…",N,N],[4,"MappingType","","The type of a Virtual Memory mapping. Can either be…",N,N],[13,"Present","","",19,N],[13,"Guard","","",19,N],[5,"__assertions","","",N,[[]]],[0,"entry","","i386 page table entry",N,N],[3,"EntryFlags","kfs_bootstrap::paging::table::entry","The flags of a table entry",N,N],[12,"bits","","",32,N],[3,"Entry","","An entry in a page table or page directory. An unused…",N,N],[12,"0","","",33,N],[4,"PageState","","Represent the current state of this Page Table Entry: It…",N,N],[13,"Available","","",34,N],[13,"Guarded","","",34,N],[13,"Present","","",34,N],[17,"ENTRY_PHYS_ADDRESS_MASK","","",N,N],[18,"PRESENT","","",32,N],[18,"WRITABLE","","",32,N],[18,"USER_ACCESSIBLE","","",32,N],[18,"WRITE_THROUGH","","",32,N],[18,"NO_CACHE","","",32,N],[18,"ACCESSED","","",32,N],[18,"DIRTY","","",32,N],[18,"HUGE_PAGE","","",32,N],[18,"GLOBAL","","",32,N],[18,"GUARD_PAGE","","",32,N],[18,"IS_FRAME_ALLOC","","",32,N],[18,"USER_DEFINED_3","","",32,N],[11,"empty","","Returns an empty set of flags.",32,[[],["entryflags"]]],[11,"all","","Returns the set containing all flags.",32,[[],["entryflags"]]],[11,"bits","","Returns the raw value of the flags currently stored.",32,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",32,[[["u32"]],["option",["entryflags"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",32,[[["u32"]],["entryflags"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",32,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",32,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",32,[[["self"],["entryflags"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",32,[[["self"],["entryflags"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",32,[[["self"],["entryflags"]]]],[11,"remove","","Removes the specified flags in-place.",32,[[["self"],["entryflags"]]]],[11,"toggle","","Toggles the specified flags in-place.",32,[[["self"],["entryflags"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",32,[[["self"],["entryflags"],["bool"]]]],[11,"is_unused","","Is the entry unused ?",33,[[["self"]],["bool"]]],[11,"set_unused","","Clear the entry",33,[[["self"]],["pagestate",["frame"]]]],[11,"is_guard","","Is the entry a page guard ?",33,[[["self"]],["bool"]]],[11,"flags","","Get the current entry flags",33,[[["self"]],["entryflags"]]],[11,"pointed_frame","","Get the associated physical address, if available",33,[[["self"]],["pagestate",["physicaladdress"]]]],[11,"set","","Sets the entry",33,[[["self"],["frame"],["entryflags"]]]],[11,"set_guard","","Make this entry a page guard",33,[[["self"]]]],[11,"unwrap","","Move the value T out of the PageState if it is Present(T).",34,[[["self"]],["t"]]],[11,"map","","Maps a PageState to PageState by applying a function to a…",34,[[["self"],["f"]],["pagestate"]]],[11,"as_option","","Turns the PageState into an Option, setting both Guarded…",34,[[["self"]],["option"]]],[0,"detail","kfs_bootstrap::paging::table","",N,N],[8,"I386PageTablesSet","kfs_bootstrap::paging::table::detail","A trait describing the interface of a PageTable hierarchy.",N,N],[16,"PageDirectoryType","","",35,N],[10,"get_directory","","Gets a reference to the directory",35,[[["self"]],["smarthierarchicaltable"]]],[17,"DIRECTORY_RECURSIVE_ADDRESS","kfs_bootstrap::paging::table","When paging is on, accessing this address loops back to…",N,N],[8,"HierarchicalTable","","A table of entries, either the directory or one of the…",N,N],[10,"entries","","",36,N],[10,"entries_mut","","",36,N],[11,"zero","","zero out the whole table",36,[[["self"]]]],[11,"map_nth_entry","","Creates a mapping on the nth entry of a table T is a…",36,[[["self"],["usize"],["frame"],["i386entryflags"]]]],[11,"guard_nth_entry","","Marks the nth entry as guard page T is a flusher…",36,[[["self"],["usize"]]]],[11,"flush_cache","","",36,[[]]],[8,"PageTableTrait","","",N,N],[16,"FlusherType","","",37,N],[11,"map_whole_table","","Used at startup when creating the first page tables.",37,[[["self"],["physicaladdress"],["i386entryflags"]]]],[11,"map_guard_whole_table","","Used at startup when creating the first page tables.",37,[[["self"]]]],[8,"PageDirectoryTrait","","A trait describing all the things that a PageDirectory can…",N,N],[16,"PageTableType","","",38,N],[16,"FlusherType","","",38,N],[10,"get_table","","Gets a reference to a page table",38,[[["self"],["usize"]],["pagestate",["smarthierarchicaltable"]]]],[10,"create_table","","Allocates a page table, zero it and add an entry to the…",38,[[["self"],["usize"]],["smarthierarchicaltable"]]],[11,"get_table_or_create","","Gets the page table at given index, or creates it if it…",38,[[["self"],["usize"]],["smarthierarchicaltable"]]],[11,"map_to","","Creates a mapping in the page tables with the given flags",38,[[["self"],["frame"],["virtualaddress"],["i386entryflags"]]]],[11,"guard","","Creates a guard page",38,[[["self"],["virtualaddress"]]]],[11,"__unmap","","Deletes a mapping in the page tables, returning the frame…",38,[[["self"],["virtualaddress"]],["pagestate",["frame"]]]],[11,"find_available_virtual_space_aligned","","Finds a virtual space hole that can contain page_nb…",38,[[["self"],["usize"],["usize"]],["option",["virtualaddress"]]]],[8,"PageTablesSet","","",N,N],[10,"map_to","","Creates a mapping in the page tables with the given flags",39,[[["self"],["mappingtype"],["virtualaddress"]]]],[10,"get_phys","","Gets the current mapping state of this Virtual Address.",39,[[["self"],["virtualaddress"]],["pagestate",["physicaladdress"]]]],[10,"find_available_virtual_space_aligned","","Finds a virtual space hole that can contain page_nb…",39,[[["self"],["usize"],["usize"]],["option",["virtualaddress"]]]],[11,"print_mapping","","Prints the current mapping.",39,[[["self"]]]],[10,"unmap","","Deletes a mapping in the page tables, returning the Frame…",39,[[["self"],["virtualaddress"]],["pagestate",["frame"]]]],[11,"map_allocate_to","","Creates a mapping in the page tables with the given flags.…",39,[[["self"],["virtualaddress"],["entryflags"]]]],[11,"map_frame","","Maps a given frame in the page tables. Takes care of…",39,[[["self"],["frame"],["entryflags"]],["virtualaddress"]]],[11,"get_page","","Creates a mapping in the page tables with the given flags.…",39,[[["self"]],["virtualaddress"]]],[11,"map_page_guard","","Reserves a given page as guard page. This affects only…",39,[[["self"],["virtualaddress"]]]],[11,"map_range_page_guard","","Reserve a given region as guard pages. If the region spans…",39,[[["self"],["virtualaddress"],["usize"]]]],[11,"map_range","","Maps the given physical address range to the given virtual…",39,[[["self"],["physicaladdress"],["virtualaddress"],["usize"],["entryflags"]]]],[11,"map_range_allocate","","Maps a given number of consecutive pages at a given…",39,[[["self"],["virtualaddress"],["usize"],["entryflags"]]]],[11,"identity_map","","Maps a memory frame to the same virtual address",39,[[["self"],["frame"],["entryflags"]]]],[11,"identity_map_region","","Identity maps a range of frames",39,[[["self"],["physicaladdress"],["usize"],["entryflags"]]]],[11,"find_available_virtual_space","","Finds a virtual space hole that can contain page_nb…",39,[[["self"],["usize"]],["option",["virtualaddress"]]]],[11,"set_page_readonly","","Sets a previously mapped page as readonly",39,[[["self"],["virtualaddress"]]]],[11,"set_region_readonly","","Sets a previously mapped range of pages readonly",39,[[["self"],["virtualaddress"],["usize"]]]],[8,"Flusher","","A trait used to decide if the TLB cache should be flushed…",N,N],[11,"flush_cache","","",40,[[]]],[18,"WRITABLE","kfs_bootstrap::paging","",18,N],[18,"USER_ACCESSIBLE","","",18,N],[11,"empty","","Returns an empty set of flags.",18,[[],["entryflags"]]],[11,"all","","Returns the set containing all flags.",18,[[],["entryflags"]]],[11,"bits","","Returns the raw value of the flags currently stored.",18,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",18,[[["u32"]],["option",["entryflags"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",18,[[["u32"]],["entryflags"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",18,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",18,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",18,[[["self"],["entryflags"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",18,[[["self"],["entryflags"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",18,[[["self"],["entryflags"]]]],[11,"remove","","Removes the specified flags in-place.",18,[[["self"],["entryflags"]]]],[11,"toggle","","Toggles the specified flags in-place.",18,[[["self"],["entryflags"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",18,[[["self"],["entryflags"],["bool"]]]],[11,"get_table_address","kfs_bootstrap::paging::table","reduce recursive mapping by one time to get further down…",25,[[["self"],["usize"]],["pagestate",["usize"]]]],[11,"new","","",27,N],[11,"new","kfs_bootstrap::paging","Creates a new set of inactive page tables",16,[[],["inactivepagetables"]]],[11,"switch_to","","Switch to this page tables set. Returns the old active…",16,[[["self"]],["inactivepagetables"]]],[11,"delete","","",16,[[["self"]]]],[11,"delete_userspace","kfs_bootstrap::paging::table","",28,[[["self"]]]],[11,"copy_active_kernelspace","","Copies all the entries in the directory mapping tables…",28,[[["self"]]]],[11,"free_all_frames","","Frees all pages mapped by this table, and mark the frames…",29,[[["self"]]]],[11,"paging_off_create_page_set","kfs_bootstrap::paging","Used at startup when the paging is disabled and creating…",17,[[],["self"]]],[11,"enable_paging","","Enables paging with this tables as active tables",17,[[["self"]]]],[11,"init_directory","kfs_bootstrap::paging::table","Initializes the directory. This function does two things:",30,[[["self"]]]],[7,"ACTIVE_PAGE_TABLES","kfs_bootstrap::paging","Currently active page tables.",N,N],[17,"PAGE_SIZE","","The size of a single page.",N,N],[17,"ENTRY_COUNT","","",N,N],[8,"PageTablesSet","","",N,N],[10,"map_to","","Creates a mapping in the page tables with the given flags",39,[[["self"],["mappingtype"],["virtualaddress"]]]],[10,"get_phys","","Gets the current mapping state of this Virtual Address.",39,[[["self"],["virtualaddress"]],["pagestate",["physicaladdress"]]]],[10,"find_available_virtual_space_aligned","","Finds a virtual space hole that can contain page_nb…",39,[[["self"],["usize"],["usize"]],["option",["virtualaddress"]]]],[11,"print_mapping","kfs_bootstrap::paging::table","Prints the current mapping.",39,[[["self"]]]],[10,"unmap","kfs_bootstrap::paging","Deletes a mapping in the page tables, returning the Frame…",39,[[["self"],["virtualaddress"]],["pagestate",["frame"]]]],[11,"map_allocate_to","kfs_bootstrap::paging::table","Creates a mapping in the page tables with the given flags.…",39,[[["self"],["virtualaddress"],["entryflags"]]]],[11,"map_frame","","Maps a given frame in the page tables. Takes care of…",39,[[["self"],["frame"],["entryflags"]],["virtualaddress"]]],[11,"get_page","","Creates a mapping in the page tables with the given flags.…",39,[[["self"]],["virtualaddress"]]],[11,"map_page_guard","","Reserves a given page as guard page. This affects only…",39,[[["self"],["virtualaddress"]]]],[11,"map_range_page_guard","","Reserve a given region as guard pages. If the region spans…",39,[[["self"],["virtualaddress"],["usize"]]]],[11,"map_range","","Maps the given physical address range to the given virtual…",39,[[["self"],["physicaladdress"],["virtualaddress"],["usize"],["entryflags"]]]],[11,"map_range_allocate","","Maps a given number of consecutive pages at a given…",39,[[["self"],["virtualaddress"],["usize"],["entryflags"]]]],[11,"identity_map","","Maps a memory frame to the same virtual address",39,[[["self"],["frame"],["entryflags"]]]],[11,"identity_map_region","","Identity maps a range of frames",39,[[["self"],["physicaladdress"],["usize"],["entryflags"]]]],[11,"find_available_virtual_space","","Finds a virtual space hole that can contain page_nb…",39,[[["self"],["usize"]],["option",["virtualaddress"]]]],[11,"set_page_readonly","","Sets a previously mapped page as readonly",39,[[["self"],["virtualaddress"]]]],[11,"set_region_readonly","","Sets a previously mapped range of pages readonly",39,[[["self"],["virtualaddress"],["usize"]]]],[8,"VirtualSpaceLand","kfs_bootstrap::paging","A trait describing the splitting of virtual memory between…",N,N],[10,"start_addr","","The first address in this land.",41,[[],["virtualaddress"]]],[10,"end_addr","","The last address in this land.",41,[[],["virtualaddress"]]],[11,"start_table","","The index in page directory of the first table of this land",41,[[],["usize"]]],[11,"end_table","","The index in page directory of the last table of this land",41,[[],["usize"]]],[11,"start_addr","","",42,[[],["virtualaddress"]]],[11,"end_addr","","",42,[[],["virtualaddress"]]],[11,"start_addr","","",43,[[],["virtualaddress"]]],[11,"end_addr","","",43,[[],["virtualaddress"]]],[0,"frame_alloc","kfs_bootstrap","A module implementing a physical memory manager that…",N,N],[3,"AllocatorBitmap","kfs_bootstrap::frame_alloc","A big bitmap denoting for every frame if it is free or not",N,N],[12,"memory_bitmap","","",44,N],[12,"initialized","","",44,N],[3,"Frame","","A pointer to a physical frame",N,N],[12,"physical_addr","","",45,N],[12,"is_allocated","","",45,N],[3,"FrameAllocator","","A physical memory manger to allocate and free memory frames",N,N],[5,"addr_to_frame","","Gets the frame number from a physical address",N,[[["usize"]],["usize"]]],[5,"frame_to_addr","","Gets the physical address from a frame number",N,[[["usize"]],["usize"]]],[5,"round_to_page","","Rounds an address to its page address",N,[[["usize"]],["usize"]]],[5,"round_to_page_upper","","Rounds an address to the next page address except if its…",N,[[["usize"]],["usize"]]],[7,"FRAMES_BITMAP","","A big bitmap denoting for every frame if it is free or not",N,N],[17,"MEMORY_FRAME_SIZE","","A memory frame is the same size as a page",N,N],[17,"FRAME_OFFSET_MASK","","",N,N],[17,"FRAME_BASE_MASK","","",N,N],[17,"FRAME_BASE_LOG","","",N,N],[17,"FRAMES_BITMAP_SIZE","","The size of the frames_bitmap (~128ko)",N,N],[17,"FRAME_FREE","","",N,N],[17,"FRAME_OCCUPIED","","",N,N],[11,"address","","Get the physical address of this Frame",45,[[["self"]],["physicaladdress"]]],[11,"is_allocated","","Gets the current allocation state",45,[[["self"]],["bool"]]],[11,"from_physical_addr","","Constructs a frame structure from a physical address",45,[[["physicaladdress"]],["frame"]]],[11,"from_allocated_addr","","Constructs a frame structure from a physical address",45,[[["physicaladdress"]],["frame"]]],[11,"init","","Initialize the FrameAllocator by parsing the multiboot…",46,[[["bootinformation"]]]],[11,"check_initialized","","Panics if the frames bitmap was not initialized",46,[[["allocatorbitmap"]]]],[11,"mark_area_reserved","","Marks a physical memory area as reserved and will never…",46,N],[11,"mark_area_free","","Marks a physical memory area as free for frame allocation",46,N],[11,"alloc_frame","","Allocates a free frame",46,[[],["frame"]]],[11,"alloc_contiguous_frames","","Allocates count contiguous frames.",46,[[["usize"]],["physicaladdress"]]],[11,"free_frame","","Frees an allocated frame.",46,[[["frame"]]]],[0,"elf_loader","kfs_bootstrap","Loads the kernel in high memory",N,N],[5,"load_kernel","kfs_bootstrap::elf_loader","Loads the kernel in high memory Returns address of entry…",N,[[["pagingoffpageset"],["bootinformation"]],["usize"]]],[5,"load_segment","","Loads an elf segment by coping file_size bytes to the…",N,[[["pagingoffpageset"],["programheader"],["elffile"]]]],[0,"bootstrap_stack","kfs_bootstrap","Bootstrap stack",N,N],[3,"BootstrapStack","kfs_bootstrap::bootstrap_stack","A structure representing a kernel stack",N,N],[12,"stack_address","","",47,N],[17,"STACK_SIZE","","The size of a kernel stack, not accounting for the page…",N,N],[17,"STACK_SIZE_WITH_GUARD","","The size of the kernel stack, with the page guard.",N,N],[17,"STACK_ALIGNEMENT","","The alignment of the stack.…",N,N],[11,"allocate_stack","","Allocates the bootstrap stack",47,[[],["option",["bootstrapstack"]]]],[18,"STACK_POISON_SIZE","","We keep 2 poison pointers for fake saved ebp and saved esp…",47,N],[11,"create_poison_pointers","","Puts two poisons pointers at the base of the stack for the…",47,[[["self"]]]],[11,"get_stack_start","","Get the address of the beginning of usable stack. Used for…",47,[[["self"]],["usize"]]],[7,"STACK","kfs_bootstrap","The stack we start on.",N,N],[7,"MULTIBOOT_HEADER","","The multiboot header of our binary.",N,N],[11,"default","","",1,[[],["endtag"]]],[11,"new","","",2,[[["u32"],["u32"],["u32"]],["framebuffertag"]]],[11,"new","","",3,[[],["modulealignmenttag"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"from","kfs_bootstrap::bootstrap_logging","",48,[[["t"]],["t"]]],[11,"try_from","","",48,[[["u"]],["result"]]],[11,"try_into","","",48,[[["self"]],["result"]]],[11,"into","","",48,[[["self"]],["u"]]],[11,"borrow","","",48,[[["self"]],["t"]]],[11,"borrow_mut","","",48,[[["self"]],["t"]]],[11,"get_type_id","","",48,[[["self"]],["typeid"]]],[11,"from","kfs_bootstrap::gdt","",5,[[["t"]],["t"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"from","","",8,[[["t"]],["t"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"from","","",9,[[["t"]],["t"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"from","kfs_bootstrap::gdt::segment_selector","",10,[[["t"]],["t"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"from","kfs_bootstrap::gdt::i386","",11,[[["t"]],["t"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"from","","",12,[[["t"]],["t"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"from","kfs_bootstrap::gdt::i386::instructions::tables","",13,[[["t"]],["t"]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"into","","",13,[[["self"]],["u"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"from","kfs_bootstrap::address","",14,[[["t"]],["t"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"try_into","","",14,[[["self"]],["result"]]],[11,"into","","",14,[[["self"]],["u"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"get_type_id","","",14,[[["self"]],["typeid"]]],[11,"from","","",15,[[["t"]],["t"]]],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"try_into","","",15,[[["self"]],["result"]]],[11,"into","","",15,[[["self"]],["u"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"get_type_id","","",15,[[["self"]],["typeid"]]],[11,"from","kfs_bootstrap::paging","",49,[[["t"]],["t"]]],[11,"try_from","","",49,[[["u"]],["result"]]],[11,"try_into","","",49,[[["self"]],["result"]]],[11,"into","","",49,[[["self"]],["u"]]],[11,"borrow","","",49,[[["self"]],["t"]]],[11,"borrow_mut","","",49,[[["self"]],["t"]]],[11,"get_type_id","","",49,[[["self"]],["typeid"]]],[11,"from","","",16,[[["t"]],["t"]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"into","","",16,[[["self"]],["u"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"from","","",17,[[["t"]],["t"]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"into","","",17,[[["self"]],["u"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"get_type_id","","",17,[[["self"]],["typeid"]]],[11,"from","","",18,[[["t"]],["t"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"into","","",18,[[["self"]],["u"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"get_type_id","","",18,[[["self"]],["typeid"]]],[11,"from","","",42,[[["t"]],["t"]]],[11,"try_from","","",42,[[["u"]],["result"]]],[11,"try_into","","",42,[[["self"]],["result"]]],[11,"into","","",42,[[["self"]],["u"]]],[11,"borrow","","",42,[[["self"]],["t"]]],[11,"borrow_mut","","",42,[[["self"]],["t"]]],[11,"get_type_id","","",42,[[["self"]],["typeid"]]],[11,"from","","",43,[[["t"]],["t"]]],[11,"try_from","","",43,[[["u"]],["result"]]],[11,"try_into","","",43,[[["self"]],["result"]]],[11,"into","","",43,[[["self"]],["u"]]],[11,"borrow","","",43,[[["self"]],["t"]]],[11,"borrow_mut","","",43,[[["self"]],["t"]]],[11,"get_type_id","","",43,[[["self"]],["typeid"]]],[11,"from","","",19,[[["t"]],["t"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"try_into","","",19,[[["self"]],["result"]]],[11,"into","","",19,[[["self"]],["u"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"get_type_id","","",19,[[["self"]],["typeid"]]],[11,"from","kfs_bootstrap::paging::entry","",20,[[["t"]],["t"]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"try_into","","",20,[[["self"]],["result"]]],[11,"into","","",20,[[["self"]],["u"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"get_type_id","","",20,[[["self"]],["typeid"]]],[11,"from","","",21,[[["t"]],["t"]]],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"try_into","","",21,[[["self"]],["result"]]],[11,"into","","",21,[[["self"]],["u"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"get_type_id","","",21,[[["self"]],["typeid"]]],[11,"from","","",22,[[["t"]],["t"]]],[11,"try_from","","",22,[[["u"]],["result"]]],[11,"try_into","","",22,[[["self"]],["result"]]],[11,"into","","",22,[[["self"]],["u"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"get_type_id","","",22,[[["self"]],["typeid"]]],[11,"from","kfs_bootstrap::paging::table","",23,[[["t"]],["t"]]],[11,"try_from","","",23,[[["u"]],["result"]]],[11,"try_into","","",23,[[["self"]],["result"]]],[11,"into","","",23,[[["self"]],["u"]]],[11,"borrow","","",23,[[["self"]],["t"]]],[11,"borrow_mut","","",23,[[["self"]],["t"]]],[11,"get_type_id","","",23,[[["self"]],["typeid"]]],[11,"from","","",24,[[["t"]],["t"]]],[11,"try_from","","",24,[[["u"]],["result"]]],[11,"try_into","","",24,[[["self"]],["result"]]],[11,"into","","",24,[[["self"]],["u"]]],[11,"borrow","","",24,[[["self"]],["t"]]],[11,"borrow_mut","","",24,[[["self"]],["t"]]],[11,"get_type_id","","",24,[[["self"]],["typeid"]]],[11,"from","","",25,[[["t"]],["t"]]],[11,"try_from","","",25,[[["u"]],["result"]]],[11,"try_into","","",25,[[["self"]],["result"]]],[11,"into","","",25,[[["self"]],["u"]]],[11,"borrow","","",25,[[["self"]],["t"]]],[11,"borrow_mut","","",25,[[["self"]],["t"]]],[11,"get_type_id","","",25,[[["self"]],["typeid"]]],[11,"from","","",26,[[["t"]],["t"]]],[11,"try_from","","",26,[[["u"]],["result"]]],[11,"try_into","","",26,[[["self"]],["result"]]],[11,"into","","",26,[[["self"]],["u"]]],[11,"borrow","","",26,[[["self"]],["t"]]],[11,"borrow_mut","","",26,[[["self"]],["t"]]],[11,"get_type_id","","",26,[[["self"]],["typeid"]]],[11,"from","","",27,[[["t"]],["t"]]],[11,"try_from","","",27,[[["u"]],["result"]]],[11,"try_into","","",27,[[["self"]],["result"]]],[11,"into","","",27,[[["self"]],["u"]]],[11,"borrow","","",27,[[["self"]],["t"]]],[11,"borrow_mut","","",27,[[["self"]],["t"]]],[11,"get_type_id","","",27,[[["self"]],["typeid"]]],[11,"from","","",28,[[["t"]],["t"]]],[11,"try_from","","",28,[[["u"]],["result"]]],[11,"try_into","","",28,[[["self"]],["result"]]],[11,"into","","",28,[[["self"]],["u"]]],[11,"borrow","","",28,[[["self"]],["t"]]],[11,"borrow_mut","","",28,[[["self"]],["t"]]],[11,"get_type_id","","",28,[[["self"]],["typeid"]]],[11,"from","","",29,[[["t"]],["t"]]],[11,"try_from","","",29,[[["u"]],["result"]]],[11,"try_into","","",29,[[["self"]],["result"]]],[11,"into","","",29,[[["self"]],["u"]]],[11,"borrow","","",29,[[["self"]],["t"]]],[11,"borrow_mut","","",29,[[["self"]],["t"]]],[11,"get_type_id","","",29,[[["self"]],["typeid"]]],[11,"from","","",30,[[["t"]],["t"]]],[11,"try_from","","",30,[[["u"]],["result"]]],[11,"try_into","","",30,[[["self"]],["result"]]],[11,"into","","",30,[[["self"]],["u"]]],[11,"borrow","","",30,[[["self"]],["t"]]],[11,"borrow_mut","","",30,[[["self"]],["t"]]],[11,"get_type_id","","",30,[[["self"]],["typeid"]]],[11,"from","","",31,[[["t"]],["t"]]],[11,"try_from","","",31,[[["u"]],["result"]]],[11,"try_into","","",31,[[["self"]],["result"]]],[11,"into","","",31,[[["self"]],["u"]]],[11,"borrow","","",31,[[["self"]],["t"]]],[11,"borrow_mut","","",31,[[["self"]],["t"]]],[11,"get_type_id","","",31,[[["self"]],["typeid"]]],[11,"from","","",50,[[["t"]],["t"]]],[11,"try_from","","",50,[[["u"]],["result"]]],[11,"try_into","","",50,[[["self"]],["result"]]],[11,"into","","",50,[[["self"]],["u"]]],[11,"borrow","","",50,[[["self"]],["t"]]],[11,"borrow_mut","","",50,[[["self"]],["t"]]],[11,"get_type_id","","",50,[[["self"]],["typeid"]]],[11,"from","","",51,[[["t"]],["t"]]],[11,"try_from","","",51,[[["u"]],["result"]]],[11,"try_into","","",51,[[["self"]],["result"]]],[11,"into","","",51,[[["self"]],["u"]]],[11,"borrow","","",51,[[["self"]],["t"]]],[11,"borrow_mut","","",51,[[["self"]],["t"]]],[11,"get_type_id","","",51,[[["self"]],["typeid"]]],[11,"from","kfs_bootstrap::paging::table::entry","",32,[[["t"]],["t"]]],[11,"try_from","","",32,[[["u"]],["result"]]],[11,"try_into","","",32,[[["self"]],["result"]]],[11,"into","","",32,[[["self"]],["u"]]],[11,"borrow","","",32,[[["self"]],["t"]]],[11,"borrow_mut","","",32,[[["self"]],["t"]]],[11,"get_type_id","","",32,[[["self"]],["typeid"]]],[11,"from","","",33,[[["t"]],["t"]]],[11,"try_from","","",33,[[["u"]],["result"]]],[11,"try_into","","",33,[[["self"]],["result"]]],[11,"into","","",33,[[["self"]],["u"]]],[11,"borrow","","",33,[[["self"]],["t"]]],[11,"borrow_mut","","",33,[[["self"]],["t"]]],[11,"get_type_id","","",33,[[["self"]],["typeid"]]],[11,"from","","",34,[[["t"]],["t"]]],[11,"try_from","","",34,[[["u"]],["result"]]],[11,"try_into","","",34,[[["self"]],["result"]]],[11,"into","","",34,[[["self"]],["u"]]],[11,"borrow","","",34,[[["self"]],["t"]]],[11,"borrow_mut","","",34,[[["self"]],["t"]]],[11,"get_type_id","","",34,[[["self"]],["typeid"]]],[11,"from","kfs_bootstrap::frame_alloc","",44,[[["t"]],["t"]]],[11,"try_from","","",44,[[["u"]],["result"]]],[11,"try_into","","",44,[[["self"]],["result"]]],[11,"into","","",44,[[["self"]],["u"]]],[11,"borrow","","",44,[[["self"]],["t"]]],[11,"borrow_mut","","",44,[[["self"]],["t"]]],[11,"get_type_id","","",44,[[["self"]],["typeid"]]],[11,"from","","",45,[[["t"]],["t"]]],[11,"try_from","","",45,[[["u"]],["result"]]],[11,"try_into","","",45,[[["self"]],["result"]]],[11,"into","","",45,[[["self"]],["u"]]],[11,"borrow","","",45,[[["self"]],["t"]]],[11,"borrow_mut","","",45,[[["self"]],["t"]]],[11,"get_type_id","","",45,[[["self"]],["typeid"]]],[11,"from","","",46,[[["t"]],["t"]]],[11,"try_from","","",46,[[["u"]],["result"]]],[11,"try_into","","",46,[[["self"]],["result"]]],[11,"into","","",46,[[["self"]],["u"]]],[11,"borrow","","",46,[[["self"]],["t"]]],[11,"borrow_mut","","",46,[[["self"]],["t"]]],[11,"get_type_id","","",46,[[["self"]],["typeid"]]],[11,"from","kfs_bootstrap::bootstrap_stack","",47,[[["t"]],["t"]]],[11,"try_from","","",47,[[["u"]],["result"]]],[11,"try_into","","",47,[[["self"]],["result"]]],[11,"into","","",47,[[["self"]],["u"]]],[11,"borrow","","",47,[[["self"]],["t"]]],[11,"borrow_mut","","",47,[[["self"]],["t"]]],[11,"get_type_id","","",47,[[["self"]],["typeid"]]],[11,"entries","kfs_bootstrap::paging::table","",23,N],[11,"entries_mut","","",23,N],[11,"entries","","",24,N],[11,"entries_mut","","",24,N],[11,"entries","","",25,N],[11,"entries_mut","","",25,N],[11,"entries","","",26,N],[11,"entries_mut","","",26,N],[11,"entries","","",28,N],[11,"entries_mut","","",28,N],[11,"entries","","",29,N],[11,"entries_mut","","",29,N],[11,"entries","","",30,N],[11,"entries_mut","","",30,N],[11,"entries","","",31,N],[11,"entries_mut","","",31,N],[11,"get_table","","Gets a reference to a page table through recursive mapping",25,[[["self"],["usize"]],["pagestate",["smarthierarchicaltable"]]]],[11,"create_table","","Allocates a page table, zero it and add an entry to the…",25,[[["self"],["usize"]],["smarthierarchicaltable"]]],[11,"get_table","","Temporary map the table",28,[[["self"],["usize"]],["pagestate",["smarthierarchicaltable"]]]],[11,"create_table","","Allocates a page table, temporarily map it, zero it and…",28,[[["self"],["usize"]],["smarthierarchicaltable"]]],[11,"get_table","","Simply cast pointed frame as PageTable",30,[[["self"],["usize"]],["pagestate",["smarthierarchicaltable"]]]],[11,"create_table","","Allocates a page table, zero it and add an entry to the…",30,[[["self"],["usize"]],["smarthierarchicaltable"]]],[11,"get_directory","kfs_bootstrap::paging","",49,[[["self"]],["smarthierarchicaltable",["activepagedirectory"]]]],[11,"get_directory","","Temporary map the directory",16,[[["self"]],["smarthierarchicaltable",["inactivepagedirectory"]]]],[11,"get_directory","","",17,[[["self"]],["smarthierarchicaltable"]]],[11,"flush_cache","kfs_bootstrap::paging::table","",50,[[]]],[11,"flush_cache","","",51,[[]]],[11,"start_addr","kfs_bootstrap::paging","",42,[[],["virtualaddress"]]],[11,"end_addr","","",42,[[],["virtualaddress"]]],[11,"start_addr","","",43,[[],["virtualaddress"]]],[11,"end_addr","","",43,[[],["virtualaddress"]]],[11,"PRESENT","kfs_bootstrap::paging::entry","",20,[[["self"]],["bool"]]],[11,"WRITABLE","","",20,[[["self"]],["bool"]]],[11,"USER_ACCESSIBLE","","",20,[[["self"]],["bool"]]],[11,"WRITE_THROUGH","","",20,[[["self"]],["bool"]]],[11,"NO_CACHE","","",20,[[["self"]],["bool"]]],[11,"ACCESSED","","",20,[[["self"]],["bool"]]],[11,"DIRTY","","",20,[[["self"]],["bool"]]],[11,"HUGE_PAGE","","",20,[[["self"]],["bool"]]],[11,"GLOBAL","","",20,[[["self"]],["bool"]]],[11,"GUARD_PAGE","","",20,[[["self"]],["bool"]]],[11,"IS_FRAME_ALLOC","","",20,[[["self"]],["bool"]]],[11,"USER_DEFINED_3","","",20,[[["self"]],["bool"]]],[11,"PRESENT","","",20,[[],["u32"]]],[11,"WRITABLE","","",20,[[],["u32"]]],[11,"USER_ACCESSIBLE","","",20,[[],["u32"]]],[11,"WRITE_THROUGH","","",20,[[],["u32"]]],[11,"NO_CACHE","","",20,[[],["u32"]]],[11,"ACCESSED","","",20,[[],["u32"]]],[11,"DIRTY","","",20,[[],["u32"]]],[11,"HUGE_PAGE","","",20,[[],["u32"]]],[11,"GLOBAL","","",20,[[],["u32"]]],[11,"GUARD_PAGE","","",20,[[],["u32"]]],[11,"IS_FRAME_ALLOC","","",20,[[],["u32"]]],[11,"USER_DEFINED_3","","",20,[[],["u32"]]],[11,"PRESENT","kfs_bootstrap::paging::table::entry","",32,[[["self"]],["bool"]]],[11,"WRITABLE","","",32,[[["self"]],["bool"]]],[11,"USER_ACCESSIBLE","","",32,[[["self"]],["bool"]]],[11,"WRITE_THROUGH","","",32,[[["self"]],["bool"]]],[11,"NO_CACHE","","",32,[[["self"]],["bool"]]],[11,"ACCESSED","","",32,[[["self"]],["bool"]]],[11,"DIRTY","","",32,[[["self"]],["bool"]]],[11,"HUGE_PAGE","","",32,[[["self"]],["bool"]]],[11,"GLOBAL","","",32,[[["self"]],["bool"]]],[11,"GUARD_PAGE","","",32,[[["self"]],["bool"]]],[11,"IS_FRAME_ALLOC","","",32,[[["self"]],["bool"]]],[11,"USER_DEFINED_3","","",32,[[["self"]],["bool"]]],[11,"PRESENT","","",32,[[],["u32"]]],[11,"WRITABLE","","",32,[[],["u32"]]],[11,"USER_ACCESSIBLE","","",32,[[],["u32"]]],[11,"WRITE_THROUGH","","",32,[[],["u32"]]],[11,"NO_CACHE","","",32,[[],["u32"]]],[11,"ACCESSED","","",32,[[],["u32"]]],[11,"DIRTY","","",32,[[],["u32"]]],[11,"HUGE_PAGE","","",32,[[],["u32"]]],[11,"GLOBAL","","",32,[[],["u32"]]],[11,"GUARD_PAGE","","",32,[[],["u32"]]],[11,"IS_FRAME_ALLOC","","",32,[[],["u32"]]],[11,"USER_DEFINED_3","","",32,[[],["u32"]]],[11,"WRITABLE","kfs_bootstrap::paging","",18,[[["self"]],["bool"]]],[11,"USER_ACCESSIBLE","","",18,[[["self"]],["bool"]]],[11,"WRITABLE","","",18,[[],["u32"]]],[11,"USER_ACCESSIBLE","","",18,[[],["u32"]]],[11,"fmt","kfs_bootstrap::address","",14,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","kfs_bootstrap::gdt::segment_selector","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::gdt::i386","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::gdt","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::address","",14,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","kfs_bootstrap::paging::entry","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",21,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",22,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::paging::table::entry","",32,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",33,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",34,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::paging","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::frame_alloc","",45,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::bootstrap_stack","",47,[[["self"],["formatter"]],["result"]]],[11,"eq","kfs_bootstrap::gdt::i386","",12,[[["self"],["privilegelevel"]],["bool"]]],[11,"eq","kfs_bootstrap::address","",14,[[["self"],["physicaladdress"]],["bool"]]],[11,"ne","","",14,[[["self"],["physicaladdress"]],["bool"]]],[11,"eq","","",15,[[["self"],["virtualaddress"]],["bool"]]],[11,"ne","","",15,[[["self"],["virtualaddress"]],["bool"]]],[11,"eq","kfs_bootstrap::paging::entry","",20,[[["self"],["entryflags"]],["bool"]]],[11,"ne","","",20,[[["self"],["entryflags"]],["bool"]]],[11,"eq","kfs_bootstrap::paging::table::entry","",32,[[["self"],["entryflags"]],["bool"]]],[11,"ne","","",32,[[["self"],["entryflags"]],["bool"]]],[11,"eq","kfs_bootstrap::paging","",18,[[["self"],["entryflags"]],["bool"]]],[11,"ne","","",18,[[["self"],["entryflags"]],["bool"]]],[11,"assert_receiver_is_total_eq","kfs_bootstrap::gdt::i386","",12,N],[11,"assert_receiver_is_total_eq","kfs_bootstrap::address","",14,N],[11,"assert_receiver_is_total_eq","","",15,N],[11,"assert_receiver_is_total_eq","kfs_bootstrap::paging::entry","",20,N],[11,"assert_receiver_is_total_eq","kfs_bootstrap::paging::table::entry","",32,N],[11,"assert_receiver_is_total_eq","kfs_bootstrap::paging","",18,N],[11,"cmp","kfs_bootstrap::address","",14,[[["self"],["physicaladdress"]],["ordering"]]],[11,"cmp","","",15,[[["self"],["virtualaddress"]],["ordering"]]],[11,"cmp","kfs_bootstrap::paging::entry","",20,[[["self"],["entryflags"]],["ordering"]]],[11,"cmp","kfs_bootstrap::paging::table::entry","",32,[[["self"],["entryflags"]],["ordering"]]],[11,"cmp","kfs_bootstrap::paging","",18,[[["self"],["entryflags"]],["ordering"]]],[11,"partial_cmp","kfs_bootstrap::address","",14,[[["self"],["physicaladdress"]],["option",["ordering"]]]],[11,"lt","","",14,[[["self"],["physicaladdress"]],["bool"]]],[11,"le","","",14,[[["self"],["physicaladdress"]],["bool"]]],[11,"gt","","",14,[[["self"],["physicaladdress"]],["bool"]]],[11,"ge","","",14,[[["self"],["physicaladdress"]],["bool"]]],[11,"partial_cmp","","",15,[[["self"],["virtualaddress"]],["option",["ordering"]]]],[11,"lt","","",15,[[["self"],["virtualaddress"]],["bool"]]],[11,"le","","",15,[[["self"],["virtualaddress"]],["bool"]]],[11,"gt","","",15,[[["self"],["virtualaddress"]],["bool"]]],[11,"ge","","",15,[[["self"],["virtualaddress"]],["bool"]]],[11,"partial_cmp","kfs_bootstrap::paging::entry","",20,[[["self"],["entryflags"]],["option",["ordering"]]]],[11,"lt","","",20,[[["self"],["entryflags"]],["bool"]]],[11,"le","","",20,[[["self"],["entryflags"]],["bool"]]],[11,"gt","","",20,[[["self"],["entryflags"]],["bool"]]],[11,"ge","","",20,[[["self"],["entryflags"]],["bool"]]],[11,"partial_cmp","kfs_bootstrap::paging::table::entry","",32,[[["self"],["entryflags"]],["option",["ordering"]]]],[11,"lt","","",32,[[["self"],["entryflags"]],["bool"]]],[11,"le","","",32,[[["self"],["entryflags"]],["bool"]]],[11,"gt","","",32,[[["self"],["entryflags"]],["bool"]]],[11,"ge","","",32,[[["self"],["entryflags"]],["bool"]]],[11,"partial_cmp","kfs_bootstrap::paging","",18,[[["self"],["entryflags"]],["option",["ordering"]]]],[11,"lt","","",18,[[["self"],["entryflags"]],["bool"]]],[11,"le","","",18,[[["self"],["entryflags"]],["bool"]]],[11,"gt","","",18,[[["self"],["entryflags"]],["bool"]]],[11,"ge","","",18,[[["self"],["entryflags"]],["bool"]]],[11,"hash","kfs_bootstrap::address","",14,N],[11,"hash","","",15,N],[11,"hash","kfs_bootstrap::paging::entry","",20,N],[11,"hash","kfs_bootstrap::paging::table::entry","",32,N],[11,"hash","kfs_bootstrap::paging","",18,N],[11,"add","kfs_bootstrap::address","Adding a length to an address gives another address",15,[[["self"],["usize"]],["virtualaddress"]]],[11,"add","","Adding a length to an address gives another address",14,[[["self"],["usize"]],["physicaladdress"]]],[11,"sub","","Subtracting a length from an address gives another address",15,[[["self"],["usize"]],["virtualaddress"]]],[11,"sub","","Subtracting a length from an address gives another address",14,[[["self"],["usize"]],["physicaladdress"]]],[11,"sub","","Subtracting two address gives their distance",15,[[["self"],["virtualaddress"]],["usize"]]],[11,"sub","","Subtracting two address gives their distance",14,[[["self"],["physicaladdress"]],["usize"]]],[11,"sub","kfs_bootstrap::paging::entry","Returns the set difference of the two sets of flags.",20,[[["self"],["entryflags"]],["entryflags"]]],[11,"sub","kfs_bootstrap::paging::table::entry","Returns the set difference of the two sets of flags.",32,[[["self"],["entryflags"]],["entryflags"]]],[11,"sub","kfs_bootstrap::paging","Returns the set difference of the two sets of flags.",18,[[["self"],["entryflags"]],["entryflags"]]],[11,"add_assign","kfs_bootstrap::address","Adding a length to an address gives another address",15,[[["self"],["usize"]]]],[11,"add_assign","","Adding a length to an address gives another address",14,[[["self"],["usize"]]]],[11,"sub_assign","","Subtracting a length from an address gives another address",15,[[["self"],["usize"]]]],[11,"sub_assign","","Subtracting a length from an address gives another address",14,[[["self"],["usize"]]]],[11,"sub_assign","kfs_bootstrap::paging::entry","Disables all flags enabled in the set.",20,[[["self"],["entryflags"]]]],[11,"sub_assign","kfs_bootstrap::paging::table::entry","Disables all flags enabled in the set.",32,[[["self"],["entryflags"]]]],[11,"sub_assign","kfs_bootstrap::paging","Disables all flags enabled in the set.",18,[[["self"],["entryflags"]]]],[11,"not","kfs_bootstrap::paging::entry","Returns the complement of this set of flags.",20,[[["self"]],["entryflags"]]],[11,"not","kfs_bootstrap::paging::table::entry","Returns the complement of this set of flags.",32,[[["self"]],["entryflags"]]],[11,"not","kfs_bootstrap::paging","Returns the complement of this set of flags.",18,[[["self"]],["entryflags"]]],[11,"bitand","kfs_bootstrap::paging::entry","Returns the intersection between the two sets of flags.",20,[[["self"],["entryflags"]],["entryflags"]]],[11,"bitand","kfs_bootstrap::paging::table::entry","Returns the intersection between the two sets of flags.",32,[[["self"],["entryflags"]],["entryflags"]]],[11,"bitand","kfs_bootstrap::paging","Returns the intersection between the two sets of flags.",18,[[["self"],["entryflags"]],["entryflags"]]],[11,"bitor","kfs_bootstrap::paging::entry","Returns the union of the two sets of flags.",20,[[["self"],["entryflags"]],["entryflags"]]],[11,"bitor","kfs_bootstrap::paging::table::entry","Returns the union of the two sets of flags.",32,[[["self"],["entryflags"]],["entryflags"]]],[11,"bitor","kfs_bootstrap::paging","Returns the union of the two sets of flags.",18,[[["self"],["entryflags"]],["entryflags"]]],[11,"bitxor","kfs_bootstrap::paging::entry","Returns the left flags, but with all the right flags…",20,[[["self"],["entryflags"]],["entryflags"]]],[11,"bitxor","kfs_bootstrap::paging::table::entry","Returns the left flags, but with all the right flags…",32,[[["self"],["entryflags"]],["entryflags"]]],[11,"bitxor","kfs_bootstrap::paging","Returns the left flags, but with all the right flags…",18,[[["self"],["entryflags"]],["entryflags"]]],[11,"bitand_assign","kfs_bootstrap::paging::entry","Disables all flags disabled in the set.",20,[[["self"],["entryflags"]]]],[11,"bitand_assign","kfs_bootstrap::paging::table::entry","Disables all flags disabled in the set.",32,[[["self"],["entryflags"]]]],[11,"bitand_assign","kfs_bootstrap::paging","Disables all flags disabled in the set.",18,[[["self"],["entryflags"]]]],[11,"bitor_assign","kfs_bootstrap::paging::entry","Adds the set of flags.",20,[[["self"],["entryflags"]]]],[11,"bitor_assign","kfs_bootstrap::paging::table::entry","Adds the set of flags.",32,[[["self"],["entryflags"]]]],[11,"bitor_assign","kfs_bootstrap::paging","Adds the set of flags.",18,[[["self"],["entryflags"]]]],[11,"bitxor_assign","kfs_bootstrap::paging::entry","Toggles the set of flags.",20,[[["self"],["entryflags"]]]],[11,"bitxor_assign","kfs_bootstrap::paging::table::entry","Toggles the set of flags.",32,[[["self"],["entryflags"]]]],[11,"bitxor_assign","kfs_bootstrap::paging","Toggles the set of flags.",18,[[["self"],["entryflags"]]]],[11,"deref","kfs_bootstrap::gdt","",5,[[["self"]],["tssstruct"]]],[11,"deref","","",6,[[["self"]],["tssstruct"]]],[11,"deref","kfs_bootstrap::paging::table","",25,N],[11,"deref","","",26,N],[11,"deref","","",27,[[["self"]],["t"]]],[11,"deref","","",28,N],[11,"deref","","",29,N],[11,"deref","","",30,N],[11,"deref","","",31,N],[11,"deref_mut","","",25,N],[11,"deref_mut","","",26,N],[11,"deref_mut","","",27,[[["self"]],["t"]]],[11,"deref_mut","","",28,N],[11,"deref_mut","","",29,N],[11,"deref_mut","","",30,N],[11,"deref_mut","","",31,N],[11,"drop","","",27,[[["self"]]]],[11,"drop","","",28,[[["self"]]]],[11,"drop","","",29,[[["self"]]]],[11,"drop","kfs_bootstrap::frame_alloc","",45,[[["self"]]]],[11,"index","kfs_bootstrap::paging::table","",24,[[["self"],["usize"]],["entry"]]],[11,"index","","",23,[[["self"],["usize"]],["entry"]]],[11,"index","","",25,[[["self"],["usize"]],["entry"]]],[11,"index","","",26,[[["self"],["usize"]],["entry"]]],[11,"index","","",28,[[["self"],["usize"]],["entry"]]],[11,"index","","",29,[[["self"],["usize"]],["entry"]]],[11,"index","","",30,[[["self"],["usize"]],["entry"]]],[11,"index","","",31,[[["self"],["usize"]],["entry"]]],[11,"index_mut","","",24,[[["self"],["usize"]],["entry"]]],[11,"index_mut","","",23,[[["self"],["usize"]],["entry"]]],[11,"index_mut","","",25,[[["self"],["usize"]],["entry"]]],[11,"index_mut","","",26,[[["self"],["usize"]],["entry"]]],[11,"index_mut","","",28,[[["self"],["usize"]],["entry"]]],[11,"index_mut","","",29,[[["self"],["usize"]],["entry"]]],[11,"index_mut","","",30,[[["self"],["usize"]],["entry"]]],[11,"index_mut","","",31,[[["self"],["usize"]],["entry"]]],[11,"from_iter","kfs_bootstrap::paging::entry","",20,[[["t"]],["entryflags"]]],[11,"from_iter","kfs_bootstrap::paging::table::entry","",32,[[["t"]],["entryflags"]]],[11,"from_iter","kfs_bootstrap::paging","",18,[[["t"]],["entryflags"]]],[11,"extend","kfs_bootstrap::paging::entry","",20,[[["self"],["t"]]]],[11,"extend","kfs_bootstrap::paging::table::entry","",32,[[["self"],["t"]]]],[11,"extend","kfs_bootstrap::paging","",18,[[["self"],["t"]]]],[11,"from","kfs_bootstrap::paging::entry","",20,[[["entryflags"]],["entryflags"]]],[11,"from","kfs_bootstrap::paging::table::entry","",32,[[["entryflags"]],["entryflags"]]],[11,"write_str","kfs_bootstrap::bootstrap_logging","Writes a string to COM1.",48,[[["self"],["str"]],["result",["error"]]]],[11,"fmt","kfs_bootstrap::paging::entry","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::paging::table::entry","",32,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::paging","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::paging::entry","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::paging::table::entry","",32,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::paging","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::address","",14,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","kfs_bootstrap::paging::entry","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::paging::table::entry","",32,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::paging","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::paging::entry","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::paging::table::entry","",32,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_bootstrap::paging","",18,[[["self"],["formatter"]],["result"]]],[11,"clone","kfs_bootstrap::gdt::i386","",12,[[["self"]],["privilegelevel"]]],[11,"clone","","",11,[[["self"]],["tssstruct"]]],[11,"clone","kfs_bootstrap::gdt","",9,[[["self"]],["systemdescriptortypes"]]],[11,"clone","","",8,[[["self"]],["descriptortableentry"]]],[11,"clone","kfs_bootstrap::address","",14,[[["self"]],["physicaladdress"]]],[11,"clone","","",15,[[["self"]],["virtualaddress"]]],[11,"clone","kfs_bootstrap::paging::entry","",20,[[["self"]],["entryflags"]]],[11,"clone","","",21,[[["self"]],["entry"]]],[11,"clone","kfs_bootstrap::paging::table::entry","",32,[[["self"]],["entryflags"]]],[11,"clone","","",33,[[["self"]],["entry"]]],[11,"clone","kfs_bootstrap::paging","",18,[[["self"]],["entryflags"]]],[11,"default","kfs_bootstrap::gdt::i386","",11,[[],["tssstruct"]]],[11,"default","kfs_bootstrap::paging","",16,[[],["inactivepagetables"]]],[11,"initialize","kfs_bootstrap::gdt","",5,[[["self"]]]],[11,"initialize","","",6,[[["self"]]]]],"paths":[[3,"AlignedStack"],[3,"EndTag"],[3,"FramebufferTag"],[3,"ModuleAlignmentTag"],[3,"MultiBootHeader"],[3,"MAIN_TASK"],[3,"FAULT_TASK"],[3,"DescriptorTable"],[3,"DescriptorTableEntry"],[4,"SystemDescriptorTypes"],[3,"SegmentSelector"],[3,"TssStruct"],[4,"PrivilegeLevel"],[3,"DescriptorTablePointer"],[3,"PhysicalAddress"],[3,"VirtualAddress"],[3,"InactivePageTables"],[3,"PagingOffPageSet"],[3,"EntryFlags"],[4,"MappingType"],[3,"EntryFlags"],[3,"Entry"],[4,"PageState"],[3,"PageTable"],[3,"PageDirectory"],[3,"ActivePageDirectory"],[3,"ActivePageTable"],[3,"SmartHierarchicalTable"],[3,"InactivePageDirectory"],[3,"InactivePageTable"],[3,"PagingOffDirectory"],[3,"PagingOffTable"],[3,"EntryFlags"],[3,"Entry"],[4,"PageState"],[8,"I386PageTablesSet"],[8,"HierarchicalTable"],[8,"PageTableTrait"],[8,"PageDirectoryTrait"],[8,"PageTablesSet"],[8,"Flusher"],[8,"VirtualSpaceLand"],[3,"KernelLand"],[3,"UserLand"],[3,"AllocatorBitmap"],[3,"Frame"],[3,"FrameAllocator"],[3,"BootstrapStack"],[3,"Serial"],[3,"ActivePageTables"],[3,"TlbFlush"],[3,"NoFlush"]]};
searchIndex["kfs_clock"]={"doc":"Clock applet","items":[[3,"Rtc","kfs_clock","IBM Real Time Clock provides access to the current date…",N,N],[12,"command","","Command Register.",0,N],[12,"data","","Data Register.",0,N],[5,"get_day_of_week","","Turns a day of week number from RTC into an english string.",N,[[["u8"]],["str"]]],[5,"get_month","","Turns a month number from RTC into an english string.",N,[[["u8"]],["str"]]],[5,"main","","",N,[[]]],[7,"CAPABILITIES","","",N,N],[11,"new","","Create a new RTC with the default IBM PC values.",0,[[],["rtc"]]],[11,"read_reg","","Read from a CMOS register.",0,[[["self"],["u8"]],["u8"]]],[11,"write_reg","","Write to the CMOS register.",0,[[["self"],["u8"],["u8"]]]],[11,"enable_update_ended_int","","Enable the Update Ended RTC interrupt. This will enable an…",0,[[["self"]]]],[11,"read_interrupt_kind","","Acknowledges an interrupt from the RTC. Necessary to…",0,[[["self"]],["u8"]]],[11,"is_12hr_clock","","Checks if the RTC is in 12 hours or 24 hours mode.…",0,[[["self"]],["bool"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]]],"paths":[[3,"Rtc"]]};
searchIndex["kfs_kernel"]={"doc":"KFS","items":[[5,"force_double_fault","kfs_kernel","Forces a double fault by stack overflowing.",N,[[]]],[5,"main","","The kernel's `main`.",N,[[]]],[5,"start","","The entry point of our kernel.",N,N],[5,"common_start","","CRT0 starts here.",N,N],[5,"eh_personality","","The exception handling personality function for use in the…",N,[[]]],[5,"do_panic","","The kernel panic function.",N,N],[5,"panic_fmt","","Function called on `panic!` invocation.",N,N],[0,"paging","","Paging.",N,N],[3,"MappingAccessRights","kfs_kernel::paging","The flags of a mapping.",N,N],[12,"bits","","",0,N],[4,"PageState","","A hierarchical paging is composed of entries. An entry can…",N,N],[13,"Available","","Available, aka unused. Will page fault on use.",1,N],[13,"Guarded","","Guarded. Reserved and will cause a pagefault on use. Used…",1,N],[13,"Present","","Present. Used and has a backing physical address.",1,N],[5,"read_cr2","","Reads the value of cr2, retrieving the address that caused…",N,[[],["virtualaddress"]]],[0,"process_memory","","The management of a process' memory",N,N],[3,"ProcessMemory","kfs_kernel::paging::process_memory","The struct representing a process' memory, stored in the…",N,N],[12,"userspace_bookkeping","","The list of mappings in this address space.",2,N],[12,"table_hierarchy","","The architecture-dependent paging hierarchy.",2,N],[12,"heap_base_address","","The start of the heap of this process. The heap is managed…",2,N],[4,"QueryMemory","","Because we do not store Available mappings internally, we…",N,N],[13,"Available","","The address fell in an available range.",3,N],[13,"Used","","The address fell in an existing mapping.",3,N],[4,"DynamicHierarchy","","Page tables selector.",N,N],[13,"Active","","The process's hierarchy is already the currently active one.",4,N],[13,"Inactive","","The process's hierarchy an inactive one.",4,N],[11,"from_active_page_tables","","Creates a ProcessMemory referencing the current page…",2,[[],["self"]]],[11,"get_hierarchy","","If these tables are the one currently in use, we return…",2,[[["self"]],["dynamichierarchy"]]],[11,"map_phys_region_to","","Maps a single physical regions to a given virtual address.…",2,[[["self"],["physicalmemregion"],["virtualaddress"],["mappingaccessrights"]],["result",["kernelerror"]]]],[11,"create_regular_mapping","","Allocates the physical regions, and maps them to specified…",2,[[["self"],["virtualaddress"],["usize"],["mappingaccessrights"]],["result",["kernelerror"]]]],[11,"map_shared_mapping","","Maps a previously created shared mapping to specified…",2,[[["self"],["arc",["vec"]],["virtualaddress"],["mappingaccessrights"]],["result",["kernelerror"]]]],[11,"guard","","Guards a range of addresses",2,[[["self"],["virtualaddress"],["usize"]],["result",["kernelerror"]]]],[11,"unmap","","Deletes a mapping in the page tables.",2,[[["self"],["virtualaddress"],["usize"]],["result",["mapping","kernelerror"]]]],[11,"query_memory","","Reads the state of the mapping at a given address.",2,[[["self"],["virtualaddress"]],["querymemory"]]],[11,"shrink_mapping","","Shrink the mapping at `address` to `new_size`.",2,[[["self"],["virtualaddress"],["usize"]],["result",["option","kernelerror"]]]],[11,"expand_mapping","","Expand the mapping at `address` to `new_size`.",2,[[["self"],["virtualaddress"],["usize"]],["result",["kernelerror"]]]],[11,"find_available_space","","Finds a hole in virtual space at least `length` long.",2,[[["self"],["usize"]],["result",["virtualaddress","kernelerror"]]]],[11,"mirror_mapping","","Retrieves the mapping that `address` falls into, and…",2,[[["self"],["virtualaddress"],["usize"]],["result",["crossprocessmapping","kernelerror"]]]],[11,"resize_heap","","Resize the heap of this process, just like a brk. It can…",2,[[["self"],["usize"]],["result",["virtualaddress","kernelerror"]]]],[11,"switch_to","","Switches to this process memory",2,[[["self"]]]],[0,"kernel_memory","kfs_kernel::paging","The management of kernel memory",N,N],[3,"KernelMemory","kfs_kernel::paging::kernel_memory","A struct that acts on KernelLand and RecursiveTablesLand.",N,N],[12,"tables","","The currently active page tables.",5,N],[5,"get_kernel_memory","","Locks the KERNEL_MEMORY",N,[[],["mutexguard",["kernelmemory"]]]],[7,"KERNEL_MEMORY","","A mutex protecting the KernelMemory manager.",N,N],[11,"find_virtual_space_aligned","","Finds a hole in the virtual space at least 'length' long,…",5,[[["self"],["usize"],["usize"]],["result",["virtualaddress","kernelerror"]]]],[11,"find_virtual_space","","Finds a hole in the virtual space at least 'length' long.",5,[[["self"],["usize"]],["result",["virtualaddress","kernelerror"]]]],[11,"map_phys_region_to","","Maps a single physical regions to a given virtual address.",5,[[["self"],["physicalmemregion"],["virtualaddress"],["mappingaccessrights"]]]],[11,"map_phys_region","","Maps a single physical region anywhere.",5,[[["self"],["physicalmemregion"],["mappingaccessrights"]],["virtualaddress"]]],[11,"map_phys_regions","","Maps a list of physical region anywhere.",5,N],[11,"map_frame_iterator_to","","Maps a list of physical region yielded by an iterator.",5,[[["self"],["i"],["virtualaddress"],["mappingaccessrights"]]]],[11,"map_frame_iterator","","Maps a list of physical region yielded by the iterator.…",5,[[["self"],["i"],["mappingaccessrights"]],["virtualaddress"]]],[11,"get_page","","Allocates and maps a single page, choosing a spot in VMEM…",5,[[["self"]],["virtualaddress"]]],[11,"map_allocate_to","","Allocates non-contiguous frames, and map them at the given…",5,[[["self"],["virtualaddress"],["usize"],["mappingaccessrights"]]]],[11,"get_pages","","Allocates and maps the given length, chosing a spot in…",5,[[["self"],["usize"]],["virtualaddress"]]],[11,"guard","","Guards a range of addresses.",5,[[["self"],["virtualaddress"],["usize"]]]],[11,"mapping_state","","Reads the state of the mapping at a given address.",5,[[["self"],["virtualaddress"]],["pagestate",["physicaladdress"]]]],[11,"unmap","","Deletes a mapping in the page tables. This functions…",5,[[["self"],["virtualaddress"],["usize"]]]],[11,"unmap_no_dealloc","","Deletes a mapping in the page tables, but does not free…",5,[[["self"],["virtualaddress"],["usize"]]]],[11,"reserve_kernel_land_frames","","Marks all frames mapped in KernelLand as reserve This is…",5,[[["self"]]]],[11,"get_hierarchy","","Safe access to the active page tables.",5,[[["self"]],["activehierarchy"]]],[11,"dump_kernelland_state","","Prints the state of the KernelLand by parsing the page…",5,[[["self"]]]],[0,"lands","kfs_kernel::paging","Module describing the split between the UserSpace and…",N,N],[3,"KernelLand","kfs_kernel::paging::lands","The virtual memory belonging to kernel",N,N],[3,"UserLand","","The virtual memory belonging to user",N,N],[3,"RecursiveTablesLand","","The virtual memory pointing to active page tables by…",N,N],[5,"__land_assertions","","Assertions to check that Kernel/User pages falls on…",N,[[]]],[8,"VirtualSpaceLand","","A trait describing the splitting of virtual memory between…",N,N],[18,"START","","The first address in this land.",6,N],[18,"END","","The last address in this land.",6,N],[11,"start_addr","","The first address in this land.",6,[[],["virtualaddress"]]],[11,"end_addr","","The last address in this land.",6,[[],["virtualaddress"]]],[11,"length","","The length of this land.",6,[[],["usize"]]],[11,"start_table","","The index in page directory of the first table of this land.",6,[[],["usize"]]],[11,"end_table","","The index in page directory of the last table of this land.",6,[[],["usize"]]],[11,"contains_address","","Is the address contained in this Land ?",6,[[["virtualaddress"]],["bool"]]],[11,"contains_region","","Is the region fully contained in this Land ?",6,[[["virtualaddress"],["usize"]],["bool"]]],[11,"check_contains_address","","Checks that a given address falls in this land, or return…",6,[[["virtualaddress"]],["result",["kernelerror"]]]],[11,"check_contains_region","","Checks that a given region falls in this land, or return…",6,[[["virtualaddress"],["usize"]],["result",["kernelerror"]]]],[0,"mapping","kfs_kernel::paging","Mapping",N,N],[3,"Mapping","kfs_kernel::paging::mapping","A memory mapping. Stores the address, the length, and the…",N,N],[12,"address","","The first address of this mapping.",7,N],[12,"length","","The length of this mapping.",7,N],[12,"mtype","","The type of this mapping, and frames it maps.",7,N],[12,"flags","","The access rights of this mapping.",7,N],[4,"MappingType","","The types that a UserSpace mapping can be in.",N,N],[13,"Available","","Available, nothing is stored there. Accessing to it will…",8,N],[13,"Guarded","","Guarded, like Available, but nothing can be allocated…",8,N],[13,"Regular","","Regular, a region known only by this process. Access…",8,N],[13,"Shared","","Shared, a region that can be mapped in multiple processes.…",8,N],[13,"SystemReserved","","SystemReserved, used to denote the KernelLand and other…",8,N],[11,"new_regular","","Tries to construct a regular mapping.",7,[[["virtualaddress"],["vec",["physicalmemregion"]],["mappingaccessrights"]],["result",["mapping","kernelerror"]]]],[11,"new_shared","","Tries to construct a shared mapping.",7,[[["virtualaddress"],["arc",["vec"]],["mappingaccessrights"]],["result",["mapping","kernelerror"]]]],[11,"new_guard","","Tries to construct a guarded mapping.",7,[[["virtualaddress"],["usize"]],["result",["mapping","kernelerror"]]]],[11,"new_available","","Tries to construct an available mapping.",7,[[["virtualaddress"],["usize"]],["result",["mapping","kernelerror"]]]],[11,"new_system_reserved","","Tries to construct a system reserved mapping.",7,[[["virtualaddress"],["usize"]],["result",["mapping","kernelerror"]]]],[11,"address","","Returns the address of this mapping.",7,[[["self"]],["virtualaddress"]]],[11,"length","","Returns the address of this mapping.",7,[[["self"]],["usize"]]],[11,"mtype_ref","","Returns a reference to the type of this mapping.",7,[[["self"]],["mappingtype"]]],[11,"mtype","","Returns the type of this mapping.",7,[[["self"]],["mappingtype"]]],[11,"flags","","Returns the type of this mapping.",7,[[["self"]],["mappingaccessrights"]]],[0,"cross_process","kfs_kernel::paging","Cross Process Mapping",N,N],[3,"CrossProcessMapping","kfs_kernel::paging::cross_process","A struct representing a UserLand mapping temporarily…",N,N],[12,"kernel_address","","The KernelLand address it was remapped to. Has the desired…",9,N],[12,"len","","Stores the desired length.",9,N],[12,"mapping","","The mapping we remapped from.",9,N],[11,"mirror_mapping","","Creates a `CrossProcessMapping`.",9,[[["mapping"],["usize"],["usize"]],["result",["crossprocessmapping","kernelerror"]]]],[11,"addr","","The address of the region asked to be remapped.",9,[[["self"]],["virtualaddress"]]],[11,"len","","The length of the region asked to be remapped.",9,[[["self"]],["usize"]]],[0,"error","kfs_kernel::paging","Errors specific to memory management",N,N],[4,"MmError","kfs_kernel::paging::error","An error related to Memory Management",N,N],[13,"OccupiedMapping","","",10,N],[12,"address","kfs_kernel::paging::error::MmError","",10,N],[12,"length","","",10,N],[12,"backtrace","","",10,N],[13,"DoesNotSpanMapping","kfs_kernel::paging::error","",10,N],[12,"address","kfs_kernel::paging::error::MmError","",10,N],[12,"length","","",10,N],[12,"backtrace","","",10,N],[13,"SpansSeveralMappings","kfs_kernel::paging::error","",10,N],[12,"address","kfs_kernel::paging::error::MmError","",10,N],[12,"length","","",10,N],[12,"backtrace","","",10,N],[13,"WasAvailable","kfs_kernel::paging::error","",10,N],[12,"address","kfs_kernel::paging::error::MmError","",10,N],[12,"backtrace","","",10,N],[13,"SharedMapping","kfs_kernel::paging::error","",10,N],[12,"backtrace","kfs_kernel::paging::error::MmError","",10,N],[13,"InvalidMapping","kfs_kernel::paging::error","",10,N],[12,"backtrace","kfs_kernel::paging::error::MmError","",10,N],[13,"ThisWillNeverHappenButPleaseDontMatchExhaustively","kfs_kernel::paging::error","",10,N],[17,"_DERIVE_failure_Fail_FOR_MmError","","",N,N],[17,"_DERIVE_failure_core_fmt_Display_FOR_MmError","","",N,N],[0,"hierarchical_table","kfs_kernel::paging","Arch-independent traits for architectures that implement…",N,N],[3,"NoFlush","kfs_kernel::paging::hierarchical_table","Flusher that doesn't flush.",N,N],[3,"SmartHierarchicalTable","","This is just a wrapper for a pointer to a table. It…",N,N],[12,"0","","",11,N],[12,"1","","",11,N],[4,"PageState","","A hierarchical paging is composed of entries. An entry can…",N,N],[13,"Available","","Available, aka unused. Will page fault on use.",1,N],[13,"Guarded","","Guarded. Reserved and will cause a pagefault on use. Used…",1,N],[13,"Present","","Present. Used and has a backing physical address.",1,N],[8,"HierarchicalEntry","","A hierarchical paging is composed of entries. All entries…",N,N],[16,"EntryFlagsType","","An entry comports some flags. They are often represented…",12,N],[10,"is_unused","","Is the entry unused ?",12,[[["self"]],["bool"]]],[10,"set_unused","","Clear the entry",12,[[["self"]],["pagestate",["physicaladdress"]]]],[10,"is_guard","","Is the entry a page guard ?",12,[[["self"]],["bool"]]],[10,"flags","","Get the current entry flags",12,N],[10,"pointed_frame","","Get the associated physical address, if available",12,[[["self"]],["pagestate",["physicaladdress"]]]],[10,"set","","Sets the entry",12,N],[10,"set_guard","","Make this entry a page guard",12,[[["self"]]]],[8,"HierarchicalTable","","A hierarchical paging is composed of tables. All tables…",N,N],[16,"EntryType","","The Entry our table has",13,N],[16,"CacheFlusherType","","A Flusher that should be called on table modifications",13,N],[16,"ChildTableType","","If we're a parent table, the type of our child tables. If…",13,N],[10,"entries","","gets the raw array of entries",13,N],[11,"zero","","zero out the whole table",13,[[["self"]]]],[11,"guard_all_entries","","Makes all entries guarded",13,[[["self"]]]],[11,"map_nth_entry","","Creates a mapping on the nth entry of a table",13,N],[11,"guard_nth_entry","","Marks the nth entry as guard page",13,[[["self"],["usize"]]]],[11,"unmap_nth_entry","","Marks the nth entry as guard page",13,[[["self"],["usize"]]]],[10,"table_level","","Called to check if this table's entries should be treated…",13,[[],["usize"]]],[11,"entry_vm_size","","the size an entry in this table spans in virtual memory.…",13,[[],["usize"]]],[10,"get_child_table","","Gets a reference to a child page table.",13,[[["self"],["usize"]],["pagestate",["smarthierarchicaltable"]]]],[10,"create_child_table","","Allocates a child page table, zero it and add an entry…",13,[[["self"],["usize"]],["smarthierarchicaltable"]]],[11,"get_child_table_or_create","","Gets the child page table at given index, or creates it if…",13,[[["self"],["usize"]],["pagestate",["smarthierarchicaltable"]]]],[8,"PagingCacheFlusher","","Most implementations of paging have are accelerated with a…",N,N],[10,"flush_whole_cache","","Flushes the whole cache.",14,[[]]],[8,"TableHierarchy","","A trait operating on a whole hierarchy of tables.",N,N],[16,"TopLevelTableType","","The type of the top level table.",15,N],[10,"get_top_level_table","","Gets a reference to the top level table, either through…",15,[[["self"]],["smarthierarchicaltable"]]],[11,"map_to_from_iterator","","Creates a mapping in the page tables with the given flags.",15,[[["self"],["i"],["virtualaddress"],["mappingaccessrights"]]]],[11,"guard","","Creates a span of guard pages",15,[[["self"],["virtualaddress"],["usize"]]]],[11,"unmap","","Unmaps a range of virtual address. On every frames mapped…",15,[[["self"],["virtualaddress"],["usize"],["c"]]]],[11,"for_every_entry","","Iters in the page tables, applying closure on every…",15,[[["self"],["virtualaddress"],["usize"],["c"]]]],[11,"find_available_virtual_space_aligned","","Finds a virtual space hole that is at least length long,…",15,[[["self"],["usize"],["virtualaddress"],["virtualaddress"],["usize"]],["option",["virtualaddress"]]]],[8,"InactiveHierarchyTrait","","A trait implemented by innactive table hierarchies.…",N,N],[10,"new","","Creates a hierarchy. Allocates at least a top level…",16,[[],["self"]]],[10,"switch_to","","Switches to this hierarchy,",16,[[["self"]]]],[11,"destroy","","De-allocates all physical memory used by tables of this…",16,[[["self"]]]],[10,"copy_active_kernel_space","","Performs a shallow copy of the top level-directory section…",16,[[["self"]]]],[10,"is_currently_active","","Checks if this inactive hierarchy is actually the…",16,[[["self"]],["bool"]]],[10,"from_currently_active","","Returns the currently active hierarchy as an inactive…",16,[[],["self"]]],[11,"unwrap","kfs_kernel::paging","Move the value T out of the PageState if it is Present(T).",1,[[["self"]],["t"]]],[11,"map","","Maps a PageState to PageState by applying a function to a…",1,[[["self"],["f"]],["pagestate"]]],[11,"as_option","","Turns the PageState into an Option, setting both Guarded…",1,[[["self"]],["option"]]],[11,"new","kfs_kernel::paging::hierarchical_table","Wraps the given pointer in a `SmartHierarchicalTable`.",11,N],[0,"arch","kfs_kernel::paging","Arch-specific implementations of paging",N,N],[0,"i386","kfs_kernel::paging::arch","Paging implementation on i386",N,N],[5,"is_paging_on","kfs_kernel::paging::arch::i386","Check if the paging is currently active.",N,[[],["bool"]]],[5,"enable_paging","","Not used anymore, bootstrap's job",N,[[["physicaladdress"]]]],[5,"flush_tlb","","Flush the Translation Lookaside Buffer…",N,[[]]],[5,"swap_cr3","","Changes the content of the cr3 register, and returns the…",N,[[["physicaladdress"]],["physicaladdress"]]],[5,"read_cr3","","Reads the value of cr3, retrieving the current page…",N,[[],["physicaladdress"]]],[5,"read_cr2","","Reads the value of cr2, retrieving the address that caused…",N,[[],["virtualaddress"]]],[0,"entry","","i386 page table entry",N,N],[3,"I386EntryFlags","kfs_kernel::paging::arch::i386::entry","The flags of a table entry",N,N],[12,"bits","","",17,N],[3,"I386Entry","","An entry in a page table or page directory. An unused…",N,N],[12,"0","","",18,N],[17,"ENTRY_PHYS_ADDRESS_MASK","","The part of an entry that encodes the physical address.",N,N],[18,"PRESENT","","",17,N],[18,"WRITABLE","","",17,N],[18,"USER_ACCESSIBLE","","",17,N],[18,"WRITE_THROUGH","","",17,N],[18,"NO_CACHE","","",17,N],[18,"ACCESSED","","",17,N],[18,"DIRTY","","",17,N],[18,"HUGE_PAGE","","",17,N],[18,"GLOBAL","","",17,N],[18,"GUARD_PAGE","","",17,N],[18,"USER_DEFINED_2","","",17,N],[18,"USER_DEFINED_3","","",17,N],[11,"empty","","Returns an empty set of flags.",17,[[],["i386entryflags"]]],[11,"all","","Returns the set containing all flags.",17,[[],["i386entryflags"]]],[11,"bits","","Returns the raw value of the flags currently stored.",17,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",17,[[["u32"]],["option",["i386entryflags"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",17,[[["u32"]],["i386entryflags"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",17,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",17,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",17,[[["self"],["i386entryflags"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",17,[[["self"],["i386entryflags"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",17,[[["self"],["i386entryflags"]]]],[11,"remove","","Removes the specified flags in-place.",17,[[["self"],["i386entryflags"]]]],[11,"toggle","","Toggles the specified flags in-place.",17,[[["self"],["i386entryflags"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",17,[[["self"],["i386entryflags"],["bool"]]]],[0,"table","kfs_kernel::paging::arch::i386","i386 Page Tables hierarchy",N,N],[3,"Table","kfs_kernel::paging::arch::i386::table","A page table or directory in memory.",N,N],[12,"entries","","The array of entries making up this table.",19,N],[3,"ActivePageTable","","A currently active page table.",N,N],[12,"0","","",20,N],[3,"ActivePageDirectory","","A currently active page directory.",N,N],[12,"0","","",21,N],[3,"ActiveHierarchy","","The currently active hierarchy of directory and tables.…",N,N],[3,"InactivePageTable","","A currently inactive page table.",N,N],[12,"0","","",22,N],[3,"InactivePageDirectory","","A currently inactive page directory.",N,N],[12,"0","","",23,N],[3,"InactiveHierarchy","","A currently inactive hierarchy of directory and tables.",N,N],[12,"directory_physical_address","","The address we must put in cr3 to switch to these pages.",24,N],[3,"TlbFlush","","When passing this struct the TLB will be flushed. Used by…",N,N],[17,"DIRECTORY_RECURSIVE_ADDRESS","","When paging is on, accessing this address loops back to…",N,N],[11,"get_table_address","","reduce recursive mapping by one time to get further down…",21,[[["self"],["usize"]],["pagestate",["usize"]]]],[17,"PAGE_SIZE","kfs_kernel::paging::arch::i386","The page size. Dictated by the MMU. In simple, elegant,…",N,N],[17,"ENTRY_COUNT","","The number of entries a page table has. On i386 a page…",N,N],[0,"bookkeeping","kfs_kernel::paging","Bookkeeping of mappings in UserLand",N,N],[3,"UserspaceBookkeeping","kfs_kernel::paging::bookkeeping","A bookkeeping is just a list of Mappings",N,N],[12,"mappings","","The list of mappings of this process.",25,N],[4,"QueryMemory","","Because we do not store Available mappings internally, we…",N,N],[13,"Available","","The address fell in an available range.",3,N],[13,"Used","","The address fell in an existing mapping.",3,N],[11,"mapping","kfs_kernel::paging::process_memory","Returns a reference to the underlying mapping.",3,[[["self"]],["mapping"]]],[11,"new","kfs_kernel::paging::bookkeeping","Constructs a UserspaceBookkeeping",25,[[],["self"]]],[11,"mapping_at_or_following","","Returns the mapping `address` falls into, or if it is…",25,[[["self"],["virtualaddress"]],["option",["mapping"]]]],[11,"mapping_at_or_preceding","","Returns the mapping `address` falls into, or if it is…",25,[[["self"],["virtualaddress"]],["option",["mapping"]]]],[11,"mapping_at","","Returns the mapping `address` falls into.",25,[[["self"],["virtualaddress"]],["querymemory"]]],[11,"occupied_mapping_at","","Returns the mapping `address` falls into.",25,[[["self"],["virtualaddress"]],["result",["mapping","kernelerror"]]]],[11,"is_vacant","","Checks that a given range is unoccupied.",25,[[["self"],["virtualaddress"],["usize"]],["result",["bool","kernelerror"]]]],[11,"check_vacant","","Asserts that a given range is unoccupied",25,[[["self"],["virtualaddress"],["usize"]],["result",["kernelerror"]]]],[11,"add_mapping","","Adds a mapping to the list of tracked mappings",25,[[["self"],["mapping"]],["result",["kernelerror"]]]],[11,"remove_mapping","","Removes a mapping from the tracked mappings, and returns it.",25,[[["self"],["virtualaddress"],["usize"]],["result",["mapping","kernelerror"]]]],[11,"remove_mapping_split","","Removes part of a mapping from the tracked mappings, and…",25,[[["self"],["virtualaddress"],["usize"]],["result",["mapping","kernelerror"]]]],[11,"find_available_space","","Finds a hole in virtual space at least `length` long.",25,[[["self"],["usize"]],["result",["virtualaddress","kernelerror"]]]],[17,"PAGE_SIZE","kfs_kernel::paging","The page size. Dictated by the MMU. In simple, elegant,…",N,N],[18,"READABLE","","Mapping is readable.",0,N],[18,"WRITABLE","","Mapping is writable.",0,N],[18,"EXECUTABLE","","Mapping is executable.",0,N],[18,"USER_ACCESSIBLE","","Mapping can be accessed from userland, with the same…",0,N],[11,"empty","","Returns an empty set of flags.",0,[[],["mappingaccessrights"]]],[11,"all","","Returns the set containing all flags.",0,[[],["mappingaccessrights"]]],[11,"bits","","Returns the raw value of the flags currently stored.",0,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",0,[[["u32"]],["option",["mappingaccessrights"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",0,[[["u32"]],["mappingaccessrights"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",0,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",0,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",0,[[["self"],["mappingaccessrights"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",0,[[["self"],["mappingaccessrights"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",0,[[["self"],["mappingaccessrights"]]]],[11,"remove","","Removes the specified flags in-place.",0,[[["self"],["mappingaccessrights"]]]],[11,"toggle","","Toggles the specified flags in-place.",0,[[["self"],["mappingaccessrights"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",0,[[["self"],["mappingaccessrights"],["bool"]]]],[11,"k_r","","Shorthand for READABLE",0,[[],["mappingaccessrights"]]],[11,"k_w","","Shorthand for WRITABLE",0,[[],["mappingaccessrights"]]],[11,"k_rw","","Shorthand for READABLE | WRITABLE",0,[[],["mappingaccessrights"]]],[11,"k_rx","","Shorthand for READABLE | EXECUTABLE",0,[[],["mappingaccessrights"]]],[11,"u_r","","Shorthand for USER_ACCESSIBLE | READABLE",0,[[],["mappingaccessrights"]]],[11,"u_w","","Shorthand for USER_ACCESSIBLE | WRITABLE",0,[[],["mappingaccessrights"]]],[11,"u_rw","","Shorthand for USER_ACCESSIBLE | WRITABLE",0,[[],["mappingaccessrights"]]],[11,"u_rx","","Shorthand for USER_ACCESSIBLE | WRITABLE",0,[[],["mappingaccessrights"]]],[0,"event","kfs_kernel","The core event handling primitives of KFS.",N,N],[3,"IRQEvent","kfs_kernel::event","An event waiting for an IRQ.",N,N],[12,"state","","The global state of the IRQ this event is listening on.…",26,N],[12,"ack","","Acknowledgement counter for this IRQEvent instance. Each…",26,N],[3,"IRQState","","Global state of an IRQ.",N,N],[12,"irqnum","","The irq number this state represents. Only used for debug…",27,N],[12,"counter","","The number of time this IRQ was triggered from kernel boot.",27,N],[12,"waiting_processes","","List of processes waiting on this IRQ. When this IRQ is…",27,N],[5,"wait","","Waits for an event to occur on one of the given Waitable…",N,[[["intoiter"]],["result",["waitable","userspaceerror"]]]],[5,"dispatch_event","","Signal the scheduler and waiters that an IRQ has been…",N,[[["usize"]]]],[5,"wait_event","","Creates an IRQEvent waiting for the given IRQ number.",N,[[["usize"]],["irqevent"]]],[7,"IRQ_STATES","","Global state for all the IRQ handled by the PIC.",N,N],[8,"Waitable","","A waitable item.",N,N],[10,"is_signaled","","Checks whether the Waitable was signalled.",28,[[["self"]],["bool"]]],[10,"register","","Register the waitable with the scheduler.",28,[[["self"]]]],[11,"new","","Create a new IRQState for the given IRQ number, with the…",27,[[["usize"]],["irqstate"]]],[0,"error","kfs_kernel","UserspaceError and KernelError",N,N],[3,"UserspaceError","kfs_kernel::error","Kernel syscall error codes.",N,N],[12,"0","","",29,N],[4,"ArithmeticOperation","","",N,N],[13,"Add","","",30,N],[13,"Sub","","",30,N],[13,"Mul","","",30,N],[13,"Div","","",30,N],[13,"Mod","","",30,N],[13,"Pow","","",30,N],[4,"KernelError","","Kernel Error.",N,N],[13,"PhysicalMemoryExhaustion","","",31,N],[12,"backtrace","kfs_kernel::error::KernelError","",31,N],[13,"VirtualMemoryExhaustion","kfs_kernel::error","",31,N],[12,"backtrace","kfs_kernel::error::KernelError","",31,N],[13,"InvalidAddress","kfs_kernel::error","",31,N],[12,"address","kfs_kernel::error::KernelError","",31,N],[12,"length","","",31,N],[12,"backtrace","","",31,N],[13,"InvalidSize","kfs_kernel::error","",31,N],[12,"size","kfs_kernel::error::KernelError","",31,N],[12,"backtrace","","",31,N],[13,"AlignmentError","kfs_kernel::error","",31,N],[12,"given","kfs_kernel::error::KernelError","",31,N],[12,"needed","","",31,N],[12,"backtrace","","",31,N],[13,"WouldOverflow","kfs_kernel::error","",31,N],[12,"lhs","kfs_kernel::error::KernelError","",31,N],[12,"rhs","","",31,N],[12,"operation","","",31,N],[12,"backtrace","","",31,N],[13,"ZeroLengthError","kfs_kernel::error","",31,N],[12,"backtrace","kfs_kernel::error::KernelError","",31,N],[13,"MmError","kfs_kernel::error","",31,N],[13,"ProcessKilled","","",31,N],[12,"backtrace","kfs_kernel::error::KernelError","",31,N],[13,"ThreadAlreadyStarted","kfs_kernel::error","",31,N],[12,"backtrace","kfs_kernel::error::KernelError","",31,N],[13,"InvalidCombination","kfs_kernel::error","",31,N],[12,"backtrace","kfs_kernel::error::KernelError","",31,N],[13,"ExceedingMaximum","kfs_kernel::error","",31,N],[12,"value","kfs_kernel::error::KernelError","",31,N],[12,"maximum","","",31,N],[12,"backtrace","","",31,N],[13,"InvalidKernelCaps","kfs_kernel::error","",31,N],[12,"kcap","kfs_kernel::error::KernelError","",31,N],[12,"backtrace","","",31,N],[13,"ReservedValue","kfs_kernel::error","",31,N],[12,"backtrace","kfs_kernel::error::KernelError","",31,N],[13,"ThisWillNeverHappenButPleaseDontMatchExhaustively","kfs_kernel::error","",31,N],[17,"_DERIVE_failure_Fail_FOR_KernelError","","",N,N],[17,"_DERIVE_failure_core_fmt_Display_FOR_KernelError","","",N,N],[0,"log_impl","kfs_kernel","A simple log implementation based on env_logger",N,N],[3,"Logger","kfs_kernel::log_impl","",N,N],[12,"filter","","",32,N],[5,"early_init","","Initializes the Logger in a heapless environment.",N,[[]]],[5,"init","","Reinitializes the logger using the cmdline. This requires…",N,[[]]],[0,"filter","","Filtering for log records.",N,N],[3,"Filter","kfs_kernel::log_impl::filter","A log filter.",N,N],[12,"directives","","",33,N],[12,"filter","","",33,N],[3,"Builder","","A builder for a log filter.",N,N],[12,"directives","","",34,N],[12,"filter","","",34,N],[3,"Directive","","",N,N],[12,"name","","",35,N],[12,"level","","",35,N],[5,"parse_spec","","Parse a logging specification string (e.g:…",N,N],[5,"enabled","","",N,N],[0,"inner","","",N,N],[3,"Filter","kfs_kernel::log_impl::filter::inner","",N,N],[12,"inner","","",36,N],[11,"new","","",36,[[["str"]],["result",["filter","string"]]]],[11,"is_match","","",36,[[["self"],["str"]],["bool"]]],[11,"filter","kfs_kernel::log_impl::filter","Returns the maximum `LevelFilter` that this filter…",33,[[["self"]],["levelfilter"]]],[11,"matches","","Checks if this record matches the configured filter.",33,[[["self"],["record"]],["bool"]]],[11,"enabled","","Determines if a log message with the specified metadata…",33,[[["self"],["metadata"]],["bool"]]],[11,"new","","Initializes the filter builder with defaults.",34,[[],["builder"]]],[11,"filter_module","","Initializes the filter builder from an environment. Adds a…",34,[[["self"],["str"],["levelfilter"]],["self"]]],[11,"filter_level","","Adds a directive to the filter for all modules.",34,[[["self"],["levelfilter"]],["self"]]],[11,"filter","","Adds a directive to the filter.",34,[[["self"],["option",["str"]],["levelfilter"]],["self"]]],[11,"parse","","Parses the directives string.",34,[[["self"],["str"]],["self"]]],[11,"build","","Build a log filter.",34,[[["self"]],["filter"]]],[7,"LOGGER","kfs_kernel::log_impl","",N,N],[0,"i386","kfs_kernel","This crate is x86_64's little brother. It provides i386…",N,N],[3,"TssStruct","kfs_kernel::i386","The Task State Segment (TSS) is a special data structure…",N,N],[12,"link","","",37,N],[12,"_reserved1","","",37,N],[12,"esp0","","",37,N],[12,"ss0","","",37,N],[12,"_reserved2","","",37,N],[12,"esp1","","",37,N],[12,"ss1","","",37,N],[12,"_reserved3","","",37,N],[12,"esp2","","",37,N],[12,"ss2","","",37,N],[12,"_reserved4","","",37,N],[12,"cr3","","",37,N],[12,"eip","","",37,N],[12,"eflags","","",37,N],[12,"eax","","",37,N],[12,"ecx","","",37,N],[12,"edx","","",37,N],[12,"ebx","","",37,N],[12,"esp","","",37,N],[12,"ebp","","",37,N],[12,"esi","","",37,N],[12,"edi","","",37,N],[12,"es","","",37,N],[12,"_reserved5","","",37,N],[12,"cs","","",37,N],[12,"_reserved6","","",37,N],[12,"ss","","",37,N],[12,"_reserved7","","",37,N],[12,"ds","","",37,N],[12,"_reserved8","","",37,N],[12,"fs","","",37,N],[12,"_reserved9","","",37,N],[12,"gs","","",37,N],[12,"_reserveda","","",37,N],[12,"ldt_selector","","",37,N],[12,"_reservedb","","",37,N],[12,"_reservedc","","",37,N],[12,"iopboffset","","",37,N],[3,"AlignedTssStruct","","Wrapper around TssStruct ensuring it is kept at the page…",N,N],[12,"0","","",38,N],[4,"PrivilegeLevel","","Represents a protection ring level.",N,N],[13,"Ring0","","Privilege-level 0 (most privilege): This level is used by…",39,N],[13,"Ring1","","Privilege-level 1 (moderate privilege): This level is used…",39,N],[13,"Ring2","","Privilege-level 2 (moderate privilege): Like level 1, this…",39,N],[13,"Ring3","","Privilege-level 3 (least privilege): This level is used by…",39,N],[5,"tss_struct_size","","",N,[[]]],[0,"registers","","i386 registers reading",N,N],[5,"eip","kfs_kernel::i386::registers","Gets the current $eip.",N,[[],["usize"]]],[0,"eflags","","Processor state stored in the EFLAGS register.",N,N],[3,"EFlags","kfs_kernel::i386::registers::eflags","The EFLAGS register.",N,N],[12,"bits","","",40,N],[5,"read","","Returns the current value of the EFLAGS register.",N,[[],["eflags"]]],[5,"read_raw","","Returns the raw current value of the EFLAGS register.",N,[[],["u32"]]],[5,"write","","Writes the EFLAGS register, preserves reserved bits.",N,[[["eflags"]]]],[5,"write_raw","","Writes the EFLAGS register.",N,[[["u32"]]]],[18,"ID","","Processor feature identification flag.",40,N],[18,"VIRTUAL_INTERRUPT_PENDING","","Indicates that an external, maskable interrupt is pending.",40,N],[18,"VIRTUAL_INTERRUPT","","Virtual image of the INTERRUPT_FLAG bit.",40,N],[18,"ALIGNMENT_CHECK","","Enable automatic alignment checking if CR0.AM is set. Only…",40,N],[18,"VIRTUAL_8086_MODE","","Enable the virtual-8086 mode.",40,N],[18,"RESUME_FLAG","","Allows to restart an instruction following an instrucion…",40,N],[18,"NESTED_TASK","","Used by `iret` in hardware task switch mode to determine…",40,N],[18,"IOPL_HIGH","","The high bit of the I/O Privilege Level field.",40,N],[18,"IOPL_LOW","","The low bit of the I/O Privilege Level field.",40,N],[18,"OVERFLOW_FLAG","","Set by hardware to indicate that the sign bit of the…",40,N],[18,"DIRECTION_FLAG","","Determines the order in which strings are processed.",40,N],[18,"INTERRUPT_FLAG","","Enable interrupts.",40,N],[18,"TRAP_FLAG","","Enable single-step mode for debugging.",40,N],[18,"SIGN_FLAG","","Set by hardware if last arithmetic operation resulted in a…",40,N],[18,"ZERO_FLAG","","Set by hardware if last arithmetic operation resulted in a…",40,N],[18,"AUXILIARY_CARRY_FLAG","","Set by hardware if last arithmetic operation generated a…",40,N],[18,"PARITY_FLAG","","Set by hardware if last result has an even number of 1…",40,N],[18,"CARRY_FLAG","","Set by hardware if last arithmetic operation generated a…",40,N],[11,"empty","","Returns an empty set of flags.",40,[[],["eflags"]]],[11,"all","","Returns the set containing all flags.",40,[[],["eflags"]]],[11,"bits","","Returns the raw value of the flags currently stored.",40,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",40,[[["u32"]],["option",["eflags"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",40,[[["u32"]],["eflags"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",40,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",40,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",40,[[["self"],["eflags"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",40,[[["self"],["eflags"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",40,[[["self"],["eflags"]]]],[11,"remove","","Removes the specified flags in-place.",40,[[["self"],["eflags"]]]],[11,"toggle","","Toggles the specified flags in-place.",40,[[["self"],["eflags"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",40,[[["self"],["eflags"],["bool"]]]],[0,"stack","kfs_kernel::i386","Kernel stack",N,N],[3,"KernelStack","kfs_kernel::i386::stack","A structure representing a kernel stack.",N,N],[12,"stack_address","","The aligned address at the beginning of the stack.",41,N],[3,"StackDumpSource","","The minimal information needed to perform a stack dump.",N,N],[12,"esp","","The initial top of the stack.",42,N],[12,"ebp","","The initial bottom of the first stack frame.",42,N],[12,"eip","","The initial pc.",42,N],[5,"dump_stack","","Dumps the stack from the given information, displaying it…",N,[[["stackdumpsource"],["option"]]]],[5,"dump_stack_from_slice","","Dumps a stack, displaying it in a frame-by-frame format.",N,N],[17,"STACK_SIZE","","The size of a kernel stack in pages, not accounting for…",N,N],[17,"STACK_SIZE_WITH_GUARD","","The size of a kernel stack in pages, with the page guard.",N,N],[17,"STACK_ALIGNMENT","","The alignment of the stack.…",N,N],[11,"allocate_stack","","Allocates the kernel stack of a process.",41,[[],["result",["kernelstack","kernelerror"]]]],[11,"align_to_stack_bottom","","Aligns down a pointer to what would be the beginning of…",41,[[["usize"]],["usize"]]],[11,"get_current_stack_bottom","","Gets the bottom of the stack by `and`ing `$esp` with…",41,[[],["usize"]]],[11,"get_current_stack","","Retrieves the current stack from `$esp`.",41,[[],["kernelstack"]]],[18,"STACK_POISON_SIZE","","We keep 2 poison pointers for fake `saved ebp` and `saved…",41,N],[11,"create_poison_pointers","","Puts two poisons pointers at the base of the stack for the…",41,[[["self"]]]],[11,"get_stack_start","","Get the address of the beginning of usable stack.",41,[[["self"]],["usize"]]],[11,"dump_current_stack","","Dumps the stack, displaying it in a frame-by-frame format.",41,[[["option"]]]],[11,"new","","Creates a StackDumpSource from :",42,[[["usize"],["usize"],["usize"]],["self"]]],[0,"multiboot","kfs_kernel::i386","Multiboot Information",N,N],[5,"get_boot_information","kfs_kernel::i386::multiboot","Get a pointer to the multiboot information structure.",N,[[],["bootinformation"]]],[5,"try_get_boot_information","","Tries to get a pointer to the multiboot information…",N,[[],["option",["bootinformation"]]]],[5,"init","","Initializes the boot information module, allowing the…",N,[[["bootinformation"]]]],[7,"BOOT_INFO","","Stores the address of the multiboot.",N,N],[0,"structures","kfs_kernel::i386","Representations of various x86 specific structures and…",N,N],[0,"gdt","kfs_kernel::i386::structures","Types for the Global Descriptor Table and segment selectors.",N,N],[3,"SegmentSelector","kfs_kernel::i386::structures::gdt","Specifies which element to load into a segment from…",N,N],[12,"0","","",43,N],[11,"new","","Creates a new SegmentSelector",43,[[["u16"],["privilegelevel"]],["segmentselector"]]],[11,"index","","Returns the GDT index.",43,[[["self"]],["u16"]]],[11,"rpl","","Returns the requested privilege level.",43,[[["self"]],["privilegelevel"]]],[11,"is_ldt","","If true, this descriptor is backed by the LDT. If false,…",43,[[["self"]],["bool"]]],[0,"idt","kfs_kernel::i386::structures","Provides types for the Interrupt Descriptor Table and its…",N,N],[3,"Idt","kfs_kernel::i386::structures::idt","An Interrupt Descriptor Table with 256 entries.",N,N],[12,"divide_by_zero","","A divide by zero exception (`#DE`) occurs when the…",44,N],[12,"debug","","When the debug-exception mechanism is enabled, a `#DB`…",44,N],[12,"non_maskable_interrupt","","An non maskable interrupt exception (NMI) occurs as a…",44,N],[12,"breakpoint","","A breakpoint (`#BP`) exception occurs when an `INT3`…",44,N],[12,"overflow","","An overflow exception (`#OF`) occurs as a result of…",44,N],[12,"bound_range_exceeded","","A bound-range exception (`#BR`) exception can occur as a…",44,N],[12,"invalid_opcode","","An invalid opcode exception (`#UD`) occurs when an attempt…",44,N],[12,"device_not_available","","A device not available exception (`#NM`) occurs under any…",44,N],[12,"double_fault","","A double fault (`#DF`) exception can occur when a second…",44,N],[12,"coprocessor_segment_overrun","","This interrupt vector is reserved. It is for a…",44,N],[12,"invalid_tss","","An invalid TSS exception (`#TS`) occurs only as a result…",44,N],[12,"segment_not_present","","An segment-not-present exception (`#NP`) occurs when an…",44,N],[12,"stack_segment_fault","","An stack segment exception (`#SS`) can occur in the…",44,N],[12,"general_protection_fault","","A general protection fault (`#GP`) can occur in various…",44,N],[12,"page_fault","","A page fault (`#PF`) can occur during a memory access in…",44,N],[12,"reserved_1","","vector nr. 15",44,N],[12,"x87_floating_point","","The x87 Floating-Point Exception-Pending exception (`#MF`)…",44,N],[12,"alignment_check","","An alignment check exception (`#AC`) occurs when an…",44,N],[12,"machine_check","","The machine check exception (`#MC`) is model specific.…",44,N],[12,"simd_floating_point","","The SIMD Floating-Point Exception (`#XF`) is used to…",44,N],[12,"virtualization","","vector nr. 20",44,N],[12,"reserved_2","","vector nr. 21-29",44,N],[12,"security_exception","","The Security Exception (`#SX`) signals security-sensitive…",44,N],[12,"reserved_3","","vector nr. 31",44,N],[12,"interrupts","","User-defined interrupts can be initiated either by system…",44,N],[3,"IdtEntry","","An Interrupt Descriptor Table entry.",N,N],[12,"pointer_low","","Low word of the interrupt handler's virtual address. In an…",45,N],[12,"gdt_selector","","A segment selector.",45,N],[12,"zero","","Unused.",45,N],[12,"options","","Option bitfield.",45,N],[12,"pointer_high","","High word of the interrupt handler's virtual address.",45,N],[12,"phantom","","Type-safety guarantee: ensure that the function handler…",45,N],[3,"EntryOptions","","Represents the options field of an IDT entry.",N,N],[12,"0","","",46,N],[3,"ExceptionStackFrame","","Represents the exception stack frame pushed by the CPU on…",N,N],[12,"instruction_pointer","","This value points to the instruction that should be…",47,N],[12,"code_segment","","The code segment selector, padded with zeros.",47,N],[12,"cpu_flags","","The flags register before the interrupt handler was invoked.",47,N],[12,"stack_pointer","","The stack pointer at the time of the interrupt.",47,N],[12,"stack_segment","","The stack segment descriptor at the time of the interrupt…",47,N],[3,"PageFaultErrorCode","","Describes an page fault error code.",N,N],[12,"bits","","",48,N],[4,"GateType","","Represents the type of an IDT descriptor (called a gate).",N,N],[13,"TaskGate32","","",49,N],[13,"InterruptGate16","","",49,N],[13,"TrapGate16","","",49,N],[13,"InterruptGate32","","",49,N],[13,"TrapGate32","","",49,N],[5,"const_assert_idt","","",N,[[]]],[5,"const_assert_idtentry","","",N,[[]]],[6,"HandlerFunc","","A handler function for an interrupt or an exception…",N,N],[6,"HandlerFuncWithErrCode","","A handler function for an exception that pushes an error…",N,N],[6,"PageFaultHandlerFunc","","A page fault handler function that pushes a page fault…",N,N],[11,"init","","Creates a new IDT filled with non-present entries.",44,[[["self"]]]],[11,"load","","Loads the IDT in the CPU using the `lidt` command.",44,[[["self"]]]],[11,"missing","","Creates a non-present IDT entry (but sets the must-be-one…",45,[[],["self"]]],[11,"set_interrupt_gate_addr","","Set an interrupt gate function for the IDT entry and sets…",45,[[["self"],["u32"]],["entryoptions"]]],[11,"set_handler_task_gate_addr","","Set a task gate for the IDT entry and sets the present bit.",45,[[["self"],["u32"]]]],[11,"set_handler_fn","","Set an interrupt gate function for the IDT entry and sets…",45,[[["self"],["handlerfunc"]],["entryoptions"]]],[11,"set_task_fn","","Set a task gate function for the IDT entry and sets the…",45,[[["self"],["handlerfunc"]]]],[11,"set_handler_fn","","Set an interrupt gate function for the IDT entry and sets…",45,[[["self"],["handlerfuncwitherrcode"]],["entryoptions"]]],[11,"set_task_fn","","Set a task gate function for the IDT entry and sets the…",45,[[["self"],["handlerfuncwitherrcode"]]]],[11,"set_handler_fn","","Set an interrupt gate function for the IDT entry and sets…",45,[[["self"],["pagefaulthandlerfunc"]],["entryoptions"]]],[11,"set_task_fn","","Set a task gate function for the IDT entry and sets the…",45,[[["self"],["pagefaulthandlerfunc"]]]],[11,"gate_type","","Type of the interrupt handler. Its value determines the…",46,[[["self"]],["gatetype"]]],[11,"privilege_level","","",46,[[["self"]],["privilegelevel"]]],[11,"is_present","","",46,[[["self"]],["bool"]]],[11,"set_is_present","","",46,[[["self"],["bool"]]]],[11,"minimal","","Creates a minimal options field with all the must-be-one…",46,[[],["self"]]],[11,"set_gate_type","","Set the kind of gate this IdtEntry represents.",46,[[["self"],["gatetype"]],["self"]]],[11,"set_privilege_level","","Set the required privilege level (DPL) for invoking the…",46,[[["self"],["privilegelevel"]],["self"]]],[11,"set_present_interrupt","","Set or reset the preset bit.",46,[[["self"],["bool"]],["self"]]],[11,"set_present_task","","Set or reset the preset bit.",46,[[["self"],["bool"]],["self"]]],[11,"disable_interrupts","","Let the CPU disable hardware interrupts when the handler…",46,[[["self"],["bool"]],["self"]]],[18,"PROTECTION_VIOLATION","","If this flag is set, the page fault was caused by a…",48,N],[18,"CAUSED_BY_WRITE","","If this flag is set, the memory access that caused the…",48,N],[18,"USER_MODE","","If this flag is set, an access in user mode (CPL=3) caused…",48,N],[18,"MALFORMED_TABLE","","If this flag is set, the page fault is a result of the…",48,N],[18,"INSTRUCTION_FETCH","","If this flag is set, it indicates that the access that…",48,N],[11,"empty","","Returns an empty set of flags.",48,[[],["pagefaulterrorcode"]]],[11,"all","","Returns the set containing all flags.",48,[[],["pagefaulterrorcode"]]],[11,"bits","","Returns the raw value of the flags currently stored.",48,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",48,[[["u32"]],["option",["pagefaulterrorcode"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",48,[[["u32"]],["pagefaulterrorcode"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",48,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",48,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",48,[[["self"],["pagefaulterrorcode"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",48,[[["self"],["pagefaulterrorcode"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",48,[[["self"],["pagefaulterrorcode"]]]],[11,"remove","","Removes the specified flags in-place.",48,[[["self"],["pagefaulterrorcode"]]]],[11,"toggle","","Toggles the specified flags in-place.",48,[[["self"],["pagefaulterrorcode"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",48,[[["self"],["pagefaulterrorcode"],["bool"]]]],[0,"process_switch","kfs_kernel::i386","Arch-specific process switch functions",N,N],[3,"ThreadHardwareContext","kfs_kernel::i386::process_switch","The hardware context of a paused thread. It contains just…",N,N],[12,"esp","","The top of the stack, where all other registers are saved.",50,N],[5,"process_switch","","Performs the process switch, switching from currently…",N,[[["arc",["threadstruct"]],["arc",["threadstruct"]]],["arc",["threadstruct"]]]],[5,"prepare_for_first_schedule","","Prepares the thread for its first schedule by writing…",N,[[["threadstruct"],["usize"],["usize"]]]],[5,"first_schedule","","The function ret'd on, on a thread's first schedule - as…",N,[[]]],[5,"jump_to_entrypoint","","Jumps to Userspace, and run a userspace program.",N,N],[0,"gdt","kfs_kernel::i386","GDT Handler",N,N],[3,"GdtManager","kfs_kernel::i386::gdt","Safety wrapper that manages the lifetime of GDT tables.",N,N],[12,"unloaded_table","","Inactive descriptor table. Changes to the GDT are done on…",51,N],[3,"MAIN_TASK","","VirtualAddress of the TSS structure of the main task. Has…",N,N],[12,"__private_field","","",52,N],[3,"DescriptorTable","","A structure containing our GDT.",N,N],[12,"table","","The GDT table, a growable array of DescriptorTableEntry.",53,N],[3,"DescriptorTableEntry","","An entry in the GDT/LDT.",N,N],[12,"0","","",54,N],[4,"SystemDescriptorTypes","","Lists the valid values of System Descriptor Types.",N,N],[13,"AvailableTss16","","",55,N],[13,"Ldt","","",55,N],[13,"BusyTss16","","",55,N],[13,"CallGate16","","",55,N],[13,"AvailableTss32","","",55,N],[13,"BusyTss32","","",55,N],[13,"CallGate32","","",55,N],[5,"init_gdt","","Initializes the GDT.",N,[[]]],[5,"push_task_segment","","Push a task segment.",N,[[["tssstruct"]],["segmentselector"]]],[5,"get_main_iopb","","Get the IOPB of the Main Task.",N,N],[7,"GDT","","The global GDT. Needs to be initialized with init_gdt().",N,N],[7,"GLOBAL_LDT","","The global LDT used by all the processes.",N,N],[7,"MAIN_TASK","","",N,N],[11,"load","","Create a GdtManager from a DescriptorTable and segment…",51,[[["descriptortable"],["u16"],["u16"],["u16"]],["gdtmanager"]]],[11,"commit","","Commit the changes in the currently unloaded table.",51,[[["self"],["u16"],["u16"],["u16"]]]],[11,"new","","Create an empty GDT. This will not include the null entry,…",53,[[],["descriptortable"]]],[11,"set_from_loaded","","Fill the current DescriptorTable with a copy of the…",53,[[["self"]]]],[11,"push","","Push a new entry to the table, returning a segment…",53,[[["self"],["descriptortableentry"]],["segmentselector"]]],[11,"load_global","","Load this descriptor table into the GDTR, and set the…",53,[[["self"],["u16"],["u16"],["u16"]],["descriptortablepointer"]]],[11,"null_descriptor","","Returns an empty descriptor. Using this descriptor is an…",54,[[],["descriptortableentry"]]],[11,"new","","Creates an empty GDT descriptor, but with some flags set…",54,[[["u32"],["u32"],["bool"],["privilegelevel"]],["descriptortableentry"]]],[11,"new_system","","Creates an empty GDT system descriptor of the given type.",54,[[["systemdescriptortypes"],["u32"],["u32"],["privilegelevel"]],["descriptortableentry"]]],[11,"new_ldt","","Creates a new LDT descriptor.",54,[[["descriptortable"],["privilegelevel"]],["descriptortableentry"]]],[11,"new_tss","","Creates a GDT descriptor pointing to a TSS segment",54,[[["tssstruct"],["privilegelevel"],["usize"]],["descriptortableentry"]]],[11,"get_limit","","Gets the byte length of the entry, minus 1.",54,[[["self"]],["u32"]]],[11,"set_limit","","Sets the entry's byte length to the given number plus one.…",54,[[["self"],["u32"]]]],[11,"get_base","","Gets the base address of the entry.",54,[[["self"]],["u32"]]],[11,"set_base","","Sets the base address of the entry.",54,[[["self"],["u32"]]]],[11,"get_accessed","","CPU sets this bit to true when the segment is accessed.",54,[[["self"]],["bool"]]],[11,"is_readwrite_allowed","","",54,[[["self"]],["bool"]]],[11,"is_comformant","","",54,[[["self"]],["bool"]]],[11,"is_executable","","Determines whether the segment is a code segment or a data…",54,[[["self"]],["bool"]]],[11,"get_ring_level","","The privilege level associated with this segment.",54,[[["self"]],["privilegelevel"]]],[11,"get_present","","A segment needs to be present to have an effect. Using a…",54,[[["self"]],["bool"]]],[11,"is_4k_granularity","","If true, the limit is a count of 4k pages. If false, it is…",54,[[["self"]],["bool"]]],[11,"set_4k_granularity","","If true, the limit is a count of 4k pages. If false, it is…",54,[[["self"],["bool"]]]],[11,"is_32bit","","If true, this is a 32-bit segment. If false, it is a…",54,[[["self"]],["bool"]]],[0,"pio","kfs_kernel::i386","Port IO",N,N],[3,"Pio","kfs_kernel::i386::pio","Port IO accessor.",N,N],[12,"port","","IO-space address this Pio reads from.",56,N],[12,"value","","The word size of this pointer. Should be u8, u16 or u32.",56,N],[0,"instructions","kfs_kernel::i386","Low level functions for special i386 instructions.",N,N],[0,"tables","kfs_kernel::i386::instructions","Instructions for loading descriptor tables (GDT, IDT, etc.).",N,N],[3,"DescriptorTablePointer","kfs_kernel::i386::instructions::tables","A struct describing a pointer to a descriptor table (GDT /…",N,N],[12,"limit","","Size of the DT.",57,N],[12,"base","","Physical address of the memory region containing the DT.",57,N],[5,"lgdt","","Load GDT table.",N,[[["descriptortablepointer"]]]],[5,"sgdt","","Store GDT table.",N,[[],["descriptortablepointer"]]],[5,"lldt","","Load LDT table.",N,[[["segmentselector"]]]],[5,"ltr","","Sets the task register to the given TSS segment.",N,[[["segmentselector"]]]],[5,"lidt","","Load IDT table.",N,[[["descriptortablepointer"]]]],[0,"segmentation","kfs_kernel::i386::instructions","Provides functions to read and write segment registers.",N,N],[5,"set_cs","kfs_kernel::i386::instructions::segmentation","Reload code segment register. Note this is special since…",N,[[["segmentselector"]]]],[5,"load_ss","","Reload stack segment register.",N,[[["segmentselector"]]]],[5,"load_ds","","Reload data segment register.",N,[[["segmentselector"]]]],[5,"load_es","","Reload es segment register.",N,[[["segmentselector"]]]],[5,"load_fs","","Reload fs segment register.",N,[[["segmentselector"]]]],[5,"load_gs","","Reload gs segment register.",N,[[["segmentselector"]]]],[5,"cs","","Returns the current value of the code segment register.",N,[[],["segmentselector"]]],[0,"interrupts","kfs_kernel::i386::instructions","Interrupt disabling functionality.",N,N],[5,"sti","kfs_kernel::i386::instructions::interrupts","Enable interrupts",N,[[]]],[5,"cli","","Disable interrupts",N,[[]]],[5,"hlt","","Waits until an interrupt is fired",N,[[]]],[5,"are_enabled","","Returns whether interrupts are enabled.",N,[[],["bool"]]],[5,"without_interrupts","","Run a closue with disabled interrupts.",N,[[["f"]],["r"]]],[11,"from_u8","kfs_kernel::i386","Creates a `PrivilegeLevel` from a numeric value. The value…",39,[[["u8"]],["privilegelevel"]]],[11,"new","","Creates a new TssStruct.",37,[[],["tssstruct"]]],[11,"set_esp0_stack","","Set the stack pointer used to handle interrupts occuring…",37,[[["self"],["u32"]]]],[11,"set_ip","","Set the IP of the current task struct. When we hardware…",37,[[["self"],["u32"]]]],[11,"new","","Create a new AlignedTssStruct, using boxing to avoid…",38,[[["tssstruct"]],["box",["alignedtssstruct"]]]],[0,"interrupts","kfs_kernel","Interrupt handling.",N,N],[3,"IDT","kfs_kernel::interrupts","IDT address. Initialized in `init()`.",N,N],[12,"__private_field","","",58,N],[5,"check_thread_killed","","Checks if our thread was killed, in which case unschedule…",N,[[]]],[5,"panic_on_exception","","Panics with an informative message.",N,N],[5,"divide_by_zero_handler","","Divide by zero interruption handler. Kills the process…",N,[[["exceptionstackframe"]]]],[5,"debug_handler","","Debug interruption handler. Kills the process…",N,[[["exceptionstackframe"]]]],[5,"non_maskable_interrupt_handler","","Non maskable interruption handler. Unconditionally panics…",N,[[["exceptionstackframe"]]]],[5,"breakpoint_handler","","Breakpoint interruption handler. Does nothing.",N,[[["exceptionstackframe"]]]],[5,"overflow_handler","","Overflow interruption handler. Kills the process…",N,[[["exceptionstackframe"]]]],[5,"bound_range_exceeded_handler","","Bound range exceeded interruption handler. Kills the…",N,[[["exceptionstackframe"]]]],[5,"invalid_opcode_handler","","Invalid opcode interruption handler. Kills the process…",N,[[["exceptionstackframe"]]]],[5,"device_not_available_handler","","Device not available interruption handler. Kills the…",N,[[["exceptionstackframe"]]]],[5,"double_fault_handler","","Double fault handler. Panics the kernel unconditionally.",N,[[]]],[5,"invalid_tss_handler","","Invalid tss interruption handler. Panics the kernel…",N,[[["exceptionstackframe"],["u32"]]]],[5,"segment_not_present_handler","","Segment not present interruption handler. Kills the…",N,[[["exceptionstackframe"],["u32"]]]],[5,"stack_segment_fault_handler","","Stack segment fault handler. Kills the process…",N,[[["exceptionstackframe"],["u32"]]]],[5,"general_protection_fault_handler","","General protection fault handler. Kills the process…",N,[[["exceptionstackframe"],["u32"]]]],[5,"page_fault_handler","","Page fault handler. Kills the process unconditionally.",N,[[["exceptionstackframe"],["pagefaulterrorcode"]]]],[5,"x87_floating_point_handler","","X87 floating point interruption handler. Kills the process…",N,[[["exceptionstackframe"]]]],[5,"alignment_check_handler","","Alignment check interruption handler. Kills the process…",N,[[["exceptionstackframe"],["u32"]]]],[5,"machine_check_handler","","Machine check interruption handler. Panics the kernel…",N,[[["exceptionstackframe"]]]],[5,"simd_floating_point_handler","","SIMD exception handler. Kills the process unconditionally.",N,[[["exceptionstackframe"]]]],[5,"virtualization_handler","","Virtualization exception handler. Kills the process…",N,[[["exceptionstackframe"]]]],[5,"security_exception_handler","","Security exception handler. Panics the kernel…",N,[[["exceptionstackframe"],["u32"]]]],[5,"syscall_handler","","This is the function called on int 0x80.",N,[[]]],[5,"init","","Initialize the interrupt subsystem. Sets up the PIC and…",N,[[]]],[0,"irq","","IRQ Handling",N,N],[5,"timer_handler","kfs_kernel::interrupts::irq","",N,[[["exceptionstackframe"]]]],[7,"IRQ_HANDLERS","","Array of interrupt handlers. The position in the array…",N,N],[0,"syscalls","kfs_kernel::interrupts","Syscall implementations",N,N],[3,"Registers","kfs_kernel::interrupts::syscalls","Represents a register backup. The syscall wrapper…",N,N],[12,"eax","","",59,N],[12,"ebx","","",59,N],[12,"ecx","","",59,N],[12,"edx","","",59,N],[12,"esi","","",59,N],[12,"edi","","",59,N],[12,"ebp","","",59,N],[5,"set_heap_size","","Resize the heap of a process, just like a brk. It can both…",N,[[["usize"]],["result",["usize","userspaceerror"]]]],[5,"map_framebuffer","","Maps the vga frame buffer mmio in userspace memory",N,[[],["result",["userspaceerror"]]]],[5,"create_interrupt_event","","Create an event handle for the given IRQ number. Waiting…",N,[[["usize"],["u32"]],["result",["usize","userspaceerror"]]]],[5,"wait_synchronization","","Waits for one of the handles to signal an event.",N,[[["userspaceptr"],["usize"]],["result",["usize","userspaceerror"]]]],[5,"output_debug_string","","Print the passed string to the serial port.",N,[[["userspaceptr"]],["result",["userspaceerror"]]]],[5,"exit_process","","Kills our own process.",N,[[],["result",["userspaceerror"]]]],[5,"connect_to_port","","Connects to the given ClientPort.",N,[[["u32"]],["result",["usize","userspaceerror"]]]],[5,"exit_thread","","Kills our own thread.",N,[[],["result",["userspaceerror"]]]],[5,"create_thread","","Creates a thread in the current process. The thread can…",N,[[["usize"],["usize"],["usize"],["u32"],["u32"]],["result",["usize","userspaceerror"]]]],[5,"start_thread","","Starts a previously created thread.",N,[[["u32"]],["result",["userspaceerror"]]]],[5,"connect_to_named_port","","Connects to the given named port. The name should be a…",N,[[["userspaceptr"]],["result",["usize","userspaceerror"]]]],[5,"manage_named_port","","Creates a new ServerPort for the given named port. The…",N,[[["userspaceptr"],["u32"]],["result",["usize","userspaceerror"]]]],[5,"accept_session","","Waits for an incoming connection on the given ServerPort…",N,[[["u32"]],["result",["usize","userspaceerror"]]]],[5,"send_sync_request_with_user_buffer","","Send an IPC request through the ClientSession, and blocks…",N,[[["userspaceptrmut"],["u32"]],["result",["userspaceerror"]]]],[5,"reply_and_receive_with_user_buffer","","If ReplyTarget is not zero, a reply from the given buffer…",N,[[["userspaceptrmut"],["userspaceptr"],["u32"],["usize"]],["result",["usize","userspaceerror"]]]],[5,"close_handle","","Closed the passed handle.",N,[[["u32"]],["result",["userspaceerror"]]]],[5,"sleep_thread","","Sleep for a specified amount of time, or yield thread.",N,[[["usize"]],["result",["userspaceerror"]]]],[5,"create_port","","Create a new Port pair. Those ports are linked to…",N,[[["u32"],["bool"],["userspaceptr"]],["result",["userspaceerror"]]]],[5,"create_shared_memory","","Allocate a new SharedMemory region. This is a memory…",N,[[["u32"],["u32"],["u32"]],["result",["usize","userspaceerror"]]]],[5,"map_shared_memory","","Maps the block supplied by the handle. The required…",N,[[["u32"],["usize"],["usize"],["u32"]],["result",["userspaceerror"]]]],[5,"unmap_shared_memory","","Unmaps this shared memory region. This cannot be used to…",N,[[["u32"],["usize"],["usize"]],["result",["userspaceerror"]]]],[5,"query_memory","","Query information about an address. Will always fetch the…",N,[[["userspaceptrmut",["memoryinfo"]],["usize"],["usize"]],["result",["usize","userspaceerror"]]]],[5,"create_session","","Create a new Session pair. Those sessions are linked to…",N,[[["bool"],["usize"]],["result",["userspaceerror"]]]],[5,"syscall_handler_inner","","Syscall dispatcher. Dispatches to the various syscall…",N,[[["registers"]]]],[11,"apply0","","Update the Registers with the passed result.",59,[[["self"],["result",["userspaceerror"]]]]],[11,"apply1","","Update the Registers with the passed result.",59,[[["self"],["result",["usize","userspaceerror"]]]]],[11,"apply2","","Update the Registers with the passed result.",59,[[["self"],["result",["userspaceerror"]]]]],[11,"apply3","","Update the Registers with the passed result.",59,[[["self"],["result",["userspaceerror"]]]]],[11,"apply4","","Update the Registers with the passed result.",59,[[["self"],["result",["userspaceerror"]]]]],[7,"IDT","kfs_kernel::interrupts","",N,N],[0,"frame_allocator","kfs_kernel","Physical memory manager.",N,N],[3,"FrameAllocator","kfs_kernel::frame_allocator","The physical memory manager.",N,N],[5,"init","","Initialize the [FrameAllocator] by parsing the multiboot…",N,[[["bootinformation"]]]],[5,"mark_frame_bootstrap_allocated","","Marks a physical memory frame as already allocated…",N,[[["physicaladdress"]]]],[0,"physical_mem_region","","PhysicalMemRegion",N,N],[3,"PhysicalMemRegion","kfs_kernel::frame_allocator::physical_mem_region","A span of adjacent physical frames. A frame is [PAGE_SIZE].",N,N],[12,"frames","","The number of frames in this region.",60,N],[12,"start_addr","","The (physical) address of the start of this region.",60,N],[12,"should_free_on_drop","","Denotes if the frames held in this region should be freed…",60,N],[3,"PhysicalMemRegionIter","","An iterator over a physical region. Yields the address of…",N,N],[12,"0","","",61,N],[12,"1","","",61,N],[11,"address","","Get the start address of this PhysicalMemRegion",60,[[["self"]],["physicaladdress"]]],[11,"size","","Get the size this PhysicalMemRegion spans",60,[[["self"]],["usize"]]],[11,"on_fixed_mmio","","Constructs a `PhysicalMemRegion` by circumventing the…",60,[[["physicaladdress"],["usize"]],["self"]]],[11,"reconstruct","","Constructs a `PhysicalMemRegion` from a physical address,…",60,[[["physicaladdress"],["usize"]],["self"]]],[11,"reconstruct_no_dealloc","","Constructs a `PhysicalMemRegion` from a physical address,…",60,[[["physicaladdress"],["usize"]],["self"]]],[0,"i386","kfs_kernel::frame_allocator","Architecture specific-behaviour i386 implementation of the…",N,N],[3,"FrameAllocatori386","kfs_kernel::frame_allocator::i386","A frame allocator backed up by a giant bitmap.",N,N],[12,"memory_bitmap","","A big bitmap denoting for every frame if it is free or not",62,N],[12,"initialized","","All operations have to check that the Allocator has been…",62,N],[3,"FrameAllocator","","The physical memory manager.",N,N],[5,"addr_to_frame","","Gets the frame number from a physical address",N,[[["usize"]],["usize"]]],[5,"frame_to_addr","","Gets the physical address from a frame number",N,[[["usize"]],["usize"]]],[5,"init","","Initialize the [FrameAllocator] by parsing the multiboot…",N,[[["bootinformation"]]]],[5,"mark_area_reserved","","Marks a physical memory area as reserved and will never…",N,N],[5,"mark_area_free","","Marks a physical memory area as free for frame allocation",N,N],[5,"mark_frame_bootstrap_allocated","","Marks a physical memory frame as already allocated…",N,[[["physicaladdress"]]]],[7,"FRAME_ALLOCATOR","","A physical memory manger to allocate and free memory frames",N,N],[17,"FRAME_OFFSET_MASK","","The offset part in a [PhysicalAddress]. ``` let…",N,N],[17,"FRAME_BASE_MASK","","The frame part in [PhysicalAddress]. ``` let phys_address…",N,N],[17,"FRAME_BASE_LOG","","The right shift to perform to a Physical address to get…",N,N],[17,"FRAMES_BITMAP_SIZE","","The size of the frames_bitmap (~128ko)",N,N],[17,"FRAME_FREE","","In the the bitmap, 1 means the frame is free.",N,N],[17,"FRAME_OCCUPIED","","In the the bitmap, 0 means the frame is occupied.",N,N],[11,"new","","Called to initialize the [FRAME_ALLOCATOR] global.",62,[[],["self"]]],[0,"private","kfs_kernel::frame_allocator","Private FrameAllocator API",N,N],[8,"FrameAllocatorTraitPrivate","kfs_kernel::frame_allocator::private","An arch-specifig FrameAllocator must expose the following…",N,N],[10,"free_region","","Marks a region as deallocated. Called when a…",63,[[["physicalmemregion"]]]],[10,"check_is_allocated","","Checks if a region is marked allocated.",63,[[["physicaladdress"],["usize"]],["bool"]]],[10,"check_is_reserved","","Checks if a region is marked reserved.",63,[[["physicaladdress"],["usize"]],["bool"]]],[8,"FrameAllocatorTrait","kfs_kernel::frame_allocator","An arch-specific FrameAllocator must expose the following…",N,N],[10,"allocate_region","","Allocates a single PhysicalMemRegion. Frames are…",64,[[["usize"]],["result",["physicalmemregion","kernelerror"]]]],[10,"allocate_frames_fragmented","","Allocates physical frames, possibly fragmented across…",64,[[["usize"]],["result",["vec","kernelerror"]]]],[11,"allocate_frame","","Allocates a single physical frame.",64,[[],["result",["physicalmemregion","kernelerror"]]]],[0,"heap_allocator","kfs_kernel","Virtual heap allocator.",N,N],[3,"Allocator","kfs_kernel::heap_allocator","Simple wrapper around linked_list_allocator, growing heap…",N,N],[12,"0","","",65,N],[5,"rust_oom","","Called when the kernel heap allocator detects Out Of…",N,N],[17,"RESERVED_HEAP_SIZE","","Maximum size of our Kernel Heap.",N,N],[11,"expand","","Safely expands the heap if possible.",65,[[["self"],["usize"]]]],[11,"init","","Create a new Heap of `RESERVED_HEAP_SIZE` bytes.",65,[[],["spinlock",["heap"]]]],[11,"new","","Creates a new heap based off of loader settings.",65,[[],["allocator"]]],[0,"devices","kfs_kernel","Device drivers",N,N],[0,"rs232","kfs_kernel::devices","RS-232 serial port driver",N,N],[3,"ComPort","kfs_kernel::devices::rs232","The base IO port of a COM",N,N],[12,"0","","",66,N],[3,"SerialAttributes","","A foreground and a background combination",N,N],[12,"fg","","foreground color",67,N],[12,"bg","","background color",67,N],[3,"SerialInternal","","A COM output. Wraps the IO ports of this COM, and provides…",N,N],[12,"data_port","","The DATA IO port of this COM",68,N],[12,"status_port","","The STATUS IO port of this COM",68,N],[3,"SerialLogger","","A logger that sends its output to COM1.",N,N],[4,"SerialColor","","The possible colors for serial",N,N],[13,"Black","","",69,N],[13,"Red","","",69,N],[13,"Green","","",69,N],[13,"Yellow","","",69,N],[13,"Blue","","",69,N],[13,"Magenta","","",69,N],[13,"Cyan","","",69,N],[13,"LightGray","","",69,N],[13,"Default","","",69,N],[13,"DarkGray","","",69,N],[13,"LightRed","","",69,N],[13,"LightGreen","","",69,N],[13,"LightYellow","","",69,N],[13,"LightBlue","","",69,N],[13,"LightMagenta","","",69,N],[13,"LightCyan","","",69,N],[13,"White","","",69,N],[7,"G_SERIAL","","The serial logger.",N,N],[17,"COM1","","COM1: I/O port 0x3F8, IRQ 4",N,N],[17,"COM2","","COM2: I/O port 0x2F8, IRQ 3",N,N],[17,"COM3","","COM3: I/O port 0x3E8, IRQ 4",N,N],[17,"COM4","","COM4: I/O port 0x2E8, IRQ 3",N,N],[11,"fg","","Creates a color attribute with `fg` foreground and default…",67,[[["serialcolor"]],["serialattributes"]]],[11,"fg_bg","","Creates a color attribute with `fg` foreground and `bg`…",67,[[["serialcolor"],["serialcolor"]],["serialattributes"]]],[11,"default","","Creates a color attribute with default foreground and…",67,[[],["serialattributes"]]],[11,"new","","Creates a COM port from it's base IO address.",68,[[["comport"]],["serialinternal",["pio"]]]],[11,"send_string","","Outputs a string to this COM.",68,[[["self"],["str"]]]],[11,"force_unlock","","Re-take the lock protecting multiple access to the device.",70,[[["self"]]]],[0,"pit","kfs_kernel::devices","Programmable Interval Timer",N,N],[3,"PIT_PORTS","kfs_kernel::devices::pit","The mutex wrapping the ports",N,N],[12,"__private_field","","",71,N],[3,"Port61Flags","","The port 0x61 flags we use.",N,N],[12,"bits","","",72,N],[3,"PITPorts","","We put the PIT ports in a structure to have them under a…",N,N],[12,"port_chan_0","","",73,N],[12,"port_chan_2","","",73,N],[12,"port_cmd","","",73,N],[12,"port_61","","",73,N],[3,"PITChannel2","","Channel 2",N,N],[12,"ports","","A reference to the PITPorts structure.",74,N],[3,"WaitFor","","A stream of event that trigger every `ms` amount of…",N,N],[12,"every_ms","","Approximation of number of ms spent between triggers.",75,N],[12,"parent_event","","The IRQ that we wait on (IRQ #0).",75,N],[12,"spins_needed","","Number of IRQ #0 triggers to wait for. Derived from…",75,N],[4,"ChannelSelector","","Used internally to select which channel to apply…",N,N],[13,"Channel0","","Operation should apply to Channel 0.",76,N],[13,"Channel2","","Operation should apply to Channel 2.",76,N],[5,"spin_wait_ms","","Spin waits for at least `ms` amount of milliseconds",N,[[["usize"]]]],[5,"wait_ms","","Returns a stream of event that trigger every `ms` amount…",N,N],[5,"init_channel_0","","Initialize the channel 0 to send recurring irqs.",N,[[]]],[7,"PIT_PORTS","","",N,N],[17,"OSCILLATOR_FREQ","","The oscillator frequency when not divided, in hertz.",N,N],[17,"CHAN_0_FREQUENCY","","The frequency of channel 0 irqs, in hertz. One every 10…",N,N],[17,"CHAN_0_DIVISOR","","The channel 0 reset value",N,N],[18,"SPKR_CONTROL","","",72,N],[18,"OUT2_STATUS","","",72,N],[18,"GATE_2","","",72,N],[18,"OUT1_STATUS","","",72,N],[18,"OTHER_2","","",72,N],[18,"OTHER_3","","",72,N],[18,"OTHER_6","","",72,N],[18,"OTHER_7","","",72,N],[11,"empty","","Returns an empty set of flags.",72,[[],["port61flags"]]],[11,"all","","Returns the set containing all flags.",72,[[],["port61flags"]]],[11,"bits","","Returns the raw value of the flags currently stored.",72,[[["self"]],["u8"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",72,[[["u8"]],["option",["port61flags"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",72,[[["u8"]],["port61flags"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",72,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",72,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",72,[[["self"],["port61flags"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",72,[[["self"],["port61flags"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",72,[[["self"],["port61flags"]]]],[11,"remove","","Removes the specified flags in-place.",72,[[["self"],["port61flags"]]]],[11,"toggle","","Toggles the specified flags in-place.",72,[[["self"],["port61flags"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",72,[[["self"],["port61flags"],["bool"]]]],[11,"write_reload_value","","Writes a reload value in lobyte/hibyte access mode",73,[[["self"],["channelselector"],["u16"]]]],[11,"init","","Sets mode #0 for Channel 2.",74,[[["pitports"]],["pitchannel2"]]],[11,"start_countdown","","Sets the countdown reset value by writing to channel 2…",74,[[["self"],["u16"]]]],[11,"is_countdown_finished","","Checks if the countdown is finished",74,[[["self"]],["bool"]]],[11,"wait_countdown_is_finished","","Waits until countdown is finished",74,[[["self"]]]],[11,"spin_wait_ms","","Spin waits for at least `ms` amount of milliseconds",74,[[["self"],["usize"]]]],[0,"pic","kfs_kernel::devices","Driver for the 8259 Programmable Interrupt Controller.",N,N],[3,"ICW1","kfs_kernel::devices::pic","The first control word sent to the PIC.",N,N],[12,"bits","","",77,N],[3,"InternalPic","","A single PIC8259 device.",N,N],[12,"port_cmd","","The PIC's COMMAND IO port.",78,N],[12,"port_data","","The PIC's DATA IO port.",78,N],[3,"Pic","","A master/slave PIC setup, as commonly found on IBM PCs.",N,N],[12,"master","","The master PIC.",79,N],[12,"slave","","The slave PIC, cascaded on line 2 of `.master`",79,N],[5,"get","","Acquires a reference to the PIC, initializing it if it…",N,[[],["pic"]]],[5,"init","","Initializes the PIC if it has not yet been initialized.…",N,[[]]],[7,"PIC","","The PIC manager.",N,N],[17,"ICW4_8086","","ICW4: 8086/88 (MCS-80/85) mode.",N,N],[18,"ICW4","","If this bit is set, ICW4 has to be read. If ICW4 is not…",77,N],[18,"SINGLE","","Single. Means that this is the only 8259A in the system.…",77,N],[18,"INTERVAL4","","Call Address Interval. Used only in 8085, not 8086.…",77,N],[18,"LEVEL","","If LEVEL = 1, then the 8259A will operate in the level…",77,N],[18,"INIT","","Should always be set to 1.",77,N],[11,"empty","","Returns an empty set of flags.",77,[[],["icw1"]]],[11,"all","","Returns the set containing all flags.",77,[[],["icw1"]]],[11,"bits","","Returns the raw value of the flags currently stored.",77,[[["self"]],["u8"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",77,[[["u8"]],["option",["icw1"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",77,[[["u8"]],["icw1"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",77,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",77,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",77,[[["self"],["icw1"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",77,[[["self"],["icw1"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",77,[[["self"],["icw1"]]]],[11,"remove","","Removes the specified flags in-place.",77,[[["self"],["icw1"]]]],[11,"toggle","","Toggles the specified flags in-place.",77,[[["self"],["icw1"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",77,[[["self"],["icw1"],["bool"]]]],[11,"new","","Creates a new PIC, and initializes it.",79,[[],["pic"]]],[11,"mask","","Mask the given IRQ number. Will redirect the call to the…",79,[[["self"],["u8"]]]],[11,"acknowledge","","Acknowledges an IRQ, allowing the PIC to send a new IRQ on…",79,[[["self"],["u8"]]]],[11,"new","","Setup the 8259 pic. Redirect the IRQ to the chosen…",78,[[["u16"],["bool"],["u8"]],["internalpic"]]],[11,"acknowledge","","Acknowledges an IRQ, allowing the PIC to send a new IRQ on…",78,[[["self"]]]],[11,"mask","","Mask the given IRQ",78,[[["self"],["u8"]]]],[0,"sync","kfs_kernel","Synchronization primitives used by KFS",N,N],[3,"Once","kfs_kernel::sync","A synchronization primitive which can be used to run a…",N,N],[12,"state","","",80,N],[12,"data","","",80,N],[3,"RwLock","","A reader-writer lock",N,N],[12,"lock","","",81,N],[12,"data","","",81,N],[3,"RwLockReadGuard","","A guard to which the protected data can be read",N,N],[12,"lock","","",82,N],[12,"data","","",82,N],[3,"RwLockWriteGuard","","A guard to which the protected data can be written",N,N],[12,"lock","","",83,N],[12,"data","","",83,N],[3,"SpinLock","","This type provides MUTual EXclusion based on spinning.",N,N],[12,"lock","","",84,N],[12,"data","","",84,N],[3,"SpinLockGuard","","A guard to which the protected data can be accessed",N,N],[12,"lock","","",85,N],[12,"data","","",85,N],[3,"SpinLockIRQ","","SpinLock that disables IRQ.",N,N],[12,"internal","","SpinLock we wrap.",86,N],[3,"SpinLockIRQGuard","","The SpinLockIrq lock guard.",N,N],[12,"0","","",87,N],[12,"1","","",87,N],[5,"permanently_disable_interrupts","","Permanently disables the interrupts. Forever.",N,[[]]],[6,"Mutex","","Placeholder for future Mutex implementation.",N,N],[6,"MutexGuard","","Placeholder for future Mutex implementation.",N,N],[7,"INTERRUPT_DISARM","","Boolean to [permanently_disable_interrupts].",N,N],[8,"Lock","","Abstraction around various kind of locks.",N,N],[10,"lock","","Locks the lock until the returned guard is dropped. The…",88,[[["self"]],["guard"]]],[11,"new","","Creates a new spinlockirq wrapping the supplied data.",86,[[["t"]],["spinlockirq"]]],[11,"into_inner","","Consumes this SpinLockIRQ, returning the underlying data.",86,[[["self"]],["t"]]],[11,"lock","","Disables interrupts and locks the mutex.",86,[[["self"]],["spinlockirqguard"]]],[11,"try_lock","","Disables interrupts and locks the mutex.",86,[[["self"]],["option",["spinlockirqguard"]]]],[11,"force_unlock","","Force unlocks the lock.",86,[[["self"]]]],[0,"process","kfs_kernel","Process",N,N],[3,"ProcessCapabilities","kfs_kernel::process","Capabilities of a process.",N,N],[12,"syscall_mask","","Bitmask of syscall access controls. Should be accessed…",89,N],[12,"irq_access_mask","","Bitmask of allowed interrupts. Should be accessed through…",89,N],[12,"ioports","","A vector of readable IO ports.",89,N],[3,"ProcessStruct","","The struct representing a process. There's one for every…",N,N],[12,"pid","","The unique id of this process.",90,N],[12,"name","","A name for this process.",90,N],[12,"pmemory","","The memory view of this process. Shared among the threads.",90,N],[12,"phandles","","The handles of this process. Shared among the threads.",90,N],[12,"threads","","The threads of this process. A ProcessStruct with no…",90,N],[12,"killed","","Marks when the process is dying.",90,N],[12,"capabilities","","Permissions of this process.",90,N],[12,"thread_maternity","","An array of the created but not yet started threads.",90,N],[3,"ThreadStruct","","The struct representing a thread. A process may own…",N,N],[12,"state","","The state of this thread.",91,N],[12,"kstack","","The kernel stack it uses for handling syscalls/irqs.",91,N],[12,"hwcontext","","The saved hardware context, for getting it running again…",91,N],[12,"process","","The process that this thread belongs to.",91,N],[12,"arg","","Argument passed to the entrypoint on first schedule.",91,N],[3,"HandleTable","","Holds the table associating userspace handle numbers to a…",N,N],[12,"table","","Internal mapping from a handle number to a Kernel Object.",92,N],[12,"counter","","The next handle's ID.",92,N],[3,"ThreadStateAtomic","","Stores a ThreadState atomically.",N,N],[12,"0","","",93,N],[4,"Handle","","A handle to a userspace-accessible resource.",N,N],[13,"ReadableEvent","","An event on which we can wait. Could be an IRQ, or a…",94,N],[13,"ServerPort","","The server side of an IPC port. See [crate::ipc::port] for…",94,N],[13,"ClientPort","","The client side of an IPC port. See [crate::ipc::port] for…",94,N],[13,"ServerSession","","The server side of an IPC session. See…",94,N],[13,"ClientSession","","The client side of an IPC session. See…",94,N],[13,"Thread","","A thread.",94,N],[13,"SharedMemory","","A shared memory region. The handle holds on to the…",94,N],[4,"ThreadState","","The state of a thread.",N,N],[13,"Running","","Currently on the CPU.",95,N],[13,"Scheduled","","Scheduled to be running.",95,N],[13,"Stopped","","Not in the scheduled queue, waiting for an event.",95,N],[13,"Killed","","Dying, will be unscheduled and dropped at syscall boundary.",95,N],[0,"capabilities","","Process Capability handling",N,N],[3,"ProcessCapabilities","kfs_kernel::process::capabilities","Capabilities of a process.",N,N],[12,"syscall_mask","","Bitmask of syscall access controls. Should be accessed…",89,N],[12,"irq_access_mask","","Bitmask of allowed interrupts. Should be accessed through…",89,N],[12,"ioports","","A vector of readable IO ports.",89,N],[3,"MaskPrinter","","Wrapper around a bitfield that only prints the indices of…",N,N],[12,"0","","",96,N],[17,"KERNEL_FLAGS","","Allowed CPUID and thread priorities.",N,N],[17,"SYSCALL_MASK","","Shifted mask of allowed syscalls.",N,N],[17,"MAP_IO_OR_NORMAL_RANGE","","Map an IO or physical memory page into process address…",N,N],[17,"MAP_NORMAL_PAGE","","Map a normal page.",N,N],[17,"INTERRUPT_PAIR","","Allow creating an interrupt for the given IRQ pair.",N,N],[17,"APPLICATION_TYPE","","Type of application (sysmodule, applet, application)",N,N],[17,"KERNEL_RELEASE_VERSION","","Minimum kernel release.",N,N],[17,"HANDLE_TABLE_SIZE","","Max amount of handle for the process.",N,N],[17,"DEBUG_FLAGS","","Flags allowing app to debug or be debugged.",N,N],[17,"IO_PORTS_ALLOWED","","IOPorts the process is allowed to talk to",N,N],[17,"MAX_SVC","","The highest defined svc.",N,N],[17,"KACS_NO_DUPLICATES","","Mask of kernel capabilities that cannot appear twice in a…",N,N],[11,"parse_kcaps","kfs_kernel::process","Parse the kernel capabilities, in the NPDM format. More…",89,N],[7,"NEXT_PROCESS_ID","","Next available PID.",N,N],[11,"as_waitable","","Gets the handle as a [Waitable], or return a…",94,[[["self"]],["result",["waitable","userspaceerror"]]]],[11,"as_client_port","","Casts the handle as a [ClientPort], or returns a…",94,[[["self"]],["result",["clientport","userspaceerror"]]]],[11,"as_server_session","","Casts the handle as a [ServerSession], or returns a…",94,[[["self"]],["result",["serversession","userspaceerror"]]]],[11,"as_client_session","","Casts the handle as a [ClientSession], or returns a…",94,[[["self"]],["result",["clientsession","userspaceerror"]]]],[11,"as_thread_handle","","Casts the handle as a Weak<[ThreadStruct]>, or returns a…",94,[[["self"]],["result",["weak","userspaceerror"]]]],[11,"as_shared_memory","","Casts the handle as an Arc<Vec<[PhysicalMemRegion]>, or…",94,[[["self"]],["result",["arc","userspaceerror"]]]],[11,"add_handle","","Add a handle to the handle table, returning the userspace…",92,[[["self"],["arc",["handle"]]],["u32"]]],[11,"get_handle","","Gets the Kernel Handle associated with the given userspace…",92,[[["self"],["u32"]],["result",["arc","userspaceerror"]]]],[11,"delete_handle","","Deletes the mapping from the given userspace handle…",92,[[["self"],["u32"]],["result",["arc","userspaceerror"]]]],[11,"from_primitive","","ThreadState is stored in the ThreadStruct as an…",95,[[["usize"]],["threadstate"]]],[11,"new","","",93,[[["threadstate"]],["threadstateatomic"]]],[11,"into_inner","","",93,[[["self"]],["threadstate"]]],[11,"load","","",93,[[["self"],["ordering"]],["threadstate"]]],[11,"store","","",93,[[["self"],["threadstate"],["ordering"]]]],[11,"swap","","",93,[[["self"],["threadstate"],["ordering"]],["threadstate"]]],[11,"compare_and_swap","","",93,[[["self"],["threadstate"],["threadstate"],["ordering"]],["threadstate"]]],[11,"compare_exchange","","",93,[[["self"],["threadstate"],["threadstate"],["ordering"],["ordering"]],["result",["threadstate","threadstate"]]]],[11,"compare_exchange_weak","","",93,[[["self"],["threadstate"],["threadstate"],["ordering"],["ordering"]],["result",["threadstate","threadstate"]]]],[11,"fetch_update","","",93,[[["self"],["f"],["ordering"],["ordering"]],["result",["threadstate","threadstate"]]]],[11,"new","","Creates a new process.",90,[[["string"],["option"]],["result",["arc","kernelerror"]]]],[11,"create_first_process","","Creates the very first process at boot. Called internally…",90,[[],["arc",["processstruct"]]]],[11,"kill_process","","Kills a process by killing all of its threads.",90,[[["arc"]]]],[11,"new","","Creates a new thread.",91,[[["arc"],["virtualaddress"],["virtualaddress"],["usize"]],["result",["weak","kernelerror"]]]],[11,"create_first_thread","","Creates the very first process and thread at boot.",91,[[],["arc",["threadstruct"]]]],[11,"start","","Takes a reference to a thread, removes it from the…",91,[[["weak"]],["result",["kernelerror"]]]],[11,"kill","","Sets the thread to the `Killed` state.",91,[[["arc"]]]],[0,"scheduler","kfs_kernel","The Completly Unfair Scheduler",N,N],[5,"try_get_current_thread","kfs_kernel::scheduler","Gets the current ThreadStruct, incrementing its refcount.…",N,[[],["option",["arc"]]]],[5,"get_current_thread","","Gets the current ThreadStruct, incrementing its refcount.",N,[[],["arc",["threadstruct"]]]],[5,"try_get_current_process","","Gets the ProcessStruct of the current thread, incrementing…",N,[[],["option",["arc"]]]],[5,"get_current_process","","Gets the ProcessStruct of the current thread, incrementing…",N,[[],["arc",["processstruct"]]]],[5,"set_current_thread","","Sets the current ThreadStruct.",N,[[["arc",["threadstruct"]],["f"]],["r"]]],[5,"add_to_schedule_queue","","Adds a thread at the end of the schedule queue, and…",N,[[["arc",["threadstruct"]]]]],[5,"is_in_schedule_queue","","Checks if a thread is already either in the schedule queue…",N,[[["spinlockirqguard"],["arc"]],["bool"]]],[5,"unschedule","","Removes the current thread from the schedule queue, and…",N,[[["lock"],["guard"]],["result",["userspaceerror"]]]],[5,"create_first_process","","Creates the very first process at boot. The created…",N,[[]]],[5,"schedule","","Performs a process switch.",N,[[]]],[5,"find_next_thread_to_run","","Parses the queue to find the first unlocked process.…",N,N],[5,"internal_schedule","","Internal impl of the process switch, used by schedule and…",N,[[["lock"],["bool"]],["guard"]]],[5,"scheduler_first_schedule","","The function called when a thread was scheduled for the…",N,[[["arc",["threadstruct"]],["f"]]]],[7,"CURRENT_THREAD","","An Arc to the currently running thread.",N,N],[7,"SCHEDULE_QUEUE","","The schedule queue",N,N],[0,"mem","kfs_kernel","Basic functionality for dealing with memory.",N,N],[3,"PhysicalAddress","kfs_kernel::mem","Represents a Physical address",N,N],[12,"0","","",97,N],[3,"VirtualAddress","","Represents a Virtual address",N,N],[12,"0","","",98,N],[3,"UserSpacePtr","","A pointer to read-only userspace memory. Prevents…",N,N],[12,"0","","",99,N],[3,"UserSpacePtrMut","","A pointer to read-write userspace memory. Prevents…",N,N],[12,"0","","",100,N],[3,"FatPtr","","Internal rust representation of a DST pointer.",N,N],[12,"data","","A pointer to the underlying slice.",101,N],[12,"len","","The length of the slice, in number of elements.",101,N],[5,"round_to_page","","Rounds an address to its page address",N,[[["usize"]],["usize"]]],[5,"round_to_page_upper","","Rounds an address to the next page address except if its…",N,[[["usize"]],["usize"]]],[5,"count_pages","","Counts the number of pages `size` takes",N,[[["usize"]],["usize"]]],[11,"addr","","Gets the address as a `usize`.",98,[[["self"]],["usize"]]],[11,"addr","","Gets the address as a `usize`.",97,[[["self"]],["usize"]]],[11,"checked_add","","Tries to add an offset to a PhysicalAddress, returning a…",97,[[["self"],["usize"]],["result",["physicaladdress","kernelerror"]]]],[11,"floor","","Rounds down to PAGE_SIZE.",97,[[["self"]],["physicaladdress"]]],[11,"ceil","","Rounds up PAGE_SIZE.",97,[[["self"]],["physicaladdress"]]],[11,"checked_add","","Tries to add an offset to a VirtualAddress, returning a…",98,[[["self"],["usize"]],["result",["virtualaddress","kernelerror"]]]],[11,"floor","","Rounds down to PAGE_SIZE.",98,[[["self"]],["virtualaddress"]]],[11,"ceil","","Rounds up PAGE_SIZE.",98,[[["self"]],["virtualaddress"]]],[11,"from_raw_parts","","Forms a UserSpacePtr slice from a pointer and a length.…",99,N],[11,"from_raw_parts_mut","","Forms a UserSpacePtrMut slice from a pointer and a length.…",100,N],[0,"ipc","kfs_kernel","IPC primitives",N,N],[3,"NAMED_PORTS","kfs_kernel::ipc","",N,N],[12,"__private_field","","",102,N],[5,"create_named_port","","Creates a named port.",N,N],[5,"connect_to_named_port","","Connects to a named port.",N,N],[0,"session","","IPC Sessions",N,N],[3,"SessionRequests","kfs_kernel::ipc::session","Wrapper around the currently active session and the…",N,N],[12,"active_request","","The request currently being serviced. Sessions are…",103,N],[12,"incoming_requests","","Pending Requests.",103,N],[3,"Session","","Shared part of a Session.",N,N],[12,"internal","","Pending requests and currently active request are there.",104,N],[12,"accepters","","List of threads waiting for a request.",104,N],[12,"servercount","","Count of live ServerSessions. Once it drops to 0, all…",104,N],[3,"ClientSession","","The client side of a Session.",N,N],[12,"0","","",105,N],[3,"ServerSession","","The server side of a Session.",N,N],[12,"0","","",106,N],[3,"MsgPackedHdr","","Represenens the header of an HIPC command.",N,N],[12,"0","","",107,N],[3,"HandleDescriptorHeader","","Part of an HIPC command. Sent only when…",N,N],[12,"0","","",108,N],[3,"Request","","An incoming IPC request.",N,N],[12,"sender_buf","","Address of the mirror-mapped (in-kernel) IPC buffer.…",109,N],[12,"sender_bufsize","","Size of the IPC buffer.",109,N],[12,"sender","","Thread that sent this request. It should be woken up when…",109,N],[12,"answered","","A really really broken excuse for a condvar. The thread…",109,N],[5,"new","","Create a new Session pair. Those sessions are linked to…",N,N],[5,"buf_map","","Send an IPC Buffer from the sender into the receiver.",N,N],[5,"pass_message","","Send a message from the sender to the receiver. This is…",N,N],[11,"ty","","",107,[[["self"]],["u16"]]],[11,"num_x_descriptors","","",107,[[["self"]],["u8"]]],[11,"set_num_x_descriptors","","",107,[[["self"],["u8"]]]],[11,"num_a_descriptors","","",107,[[["self"]],["u8"]]],[11,"set_num_a_descriptors","","",107,[[["self"],["u8"]]]],[11,"num_b_descriptors","","",107,[[["self"]],["u8"]]],[11,"set_num_b_descriptors","","",107,[[["self"],["u8"]]]],[11,"num_w_descriptors","","",107,[[["self"]],["u8"]]],[11,"set_num_w_descriptors","","",107,[[["self"],["u8"]]]],[11,"raw_section_size","","",107,[[["self"]],["u16"]]],[11,"set_raw_section_size","","",107,[[["self"],["u16"]]]],[11,"c_descriptor_flags","","",107,[[["self"]],["u8"]]],[11,"set_c_descriptor_flags","","",107,[[["self"],["u8"]]]],[11,"enable_handle_descriptor","","",107,[[["self"]],["bool"]]],[11,"set_enable_handle_descriptor","","",107,[[["self"],["bool"]]]],[11,"send_pid","","",108,[[["self"]],["bool"]]],[11,"set_send_pid","","",108,[[["self"],["bool"]]]],[11,"num_copy_handles","","",108,[[["self"]],["u8"]]],[11,"set_num_copy_handles","","",108,[[["self"],["u8"]]]],[11,"num_move_handles","","",108,[[["self"]],["u8"]]],[11,"set_num_move_handles","","",108,[[["self"],["u8"]]]],[11,"client","","Returns a ClientPort from this Port.",104,[[["arc"]],["clientsession"]]],[11,"server","","Returns a ServerSession from this Port.",104,[[["arc"]],["serversession"]]],[11,"send_request","","Send an IPC request through the client pipe. Takes a…",105,[[["self"],["userspaceptrmut"]],["result",["userspaceerror"]]]],[11,"receive","","Receive an IPC request through the server pipe. Takes a…",106,[[["self"],["userspaceptrmut"]],["result",["userspaceerror"]]]],[11,"reply","","Replies to the currently active IPC request on the server…",106,[[["self"],["userspaceptr"]],["result",["userspaceerror"]]]],[0,"port","kfs_kernel::ipc","IPC Port",N,N],[3,"Port","kfs_kernel::ipc::port","An endpoint which can be connected to.",N,N],[12,"incoming_connections","","List of incoming connection requests.",110,N],[12,"accepters","","List of threads waiting for a connection request.",110,N],[12,"servercount","","Number of active ServerPort. When it drops to 0, future…",110,N],[3,"ClientPort","","The client side of a Port.",N,N],[12,"0","","",111,N],[3,"ServerPort","","The server side of a Port.",N,N],[12,"0","","",112,N],[3,"IncomingConnection","","Represents a connection request from the creator thread.",N,N],[12,"session","","Session that this connection request is for.",113,N],[12,"creator","","Thread that wants to connect to this Port.",113,N],[5,"new","","Create a new Port pair. Those ports are linked to…",N,N],[11,"client","","Returns a ClientPort from this Port.",110,[[["arc"]],["clientport"]]],[11,"server","","Returns a ServerPort from this Port.",110,[[["arc"]],["serverport"]]],[11,"accept","","Accept a new connection on the Port.",112,[[["self"]],["result",["serversession","userspaceerror"]]]],[11,"connect","","Connects to this port.",111,[[["self"]],["result",["clientsession","userspaceerror"]]]],[7,"NAMED_PORTS","kfs_kernel::ipc","",N,N],[0,"elf_loader","kfs_kernel","Loads Kernel Built-ins.",N,N],[3,"MappedGrubModule","kfs_kernel::elf_loader","Represents a grub module once mapped in kernel memory",N,N],[12,"mapping_addr","","The address of the mapping, in KernelLand.",114,N],[12,"start","","The start of the module in the mapping, if it was not page…",114,N],[12,"len","","The length of the module.",114,N],[12,"elf","","The module parsed as an ElfFile.",114,N],[5,"map_grub_module","","Maps a grub module, which already lives in reserved…",N,[[["moduletag"]],["result",["mappedgrubmodule","kernelerror"]]]],[5,"get_kacs","","Gets the desired kernel access controls for a process…",N,[[["mappedgrubmodule"]],["option"]]],[5,"load_builtin","","Loads the given kernel built-in into the given page table.…",N,[[["processmemory"],["mappedgrubmodule"]],["usize"]]],[5,"load_segment","","Loads an elf segment by coping file_size bytes to the…",N,[[["processmemory"],["programheader"],["elffile"]]]],[0,"utils","kfs_kernel","Generic useful functions",N,N],[0,"io","kfs_kernel::utils","The IO interface",N,N],[8,"Io","kfs_kernel::utils::io","The Io trait allows for accessing device IO in a generic…",N,N],[16,"Value","","The width of the IO access. Should be a primitive type…",115,N],[10,"read","","Reads from this Io.",115,N],[10,"write","","Writes `value` to this Io.",115,N],[11,"readf","","Read from this Io, and mask the value with `flags`.",115,N],[11,"writef","","Mask `value` with `flags`, and write it to this device…",115,N],[3,"ReadOnly","","A read-only wrapper around an IO device.",N,N],[12,"inner","","",116,N],[3,"WriteOnly","","An Io that we can only write to.",N,N],[12,"inner","","",117,N],[3,"Pio","","Port IO accessor.",N,N],[12,"port","","IO-space address this Pio reads from.",56,N],[12,"value","","The word size of this pointer. Should be u8, u16 or u32.",56,N],[5,"align_up","kfs_kernel::utils","Align the address to the next alignment.",N,[[["t"],["t"]],["t"]]],[5,"align_down","","Align the address to the previous alignment.",N,[[["t"],["t"]],["t"]]],[5,"align_up_checked","","align_up, but checks if addr overflows",N,[[["usize"],["usize"]],["option",["usize"]]]],[5,"div_ceil","","Counts the numbers of `b` in `a`, rounding the result up.",N,[[["t"],["t"]],["t"]]],[5,"print_hexdump","","Displays memory as hexdump",N,N],[5,"print_hexdump_as_if_at_addr","","Makes a hexdump of a slice, but display different…",N,N],[8,"BitArrayExt","","Extension of the [BitField] trait, that adds the…",N,N],[11,"set_bits_area","","Sets a range of bits to `value` in the BitField.",118,N],[5,"bit_array_first_zero","","Returns the index of the first 0 in a bit array.",N,N],[5,"bit_array_first_one","","Returns the index of the first 1 in a bit array.",N,N],[5,"bit_array_first_count_one","","Returns the index of the first instance of count…",N,N],[3,"CursorWrite","","A minimal Cursor for writing, for use in libcore.",N,N],[12,"data","","Data backing this cursor.",119,N],[12,"pos","","Position of the cursor in the data.",119,N],[3,"CursorRead","","A minimal Cursor for writing, for use in libcore.",N,N],[12,"data","","Data backing this cursor.",120,N],[12,"pos","","Position of the cursor in the data.",120,N],[14,"enum_with_val","","Creates a fake C-like enum, where all bit values are…",N,N],[8,"Splittable","","A trait for things that can be splitted in two parts",N,N],[10,"split_at","","Split the given object in two at a given offset.",121,[[["self"],["usize"]],["result",["option","kernelerror"]]]],[11,"right_split","","Splits the given object in two at the given offset.",121,[[["self"],["usize"]],["result",["option","kernelerror"]]]],[0,"checks","kfs_kernel","Checked maths functions returning useful errors.",N,N],[5,"check_aligned","kfs_kernel::checks","checks that a certain value meets the given alignment.",N,[[["usize"],["usize"]],["result",["kernelerror"]]]],[5,"check_nonzero_length","","checks that a length is not 0.",N,[[["usize"]],["result",["kernelerror"]]]],[5,"add_or_error","","adds to usize, and returns an KernelError if it would…",N,[[["usize"],["usize"]],["result",["usize","kernelerror"]]]],[5,"sub_or_error","","subtracts to usize, and returns an KernelError if it would…",N,[[["usize"],["usize"]],["result",["usize","kernelerror"]]]],[0,"__rg_allocator_abi","kfs_kernel","",N,N],[5,"__rg_alloc","kfs_kernel::__rg_allocator_abi","",N,N],[5,"__rg_dealloc","","",N,N],[5,"__rg_realloc","","",N,N],[5,"__rg_alloc_zeroed","","",N,N],[7,"ALLOCATOR","kfs_kernel","The global heap allocator.",N,N],[11,"from","kfs_kernel::paging","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::paging::process_memory","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::paging::kernel_memory","",5,[[["t"]],["t"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::paging::lands","",122,[[["t"]],["t"]]],[11,"try_from","","",122,[[["u"]],["result"]]],[11,"try_into","","",122,[[["self"]],["result"]]],[11,"into","","",122,[[["self"]],["u"]]],[11,"borrow","","",122,[[["self"]],["t"]]],[11,"borrow_mut","","",122,[[["self"]],["t"]]],[11,"get_type_id","","",122,[[["self"]],["typeid"]]],[11,"from","","",123,[[["t"]],["t"]]],[11,"try_from","","",123,[[["u"]],["result"]]],[11,"try_into","","",123,[[["self"]],["result"]]],[11,"into","","",123,[[["self"]],["u"]]],[11,"borrow","","",123,[[["self"]],["t"]]],[11,"borrow_mut","","",123,[[["self"]],["t"]]],[11,"get_type_id","","",123,[[["self"]],["typeid"]]],[11,"from","","",124,[[["t"]],["t"]]],[11,"try_from","","",124,[[["u"]],["result"]]],[11,"try_into","","",124,[[["self"]],["result"]]],[11,"into","","",124,[[["self"]],["u"]]],[11,"borrow","","",124,[[["self"]],["t"]]],[11,"borrow_mut","","",124,[[["self"]],["t"]]],[11,"get_type_id","","",124,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::paging::mapping","",7,[[["t"]],["t"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"from","","",8,[[["t"]],["t"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::paging::cross_process","",9,[[["t"]],["t"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::paging::error","",10,[[["t"]],["t"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"to_string","","",10,[[["self"]],["string"]]],[11,"as_fail","","",10,[[["self"]],["fail"]]],[11,"from","kfs_kernel::paging::hierarchical_table","",125,[[["t"]],["t"]]],[11,"try_from","","",125,[[["u"]],["result"]]],[11,"try_into","","",125,[[["self"]],["result"]]],[11,"into","","",125,[[["self"]],["u"]]],[11,"borrow","","",125,[[["self"]],["t"]]],[11,"borrow_mut","","",125,[[["self"]],["t"]]],[11,"get_type_id","","",125,[[["self"]],["typeid"]]],[11,"from","","",11,[[["t"]],["t"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::paging::arch::i386::entry","",17,[[["t"]],["t"]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"into","","",17,[[["self"]],["u"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"get_type_id","","",17,[[["self"]],["typeid"]]],[11,"to_owned","","",17,[[["self"]],["t"]]],[11,"clone_into","","",17,N],[11,"from","","",18,[[["t"]],["t"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"into","","",18,[[["self"]],["u"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"get_type_id","","",18,[[["self"]],["typeid"]]],[11,"to_owned","","",18,[[["self"]],["t"]]],[11,"clone_into","","",18,N],[11,"from","kfs_kernel::paging::arch::i386::table","",19,[[["t"]],["t"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"try_into","","",19,[[["self"]],["result"]]],[11,"into","","",19,[[["self"]],["u"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"get_type_id","","",19,[[["self"]],["typeid"]]],[11,"from","","",20,[[["t"]],["t"]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"try_into","","",20,[[["self"]],["result"]]],[11,"into","","",20,[[["self"]],["u"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"get_type_id","","",20,[[["self"]],["typeid"]]],[11,"from","","",21,[[["t"]],["t"]]],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"try_into","","",21,[[["self"]],["result"]]],[11,"into","","",21,[[["self"]],["u"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"get_type_id","","",21,[[["self"]],["typeid"]]],[11,"from","","",126,[[["t"]],["t"]]],[11,"try_from","","",126,[[["u"]],["result"]]],[11,"try_into","","",126,[[["self"]],["result"]]],[11,"into","","",126,[[["self"]],["u"]]],[11,"borrow","","",126,[[["self"]],["t"]]],[11,"borrow_mut","","",126,[[["self"]],["t"]]],[11,"get_type_id","","",126,[[["self"]],["typeid"]]],[11,"from","","",22,[[["t"]],["t"]]],[11,"try_from","","",22,[[["u"]],["result"]]],[11,"try_into","","",22,[[["self"]],["result"]]],[11,"into","","",22,[[["self"]],["u"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"get_type_id","","",22,[[["self"]],["typeid"]]],[11,"from","","",23,[[["t"]],["t"]]],[11,"try_from","","",23,[[["u"]],["result"]]],[11,"try_into","","",23,[[["self"]],["result"]]],[11,"into","","",23,[[["self"]],["u"]]],[11,"borrow","","",23,[[["self"]],["t"]]],[11,"borrow_mut","","",23,[[["self"]],["t"]]],[11,"get_type_id","","",23,[[["self"]],["typeid"]]],[11,"from","","",24,[[["t"]],["t"]]],[11,"try_from","","",24,[[["u"]],["result"]]],[11,"try_into","","",24,[[["self"]],["result"]]],[11,"into","","",24,[[["self"]],["u"]]],[11,"borrow","","",24,[[["self"]],["t"]]],[11,"borrow_mut","","",24,[[["self"]],["t"]]],[11,"get_type_id","","",24,[[["self"]],["typeid"]]],[11,"from","","",127,[[["t"]],["t"]]],[11,"try_from","","",127,[[["u"]],["result"]]],[11,"try_into","","",127,[[["self"]],["result"]]],[11,"into","","",127,[[["self"]],["u"]]],[11,"borrow","","",127,[[["self"]],["t"]]],[11,"borrow_mut","","",127,[[["self"]],["t"]]],[11,"get_type_id","","",127,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::paging::bookkeeping","",25,[[["t"]],["t"]]],[11,"try_from","","",25,[[["u"]],["result"]]],[11,"try_into","","",25,[[["self"]],["result"]]],[11,"into","","",25,[[["self"]],["u"]]],[11,"borrow","","",25,[[["self"]],["t"]]],[11,"borrow_mut","","",25,[[["self"]],["t"]]],[11,"get_type_id","","",25,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::event","",26,[[["t"]],["t"]]],[11,"try_from","","",26,[[["u"]],["result"]]],[11,"try_into","","",26,[[["self"]],["result"]]],[11,"into","","",26,[[["self"]],["u"]]],[11,"borrow","","",26,[[["self"]],["t"]]],[11,"borrow_mut","","",26,[[["self"]],["t"]]],[11,"get_type_id","","",26,[[["self"]],["typeid"]]],[11,"from","","",27,[[["t"]],["t"]]],[11,"try_from","","",27,[[["u"]],["result"]]],[11,"try_into","","",27,[[["self"]],["result"]]],[11,"into","","",27,[[["self"]],["u"]]],[11,"borrow","","",27,[[["self"]],["t"]]],[11,"borrow_mut","","",27,[[["self"]],["t"]]],[11,"get_type_id","","",27,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::error","",29,[[["t"]],["t"]]],[11,"try_from","","",29,[[["u"]],["result"]]],[11,"try_into","","",29,[[["self"]],["result"]]],[11,"into","","",29,[[["self"]],["u"]]],[11,"borrow","","",29,[[["self"]],["t"]]],[11,"borrow_mut","","",29,[[["self"]],["t"]]],[11,"get_type_id","","",29,[[["self"]],["typeid"]]],[11,"to_owned","","",29,[[["self"]],["t"]]],[11,"clone_into","","",29,N],[11,"to_string","","",29,[[["self"]],["string"]]],[11,"from","","",30,[[["t"]],["t"]]],[11,"try_from","","",30,[[["u"]],["result"]]],[11,"try_into","","",30,[[["self"]],["result"]]],[11,"into","","",30,[[["self"]],["u"]]],[11,"borrow","","",30,[[["self"]],["t"]]],[11,"borrow_mut","","",30,[[["self"]],["t"]]],[11,"get_type_id","","",30,[[["self"]],["typeid"]]],[11,"to_owned","","",30,[[["self"]],["t"]]],[11,"clone_into","","",30,N],[11,"to_string","","",30,[[["self"]],["string"]]],[11,"from","","",31,[[["t"]],["t"]]],[11,"try_from","","",31,[[["u"]],["result"]]],[11,"try_into","","",31,[[["self"]],["result"]]],[11,"into","","",31,[[["self"]],["u"]]],[11,"borrow","","",31,[[["self"]],["t"]]],[11,"borrow_mut","","",31,[[["self"]],["t"]]],[11,"get_type_id","","",31,[[["self"]],["typeid"]]],[11,"to_string","","",31,[[["self"]],["string"]]],[11,"as_fail","","",31,[[["self"]],["fail"]]],[11,"from","kfs_kernel::log_impl","",32,[[["t"]],["t"]]],[11,"try_from","","",32,[[["u"]],["result"]]],[11,"try_into","","",32,[[["self"]],["result"]]],[11,"into","","",32,[[["self"]],["u"]]],[11,"borrow","","",32,[[["self"]],["t"]]],[11,"borrow_mut","","",32,[[["self"]],["t"]]],[11,"get_type_id","","",32,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::log_impl::filter","",33,[[["t"]],["t"]]],[11,"try_from","","",33,[[["u"]],["result"]]],[11,"try_into","","",33,[[["self"]],["result"]]],[11,"into","","",33,[[["self"]],["u"]]],[11,"borrow","","",33,[[["self"]],["t"]]],[11,"borrow_mut","","",33,[[["self"]],["t"]]],[11,"get_type_id","","",33,[[["self"]],["typeid"]]],[11,"from","","",34,[[["t"]],["t"]]],[11,"try_from","","",34,[[["u"]],["result"]]],[11,"try_into","","",34,[[["self"]],["result"]]],[11,"into","","",34,[[["self"]],["u"]]],[11,"borrow","","",34,[[["self"]],["t"]]],[11,"borrow_mut","","",34,[[["self"]],["t"]]],[11,"get_type_id","","",34,[[["self"]],["typeid"]]],[11,"from","","",35,[[["t"]],["t"]]],[11,"try_from","","",35,[[["u"]],["result"]]],[11,"try_into","","",35,[[["self"]],["result"]]],[11,"into","","",35,[[["self"]],["u"]]],[11,"borrow","","",35,[[["self"]],["t"]]],[11,"borrow_mut","","",35,[[["self"]],["t"]]],[11,"get_type_id","","",35,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::log_impl::filter::inner","",36,[[["t"]],["t"]]],[11,"try_from","","",36,[[["u"]],["result"]]],[11,"try_into","","",36,[[["self"]],["result"]]],[11,"into","","",36,[[["self"]],["u"]]],[11,"borrow","","",36,[[["self"]],["t"]]],[11,"borrow_mut","","",36,[[["self"]],["t"]]],[11,"get_type_id","","",36,[[["self"]],["typeid"]]],[11,"to_string","","",36,[[["self"]],["string"]]],[11,"from","kfs_kernel::i386","",37,[[["t"]],["t"]]],[11,"try_from","","",37,[[["u"]],["result"]]],[11,"try_into","","",37,[[["self"]],["result"]]],[11,"into","","",37,[[["self"]],["u"]]],[11,"borrow","","",37,[[["self"]],["t"]]],[11,"borrow_mut","","",37,[[["self"]],["t"]]],[11,"get_type_id","","",37,[[["self"]],["typeid"]]],[11,"to_owned","","",37,[[["self"]],["t"]]],[11,"clone_into","","",37,N],[11,"from","","",38,[[["t"]],["t"]]],[11,"try_from","","",38,[[["u"]],["result"]]],[11,"try_into","","",38,[[["self"]],["result"]]],[11,"into","","",38,[[["self"]],["u"]]],[11,"borrow","","",38,[[["self"]],["t"]]],[11,"borrow_mut","","",38,[[["self"]],["t"]]],[11,"get_type_id","","",38,[[["self"]],["typeid"]]],[11,"from","","",39,[[["t"]],["t"]]],[11,"try_from","","",39,[[["u"]],["result"]]],[11,"try_into","","",39,[[["self"]],["result"]]],[11,"into","","",39,[[["self"]],["u"]]],[11,"borrow","","",39,[[["self"]],["t"]]],[11,"borrow_mut","","",39,[[["self"]],["t"]]],[11,"get_type_id","","",39,[[["self"]],["typeid"]]],[11,"to_owned","","",39,[[["self"]],["t"]]],[11,"clone_into","","",39,N],[11,"from","kfs_kernel::i386::registers::eflags","",40,[[["t"]],["t"]]],[11,"try_from","","",40,[[["u"]],["result"]]],[11,"try_into","","",40,[[["self"]],["result"]]],[11,"into","","",40,[[["self"]],["u"]]],[11,"borrow","","",40,[[["self"]],["t"]]],[11,"borrow_mut","","",40,[[["self"]],["t"]]],[11,"get_type_id","","",40,[[["self"]],["typeid"]]],[11,"to_owned","","",40,[[["self"]],["t"]]],[11,"clone_into","","",40,N],[11,"from","kfs_kernel::i386::stack","",41,[[["t"]],["t"]]],[11,"try_from","","",41,[[["u"]],["result"]]],[11,"try_into","","",41,[[["self"]],["result"]]],[11,"into","","",41,[[["self"]],["u"]]],[11,"borrow","","",41,[[["self"]],["t"]]],[11,"borrow_mut","","",41,[[["self"]],["t"]]],[11,"get_type_id","","",41,[[["self"]],["typeid"]]],[11,"from","","",42,[[["t"]],["t"]]],[11,"try_from","","",42,[[["u"]],["result"]]],[11,"try_into","","",42,[[["self"]],["result"]]],[11,"into","","",42,[[["self"]],["u"]]],[11,"borrow","","",42,[[["self"]],["t"]]],[11,"borrow_mut","","",42,[[["self"]],["t"]]],[11,"get_type_id","","",42,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::i386::structures::gdt","",43,[[["t"]],["t"]]],[11,"try_from","","",43,[[["u"]],["result"]]],[11,"try_into","","",43,[[["self"]],["result"]]],[11,"into","","",43,[[["self"]],["u"]]],[11,"borrow","","",43,[[["self"]],["t"]]],[11,"borrow_mut","","",43,[[["self"]],["t"]]],[11,"get_type_id","","",43,[[["self"]],["typeid"]]],[11,"to_owned","","",43,[[["self"]],["t"]]],[11,"clone_into","","",43,N],[11,"from","kfs_kernel::i386::structures::idt","",44,[[["t"]],["t"]]],[11,"try_from","","",44,[[["u"]],["result"]]],[11,"try_into","","",44,[[["self"]],["result"]]],[11,"into","","",44,[[["self"]],["u"]]],[11,"borrow","","",44,[[["self"]],["t"]]],[11,"borrow_mut","","",44,[[["self"]],["t"]]],[11,"get_type_id","","",44,[[["self"]],["typeid"]]],[11,"from","","",45,[[["t"]],["t"]]],[11,"try_from","","",45,[[["u"]],["result"]]],[11,"try_into","","",45,[[["self"]],["result"]]],[11,"into","","",45,[[["self"]],["u"]]],[11,"borrow","","",45,[[["self"]],["t"]]],[11,"borrow_mut","","",45,[[["self"]],["t"]]],[11,"get_type_id","","",45,[[["self"]],["typeid"]]],[11,"to_owned","","",45,[[["self"]],["t"]]],[11,"clone_into","","",45,N],[11,"from","","",46,[[["t"]],["t"]]],[11,"try_from","","",46,[[["u"]],["result"]]],[11,"try_into","","",46,[[["self"]],["result"]]],[11,"into","","",46,[[["self"]],["u"]]],[11,"borrow","","",46,[[["self"]],["t"]]],[11,"borrow_mut","","",46,[[["self"]],["t"]]],[11,"get_type_id","","",46,[[["self"]],["typeid"]]],[11,"to_owned","","",46,[[["self"]],["t"]]],[11,"clone_into","","",46,N],[11,"bit","","",46,[[["self"],["usize"]],["bool"]]],[11,"set_bit","","",46,N],[11,"from","","",47,[[["t"]],["t"]]],[11,"try_from","","",47,[[["u"]],["result"]]],[11,"try_into","","",47,[[["self"]],["result"]]],[11,"into","","",47,[[["self"]],["u"]]],[11,"borrow","","",47,[[["self"]],["t"]]],[11,"borrow_mut","","",47,[[["self"]],["t"]]],[11,"get_type_id","","",47,[[["self"]],["typeid"]]],[11,"from","","",48,[[["t"]],["t"]]],[11,"try_from","","",48,[[["u"]],["result"]]],[11,"try_into","","",48,[[["self"]],["result"]]],[11,"into","","",48,[[["self"]],["u"]]],[11,"borrow","","",48,[[["self"]],["t"]]],[11,"borrow_mut","","",48,[[["self"]],["t"]]],[11,"get_type_id","","",48,[[["self"]],["typeid"]]],[11,"to_owned","","",48,[[["self"]],["t"]]],[11,"clone_into","","",48,N],[11,"from","","",49,[[["t"]],["t"]]],[11,"try_from","","",49,[[["u"]],["result"]]],[11,"try_into","","",49,[[["self"]],["result"]]],[11,"into","","",49,[[["self"]],["u"]]],[11,"borrow","","",49,[[["self"]],["t"]]],[11,"borrow_mut","","",49,[[["self"]],["t"]]],[11,"get_type_id","","",49,[[["self"]],["typeid"]]],[11,"to_owned","","",49,[[["self"]],["t"]]],[11,"clone_into","","",49,N],[11,"from","kfs_kernel::i386::process_switch","",50,[[["t"]],["t"]]],[11,"try_from","","",50,[[["u"]],["result"]]],[11,"try_into","","",50,[[["self"]],["result"]]],[11,"into","","",50,[[["self"]],["u"]]],[11,"borrow","","",50,[[["self"]],["t"]]],[11,"borrow_mut","","",50,[[["self"]],["t"]]],[11,"get_type_id","","",50,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::i386::gdt","",51,[[["t"]],["t"]]],[11,"try_from","","",51,[[["u"]],["result"]]],[11,"try_into","","",51,[[["self"]],["result"]]],[11,"into","","",51,[[["self"]],["u"]]],[11,"borrow","","",51,[[["self"]],["t"]]],[11,"borrow_mut","","",51,[[["self"]],["t"]]],[11,"get_type_id","","",51,[[["self"]],["typeid"]]],[11,"from","","",52,[[["t"]],["t"]]],[11,"try_from","","",52,[[["u"]],["result"]]],[11,"try_into","","",52,[[["self"]],["result"]]],[11,"into","","",52,[[["self"]],["u"]]],[11,"borrow","","",52,[[["self"]],["t"]]],[11,"borrow_mut","","",52,[[["self"]],["t"]]],[11,"get_type_id","","",52,[[["self"]],["typeid"]]],[11,"from","","",53,[[["t"]],["t"]]],[11,"try_from","","",53,[[["u"]],["result"]]],[11,"try_into","","",53,[[["self"]],["result"]]],[11,"into","","",53,[[["self"]],["u"]]],[11,"borrow","","",53,[[["self"]],["t"]]],[11,"borrow_mut","","",53,[[["self"]],["t"]]],[11,"get_type_id","","",53,[[["self"]],["typeid"]]],[11,"to_owned","","",53,[[["self"]],["t"]]],[11,"clone_into","","",53,N],[11,"from","","",54,[[["t"]],["t"]]],[11,"try_from","","",54,[[["u"]],["result"]]],[11,"try_into","","",54,[[["self"]],["result"]]],[11,"into","","",54,[[["self"]],["u"]]],[11,"borrow","","",54,[[["self"]],["t"]]],[11,"borrow_mut","","",54,[[["self"]],["t"]]],[11,"get_type_id","","",54,[[["self"]],["typeid"]]],[11,"to_owned","","",54,[[["self"]],["t"]]],[11,"clone_into","","",54,N],[11,"from","","",55,[[["t"]],["t"]]],[11,"try_from","","",55,[[["u"]],["result"]]],[11,"try_into","","",55,[[["self"]],["result"]]],[11,"into","","",55,[[["self"]],["u"]]],[11,"borrow","","",55,[[["self"]],["t"]]],[11,"borrow_mut","","",55,[[["self"]],["t"]]],[11,"get_type_id","","",55,[[["self"]],["typeid"]]],[11,"to_owned","","",55,[[["self"]],["t"]]],[11,"clone_into","","",55,N],[11,"from","kfs_kernel::utils::io","",56,[[["t"]],["t"]]],[11,"try_from","","",56,[[["u"]],["result"]]],[11,"try_into","","",56,[[["self"]],["result"]]],[11,"into","","",56,[[["self"]],["u"]]],[11,"borrow","","",56,[[["self"]],["t"]]],[11,"borrow_mut","","",56,[[["self"]],["t"]]],[11,"get_type_id","","",56,[[["self"]],["typeid"]]],[11,"to_owned","","",56,[[["self"]],["t"]]],[11,"clone_into","","",56,N],[11,"from","kfs_kernel::i386::instructions::tables","",57,[[["t"]],["t"]]],[11,"try_from","","",57,[[["u"]],["result"]]],[11,"try_into","","",57,[[["self"]],["result"]]],[11,"into","","",57,[[["self"]],["u"]]],[11,"borrow","","",57,[[["self"]],["t"]]],[11,"borrow_mut","","",57,[[["self"]],["t"]]],[11,"get_type_id","","",57,[[["self"]],["typeid"]]],[11,"to_owned","","",57,[[["self"]],["t"]]],[11,"clone_into","","",57,N],[11,"from","kfs_kernel::interrupts","",58,[[["t"]],["t"]]],[11,"try_from","","",58,[[["u"]],["result"]]],[11,"try_into","","",58,[[["self"]],["result"]]],[11,"into","","",58,[[["self"]],["u"]]],[11,"borrow","","",58,[[["self"]],["t"]]],[11,"borrow_mut","","",58,[[["self"]],["t"]]],[11,"get_type_id","","",58,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::interrupts::syscalls","",59,[[["t"]],["t"]]],[11,"try_from","","",59,[[["u"]],["result"]]],[11,"try_into","","",59,[[["self"]],["result"]]],[11,"into","","",59,[[["self"]],["u"]]],[11,"borrow","","",59,[[["self"]],["t"]]],[11,"borrow_mut","","",59,[[["self"]],["t"]]],[11,"get_type_id","","",59,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::frame_allocator","",128,[[["t"]],["t"]]],[11,"try_from","","",128,[[["u"]],["result"]]],[11,"try_into","","",128,[[["self"]],["result"]]],[11,"into","","",128,[[["self"]],["u"]]],[11,"borrow","","",128,[[["self"]],["t"]]],[11,"borrow_mut","","",128,[[["self"]],["t"]]],[11,"get_type_id","","",128,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::frame_allocator::physical_mem_region","",60,[[["t"]],["t"]]],[11,"try_from","","",60,[[["u"]],["result"]]],[11,"try_into","","",60,[[["self"]],["result"]]],[11,"into","","",60,[[["self"]],["u"]]],[11,"borrow","","",60,[[["self"]],["t"]]],[11,"borrow_mut","","",60,[[["self"]],["t"]]],[11,"get_type_id","","",60,[[["self"]],["typeid"]]],[11,"into_iter","","",61,[[["self"]],["i"]]],[11,"from","","",61,[[["t"]],["t"]]],[11,"try_from","","",61,[[["u"]],["result"]]],[11,"try_into","","",61,[[["self"]],["result"]]],[11,"into","","",61,[[["self"]],["u"]]],[11,"borrow","","",61,[[["self"]],["t"]]],[11,"borrow_mut","","",61,[[["self"]],["t"]]],[11,"get_type_id","","",61,[[["self"]],["typeid"]]],[11,"to_owned","","",61,[[["self"]],["t"]]],[11,"clone_into","","",61,N],[11,"from","kfs_kernel::frame_allocator::i386","",62,[[["t"]],["t"]]],[11,"try_from","","",62,[[["u"]],["result"]]],[11,"try_into","","",62,[[["self"]],["result"]]],[11,"into","","",62,[[["self"]],["u"]]],[11,"borrow","","",62,[[["self"]],["t"]]],[11,"borrow_mut","","",62,[[["self"]],["t"]]],[11,"get_type_id","","",62,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::heap_allocator","",65,[[["t"]],["t"]]],[11,"try_from","","",65,[[["u"]],["result"]]],[11,"try_into","","",65,[[["self"]],["result"]]],[11,"into","","",65,[[["self"]],["u"]]],[11,"borrow","","",65,[[["self"]],["t"]]],[11,"borrow_mut","","",65,[[["self"]],["t"]]],[11,"get_type_id","","",65,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::devices::rs232","",66,[[["t"]],["t"]]],[11,"try_from","","",66,[[["u"]],["result"]]],[11,"try_into","","",66,[[["self"]],["result"]]],[11,"into","","",66,[[["self"]],["u"]]],[11,"borrow","","",66,[[["self"]],["t"]]],[11,"borrow_mut","","",66,[[["self"]],["t"]]],[11,"get_type_id","","",66,[[["self"]],["typeid"]]],[11,"to_owned","","",66,[[["self"]],["t"]]],[11,"clone_into","","",66,N],[11,"from","","",67,[[["t"]],["t"]]],[11,"try_from","","",67,[[["u"]],["result"]]],[11,"try_into","","",67,[[["self"]],["result"]]],[11,"into","","",67,[[["self"]],["u"]]],[11,"borrow","","",67,[[["self"]],["t"]]],[11,"borrow_mut","","",67,[[["self"]],["t"]]],[11,"get_type_id","","",67,[[["self"]],["typeid"]]],[11,"to_owned","","",67,[[["self"]],["t"]]],[11,"clone_into","","",67,N],[11,"to_string","","",67,[[["self"]],["string"]]],[11,"from","","",68,[[["t"]],["t"]]],[11,"try_from","","",68,[[["u"]],["result"]]],[11,"try_into","","",68,[[["self"]],["result"]]],[11,"into","","",68,[[["self"]],["u"]]],[11,"borrow","","",68,[[["self"]],["t"]]],[11,"borrow_mut","","",68,[[["self"]],["t"]]],[11,"get_type_id","","",68,[[["self"]],["typeid"]]],[11,"from","","",70,[[["t"]],["t"]]],[11,"try_from","","",70,[[["u"]],["result"]]],[11,"try_into","","",70,[[["self"]],["result"]]],[11,"into","","",70,[[["self"]],["u"]]],[11,"borrow","","",70,[[["self"]],["t"]]],[11,"borrow_mut","","",70,[[["self"]],["t"]]],[11,"get_type_id","","",70,[[["self"]],["typeid"]]],[11,"from","","",69,[[["t"]],["t"]]],[11,"try_from","","",69,[[["u"]],["result"]]],[11,"try_into","","",69,[[["self"]],["result"]]],[11,"into","","",69,[[["self"]],["u"]]],[11,"borrow","","",69,[[["self"]],["t"]]],[11,"borrow_mut","","",69,[[["self"]],["t"]]],[11,"get_type_id","","",69,[[["self"]],["typeid"]]],[11,"to_owned","","",69,[[["self"]],["t"]]],[11,"clone_into","","",69,N],[11,"from","kfs_kernel::devices::pit","",71,[[["t"]],["t"]]],[11,"try_from","","",71,[[["u"]],["result"]]],[11,"try_into","","",71,[[["self"]],["result"]]],[11,"into","","",71,[[["self"]],["u"]]],[11,"borrow","","",71,[[["self"]],["t"]]],[11,"borrow_mut","","",71,[[["self"]],["t"]]],[11,"get_type_id","","",71,[[["self"]],["typeid"]]],[11,"from","","",72,[[["t"]],["t"]]],[11,"try_from","","",72,[[["u"]],["result"]]],[11,"try_into","","",72,[[["self"]],["result"]]],[11,"into","","",72,[[["self"]],["u"]]],[11,"borrow","","",72,[[["self"]],["t"]]],[11,"borrow_mut","","",72,[[["self"]],["t"]]],[11,"get_type_id","","",72,[[["self"]],["typeid"]]],[11,"to_owned","","",72,[[["self"]],["t"]]],[11,"clone_into","","",72,N],[11,"from","","",73,[[["t"]],["t"]]],[11,"try_from","","",73,[[["u"]],["result"]]],[11,"try_into","","",73,[[["self"]],["result"]]],[11,"into","","",73,[[["self"]],["u"]]],[11,"borrow","","",73,[[["self"]],["t"]]],[11,"borrow_mut","","",73,[[["self"]],["t"]]],[11,"get_type_id","","",73,[[["self"]],["typeid"]]],[11,"from","","",74,[[["t"]],["t"]]],[11,"try_from","","",74,[[["u"]],["result"]]],[11,"try_into","","",74,[[["self"]],["result"]]],[11,"into","","",74,[[["self"]],["u"]]],[11,"borrow","","",74,[[["self"]],["t"]]],[11,"borrow_mut","","",74,[[["self"]],["t"]]],[11,"get_type_id","","",74,[[["self"]],["typeid"]]],[11,"from","","",75,[[["t"]],["t"]]],[11,"try_from","","",75,[[["u"]],["result"]]],[11,"try_into","","",75,[[["self"]],["result"]]],[11,"into","","",75,[[["self"]],["u"]]],[11,"borrow","","",75,[[["self"]],["t"]]],[11,"borrow_mut","","",75,[[["self"]],["t"]]],[11,"get_type_id","","",75,[[["self"]],["typeid"]]],[11,"from","","",76,[[["t"]],["t"]]],[11,"try_from","","",76,[[["u"]],["result"]]],[11,"try_into","","",76,[[["self"]],["result"]]],[11,"into","","",76,[[["self"]],["u"]]],[11,"borrow","","",76,[[["self"]],["t"]]],[11,"borrow_mut","","",76,[[["self"]],["t"]]],[11,"get_type_id","","",76,[[["self"]],["typeid"]]],[11,"to_owned","","",76,[[["self"]],["t"]]],[11,"clone_into","","",76,N],[11,"from","kfs_kernel::devices::pic","",77,[[["t"]],["t"]]],[11,"try_from","","",77,[[["u"]],["result"]]],[11,"try_into","","",77,[[["self"]],["result"]]],[11,"into","","",77,[[["self"]],["u"]]],[11,"borrow","","",77,[[["self"]],["t"]]],[11,"borrow_mut","","",77,[[["self"]],["t"]]],[11,"get_type_id","","",77,[[["self"]],["typeid"]]],[11,"to_owned","","",77,[[["self"]],["t"]]],[11,"clone_into","","",77,N],[11,"from","","",78,[[["t"]],["t"]]],[11,"try_from","","",78,[[["u"]],["result"]]],[11,"try_into","","",78,[[["self"]],["result"]]],[11,"into","","",78,[[["self"]],["u"]]],[11,"borrow","","",78,[[["self"]],["t"]]],[11,"borrow_mut","","",78,[[["self"]],["t"]]],[11,"get_type_id","","",78,[[["self"]],["typeid"]]],[11,"from","","",79,[[["t"]],["t"]]],[11,"try_from","","",79,[[["u"]],["result"]]],[11,"try_into","","",79,[[["self"]],["result"]]],[11,"into","","",79,[[["self"]],["u"]]],[11,"borrow","","",79,[[["self"]],["t"]]],[11,"borrow_mut","","",79,[[["self"]],["t"]]],[11,"get_type_id","","",79,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::sync","",80,[[["t"]],["t"]]],[11,"try_from","","",80,[[["u"]],["result"]]],[11,"try_into","","",80,[[["self"]],["result"]]],[11,"into","","",80,[[["self"]],["u"]]],[11,"borrow","","",80,[[["self"]],["t"]]],[11,"borrow_mut","","",80,[[["self"]],["t"]]],[11,"get_type_id","","",80,[[["self"]],["typeid"]]],[11,"from","","",81,[[["t"]],["t"]]],[11,"try_from","","",81,[[["u"]],["result"]]],[11,"try_into","","",81,[[["self"]],["result"]]],[11,"into","","",81,[[["self"]],["u"]]],[11,"borrow","","",81,[[["self"]],["t"]]],[11,"borrow_mut","","",81,[[["self"]],["t"]]],[11,"get_type_id","","",81,[[["self"]],["typeid"]]],[11,"from","","",82,[[["t"]],["t"]]],[11,"try_from","","",82,[[["u"]],["result"]]],[11,"try_into","","",82,[[["self"]],["result"]]],[11,"into","","",82,[[["self"]],["u"]]],[11,"borrow","","",82,[[["self"]],["t"]]],[11,"borrow_mut","","",82,[[["self"]],["t"]]],[11,"get_type_id","","",82,[[["self"]],["typeid"]]],[11,"from","","",83,[[["t"]],["t"]]],[11,"try_from","","",83,[[["u"]],["result"]]],[11,"try_into","","",83,[[["self"]],["result"]]],[11,"into","","",83,[[["self"]],["u"]]],[11,"borrow","","",83,[[["self"]],["t"]]],[11,"borrow_mut","","",83,[[["self"]],["t"]]],[11,"get_type_id","","",83,[[["self"]],["typeid"]]],[11,"from","","",84,[[["t"]],["t"]]],[11,"try_from","","",84,[[["u"]],["result"]]],[11,"try_into","","",84,[[["self"]],["result"]]],[11,"into","","",84,[[["self"]],["u"]]],[11,"borrow","","",84,[[["self"]],["t"]]],[11,"borrow_mut","","",84,[[["self"]],["t"]]],[11,"get_type_id","","",84,[[["self"]],["typeid"]]],[11,"from","","",85,[[["t"]],["t"]]],[11,"try_from","","",85,[[["u"]],["result"]]],[11,"try_into","","",85,[[["self"]],["result"]]],[11,"into","","",85,[[["self"]],["u"]]],[11,"borrow","","",85,[[["self"]],["t"]]],[11,"borrow_mut","","",85,[[["self"]],["t"]]],[11,"get_type_id","","",85,[[["self"]],["typeid"]]],[11,"from","","",86,[[["t"]],["t"]]],[11,"try_from","","",86,[[["u"]],["result"]]],[11,"try_into","","",86,[[["self"]],["result"]]],[11,"into","","",86,[[["self"]],["u"]]],[11,"borrow","","",86,[[["self"]],["t"]]],[11,"borrow_mut","","",86,[[["self"]],["t"]]],[11,"get_type_id","","",86,[[["self"]],["typeid"]]],[11,"from","","",87,[[["t"]],["t"]]],[11,"try_from","","",87,[[["u"]],["result"]]],[11,"try_into","","",87,[[["self"]],["result"]]],[11,"into","","",87,[[["self"]],["u"]]],[11,"borrow","","",87,[[["self"]],["t"]]],[11,"borrow_mut","","",87,[[["self"]],["t"]]],[11,"get_type_id","","",87,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::process","",89,[[["t"]],["t"]]],[11,"try_from","","",89,[[["u"]],["result"]]],[11,"try_into","","",89,[[["self"]],["result"]]],[11,"into","","",89,[[["self"]],["u"]]],[11,"borrow","","",89,[[["self"]],["t"]]],[11,"borrow_mut","","",89,[[["self"]],["t"]]],[11,"get_type_id","","",89,[[["self"]],["typeid"]]],[11,"from","","",90,[[["t"]],["t"]]],[11,"try_from","","",90,[[["u"]],["result"]]],[11,"try_into","","",90,[[["self"]],["result"]]],[11,"into","","",90,[[["self"]],["u"]]],[11,"borrow","","",90,[[["self"]],["t"]]],[11,"borrow_mut","","",90,[[["self"]],["t"]]],[11,"get_type_id","","",90,[[["self"]],["typeid"]]],[11,"from","","",91,[[["t"]],["t"]]],[11,"try_from","","",91,[[["u"]],["result"]]],[11,"try_into","","",91,[[["self"]],["result"]]],[11,"into","","",91,[[["self"]],["u"]]],[11,"borrow","","",91,[[["self"]],["t"]]],[11,"borrow_mut","","",91,[[["self"]],["t"]]],[11,"get_type_id","","",91,[[["self"]],["typeid"]]],[11,"from","","",92,[[["t"]],["t"]]],[11,"try_from","","",92,[[["u"]],["result"]]],[11,"try_into","","",92,[[["self"]],["result"]]],[11,"into","","",92,[[["self"]],["u"]]],[11,"borrow","","",92,[[["self"]],["t"]]],[11,"borrow_mut","","",92,[[["self"]],["t"]]],[11,"get_type_id","","",92,[[["self"]],["typeid"]]],[11,"from","","",93,[[["t"]],["t"]]],[11,"try_from","","",93,[[["u"]],["result"]]],[11,"try_into","","",93,[[["self"]],["result"]]],[11,"into","","",93,[[["self"]],["u"]]],[11,"borrow","","",93,[[["self"]],["t"]]],[11,"borrow_mut","","",93,[[["self"]],["t"]]],[11,"get_type_id","","",93,[[["self"]],["typeid"]]],[11,"from","","",94,[[["t"]],["t"]]],[11,"try_from","","",94,[[["u"]],["result"]]],[11,"try_into","","",94,[[["self"]],["result"]]],[11,"into","","",94,[[["self"]],["u"]]],[11,"borrow","","",94,[[["self"]],["t"]]],[11,"borrow_mut","","",94,[[["self"]],["t"]]],[11,"get_type_id","","",94,[[["self"]],["typeid"]]],[11,"from","","",95,[[["t"]],["t"]]],[11,"try_from","","",95,[[["u"]],["result"]]],[11,"try_into","","",95,[[["self"]],["result"]]],[11,"into","","",95,[[["self"]],["u"]]],[11,"borrow","","",95,[[["self"]],["t"]]],[11,"borrow_mut","","",95,[[["self"]],["t"]]],[11,"get_type_id","","",95,[[["self"]],["typeid"]]],[11,"to_owned","","",95,[[["self"]],["t"]]],[11,"clone_into","","",95,N],[11,"from","kfs_kernel::process::capabilities","",96,[[["t"]],["t"]]],[11,"try_from","","",96,[[["u"]],["result"]]],[11,"try_into","","",96,[[["self"]],["result"]]],[11,"into","","",96,[[["self"]],["u"]]],[11,"borrow","","",96,[[["self"]],["t"]]],[11,"borrow_mut","","",96,[[["self"]],["t"]]],[11,"get_type_id","","",96,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::mem","",97,[[["t"]],["t"]]],[11,"try_from","","",97,[[["u"]],["result"]]],[11,"try_into","","",97,[[["self"]],["result"]]],[11,"into","","",97,[[["self"]],["u"]]],[11,"borrow","","",97,[[["self"]],["t"]]],[11,"borrow_mut","","",97,[[["self"]],["t"]]],[11,"get_type_id","","",97,[[["self"]],["typeid"]]],[11,"to_owned","","",97,[[["self"]],["t"]]],[11,"clone_into","","",97,N],[11,"to_string","","",97,[[["self"]],["string"]]],[11,"from","","",98,[[["t"]],["t"]]],[11,"try_from","","",98,[[["u"]],["result"]]],[11,"try_into","","",98,[[["self"]],["result"]]],[11,"into","","",98,[[["self"]],["u"]]],[11,"borrow","","",98,[[["self"]],["t"]]],[11,"borrow_mut","","",98,[[["self"]],["t"]]],[11,"get_type_id","","",98,[[["self"]],["typeid"]]],[11,"to_owned","","",98,[[["self"]],["t"]]],[11,"clone_into","","",98,N],[11,"to_string","","",98,[[["self"]],["string"]]],[11,"from","","",99,[[["t"]],["t"]]],[11,"try_from","","",99,[[["u"]],["result"]]],[11,"try_into","","",99,[[["self"]],["result"]]],[11,"into","","",99,[[["self"]],["u"]]],[11,"borrow","","",99,[[["self"]],["t"]]],[11,"borrow_mut","","",99,[[["self"]],["t"]]],[11,"get_type_id","","",99,[[["self"]],["typeid"]]],[11,"to_owned","","",99,[[["self"]],["t"]]],[11,"clone_into","","",99,N],[11,"from","","",100,[[["t"]],["t"]]],[11,"try_from","","",100,[[["u"]],["result"]]],[11,"try_into","","",100,[[["self"]],["result"]]],[11,"into","","",100,[[["self"]],["u"]]],[11,"borrow","","",100,[[["self"]],["t"]]],[11,"borrow_mut","","",100,[[["self"]],["t"]]],[11,"get_type_id","","",100,[[["self"]],["typeid"]]],[11,"to_owned","","",100,[[["self"]],["t"]]],[11,"clone_into","","",100,N],[11,"from","","",101,[[["t"]],["t"]]],[11,"try_from","","",101,[[["u"]],["result"]]],[11,"try_into","","",101,[[["self"]],["result"]]],[11,"into","","",101,[[["self"]],["u"]]],[11,"borrow","","",101,[[["self"]],["t"]]],[11,"borrow_mut","","",101,[[["self"]],["t"]]],[11,"get_type_id","","",101,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::ipc","",102,[[["t"]],["t"]]],[11,"try_from","","",102,[[["u"]],["result"]]],[11,"try_into","","",102,[[["self"]],["result"]]],[11,"into","","",102,[[["self"]],["u"]]],[11,"borrow","","",102,[[["self"]],["t"]]],[11,"borrow_mut","","",102,[[["self"]],["t"]]],[11,"get_type_id","","",102,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::ipc::session","",103,[[["t"]],["t"]]],[11,"try_from","","",103,[[["u"]],["result"]]],[11,"try_into","","",103,[[["self"]],["result"]]],[11,"into","","",103,[[["self"]],["u"]]],[11,"borrow","","",103,[[["self"]],["t"]]],[11,"borrow_mut","","",103,[[["self"]],["t"]]],[11,"get_type_id","","",103,[[["self"]],["typeid"]]],[11,"from","","",104,[[["t"]],["t"]]],[11,"try_from","","",104,[[["u"]],["result"]]],[11,"try_into","","",104,[[["self"]],["result"]]],[11,"into","","",104,[[["self"]],["u"]]],[11,"borrow","","",104,[[["self"]],["t"]]],[11,"borrow_mut","","",104,[[["self"]],["t"]]],[11,"get_type_id","","",104,[[["self"]],["typeid"]]],[11,"from","","",105,[[["t"]],["t"]]],[11,"try_from","","",105,[[["u"]],["result"]]],[11,"try_into","","",105,[[["self"]],["result"]]],[11,"into","","",105,[[["self"]],["u"]]],[11,"borrow","","",105,[[["self"]],["t"]]],[11,"borrow_mut","","",105,[[["self"]],["t"]]],[11,"get_type_id","","",105,[[["self"]],["typeid"]]],[11,"to_owned","","",105,[[["self"]],["t"]]],[11,"clone_into","","",105,N],[11,"from","","",106,[[["t"]],["t"]]],[11,"try_from","","",106,[[["u"]],["result"]]],[11,"try_into","","",106,[[["self"]],["result"]]],[11,"into","","",106,[[["self"]],["u"]]],[11,"borrow","","",106,[[["self"]],["t"]]],[11,"borrow_mut","","",106,[[["self"]],["t"]]],[11,"get_type_id","","",106,[[["self"]],["typeid"]]],[11,"to_owned","","",106,[[["self"]],["t"]]],[11,"clone_into","","",106,N],[11,"from","","",107,[[["t"]],["t"]]],[11,"try_from","","",107,[[["u"]],["result"]]],[11,"try_into","","",107,[[["self"]],["result"]]],[11,"into","","",107,[[["self"]],["u"]]],[11,"borrow","","",107,[[["self"]],["t"]]],[11,"borrow_mut","","",107,[[["self"]],["t"]]],[11,"get_type_id","","",107,[[["self"]],["typeid"]]],[11,"bit","","",107,[[["self"],["usize"]],["bool"]]],[11,"set_bit","","",107,N],[11,"from","","",108,[[["t"]],["t"]]],[11,"try_from","","",108,[[["u"]],["result"]]],[11,"try_into","","",108,[[["self"]],["result"]]],[11,"into","","",108,[[["self"]],["u"]]],[11,"borrow","","",108,[[["self"]],["t"]]],[11,"borrow_mut","","",108,[[["self"]],["t"]]],[11,"get_type_id","","",108,[[["self"]],["typeid"]]],[11,"bit","","",108,[[["self"],["usize"]],["bool"]]],[11,"set_bit","","",108,N],[11,"from","","",109,[[["t"]],["t"]]],[11,"try_from","","",109,[[["u"]],["result"]]],[11,"try_into","","",109,[[["self"]],["result"]]],[11,"into","","",109,[[["self"]],["u"]]],[11,"borrow","","",109,[[["self"]],["t"]]],[11,"borrow_mut","","",109,[[["self"]],["t"]]],[11,"get_type_id","","",109,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::ipc::port","",110,[[["t"]],["t"]]],[11,"try_from","","",110,[[["u"]],["result"]]],[11,"try_into","","",110,[[["self"]],["result"]]],[11,"into","","",110,[[["self"]],["u"]]],[11,"borrow","","",110,[[["self"]],["t"]]],[11,"borrow_mut","","",110,[[["self"]],["t"]]],[11,"get_type_id","","",110,[[["self"]],["typeid"]]],[11,"from","","",111,[[["t"]],["t"]]],[11,"try_from","","",111,[[["u"]],["result"]]],[11,"try_into","","",111,[[["self"]],["result"]]],[11,"into","","",111,[[["self"]],["u"]]],[11,"borrow","","",111,[[["self"]],["t"]]],[11,"borrow_mut","","",111,[[["self"]],["t"]]],[11,"get_type_id","","",111,[[["self"]],["typeid"]]],[11,"to_owned","","",111,[[["self"]],["t"]]],[11,"clone_into","","",111,N],[11,"from","","",112,[[["t"]],["t"]]],[11,"try_from","","",112,[[["u"]],["result"]]],[11,"try_into","","",112,[[["self"]],["result"]]],[11,"into","","",112,[[["self"]],["u"]]],[11,"borrow","","",112,[[["self"]],["t"]]],[11,"borrow_mut","","",112,[[["self"]],["t"]]],[11,"get_type_id","","",112,[[["self"]],["typeid"]]],[11,"to_owned","","",112,[[["self"]],["t"]]],[11,"clone_into","","",112,N],[11,"from","","",113,[[["t"]],["t"]]],[11,"try_from","","",113,[[["u"]],["result"]]],[11,"try_into","","",113,[[["self"]],["result"]]],[11,"into","","",113,[[["self"]],["u"]]],[11,"borrow","","",113,[[["self"]],["t"]]],[11,"borrow_mut","","",113,[[["self"]],["t"]]],[11,"get_type_id","","",113,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::elf_loader","",114,[[["t"]],["t"]]],[11,"try_from","","",114,[[["u"]],["result"]]],[11,"try_into","","",114,[[["self"]],["result"]]],[11,"into","","",114,[[["self"]],["u"]]],[11,"borrow","","",114,[[["self"]],["t"]]],[11,"borrow_mut","","",114,[[["self"]],["t"]]],[11,"get_type_id","","",114,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::utils::io","",116,[[["t"]],["t"]]],[11,"try_from","","",116,[[["u"]],["result"]]],[11,"try_into","","",116,[[["self"]],["result"]]],[11,"into","","",116,[[["self"]],["u"]]],[11,"borrow","","",116,[[["self"]],["t"]]],[11,"borrow_mut","","",116,[[["self"]],["t"]]],[11,"get_type_id","","",116,[[["self"]],["typeid"]]],[11,"from","","",117,[[["t"]],["t"]]],[11,"try_from","","",117,[[["u"]],["result"]]],[11,"try_into","","",117,[[["self"]],["result"]]],[11,"into","","",117,[[["self"]],["u"]]],[11,"borrow","","",117,[[["self"]],["t"]]],[11,"borrow_mut","","",117,[[["self"]],["t"]]],[11,"get_type_id","","",117,[[["self"]],["typeid"]]],[11,"from","kfs_kernel::utils","",119,[[["t"]],["t"]]],[11,"try_from","","",119,[[["u"]],["result"]]],[11,"try_into","","",119,[[["self"]],["result"]]],[11,"into","","",119,[[["self"]],["u"]]],[11,"borrow","","",119,[[["self"]],["t"]]],[11,"borrow_mut","","",119,[[["self"]],["t"]]],[11,"get_type_id","","",119,[[["self"]],["typeid"]]],[11,"from","","",120,[[["t"]],["t"]]],[11,"try_from","","",120,[[["u"]],["result"]]],[11,"try_into","","",120,[[["self"]],["result"]]],[11,"into","","",120,[[["self"]],["u"]]],[11,"borrow","","",120,[[["self"]],["t"]]],[11,"borrow_mut","","",120,[[["self"]],["t"]]],[11,"get_type_id","","",120,[[["self"]],["typeid"]]],[11,"fmt","kfs_kernel::sync","",81,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",85,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",82,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",83,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",80,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",84,[[["self"],["formatter"]],["result",["error"]]]],[11,"drop","","The dropping of the MutexGuard will release the lock it…",85,N],[11,"drop","","",83,N],[11,"drop","","",82,N],[11,"deref","","",85,[[["self"]],["t"]]],[11,"deref","","",82,[[["self"]],["t"]]],[11,"deref","","",83,[[["self"]],["t"]]],[11,"deref_mut","","",83,[[["self"]],["t"]]],[11,"deref_mut","","",85,[[["self"]],["t"]]],[11,"default","","",84,[[],["mutex"]]],[11,"default","","",81,[[],["rwlock"]]],[11,"fmt","kfs_kernel::error","",29,[[["self"],["formatter"]],["result",["error"]]]],[11,"clone","","",29,[[["self"]],["kernelerror"]]],[11,"eq","","",29,[[["self"],["kernelerror"]],["bool"]]],[11,"ne","","",29,[[["self"],["kernelerror"]],["bool"]]],[11,"fmt","","",29,[[["self"],["formatter"]],["result",["error"]]]],[11,"assert_receiver_is_total_eq","","",29,N],[11,"fmt","kfs_kernel::utils","",119,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","kfs_kernel::utils::io","",56,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",116,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","kfs_kernel::utils","",120,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","kfs_kernel::utils::io","",117,[[["self"],["formatter"]],["result",["error"]]]],[11,"clone","","",56,[[["self"]],["pio"]]],[11,"read","","Read",56,[[["self"]],["u32"]]],[11,"write","","Write",56,N],[11,"read","","Read",56,[[["self"]],["u8"]]],[11,"write","","Write",56,N],[11,"read","","Read",56,[[["self"]],["u16"]]],[11,"write","","Write",56,N],[11,"is_unused","kfs_kernel::paging::arch::i386::entry","Is the entry unused ?",18,[[["self"]],["bool"]]],[11,"set_unused","","Clear the entry",18,[[["self"]],["pagestate",["physicaladdress"]]]],[11,"is_guard","","Is the entry a page guard ?",18,[[["self"]],["bool"]]],[11,"flags","","Get the current entry flags",18,[[["self"]],["i386entryflags"]]],[11,"pointed_frame","","Get the associated physical address, if available",18,[[["self"]],["pagestate",["physicaladdress"]]]],[11,"set","","Sets the entry",18,[[["self"],["physicaladdress"],["i386entryflags"]]]],[11,"set_guard","","Make this entry a page guard",18,[[["self"]]]],[11,"entries","kfs_kernel::paging::arch::i386::table","",20,N],[11,"table_level","","",20,[[],["usize"]]],[11,"get_child_table","","Panics, a page table has no children.",20,[[["self"],["usize"]],["pagestate",["smarthierarchicaltable"]]]],[11,"create_child_table","","Panics, a page table has no children.",20,[[["self"],["usize"]],["smarthierarchicaltable"]]],[11,"entries","","",21,N],[11,"table_level","","",21,[[],["usize"]]],[11,"get_child_table","","Gets a child [ActivePageTable] through recursive mapping.",21,[[["self"],["usize"]],["pagestate",["smarthierarchicaltable"]]]],[11,"create_child_table","","Creates a child [ActivePageTable], maps it at the given…",21,[[["self"],["usize"]],["smarthierarchicaltable",["activepagetable"]]]],[11,"entries","","",22,N],[11,"table_level","","",22,[[],["usize"]]],[11,"get_child_table","","Panics, a page table has no children.",22,[[["self"],["usize"]],["pagestate",["smarthierarchicaltable"]]]],[11,"create_child_table","","Panics, a page table has no children.",22,[[["self"],["usize"]],["smarthierarchicaltable"]]],[11,"entries","","",23,N],[11,"table_level","","",23,[[],["usize"]]],[11,"get_child_table","","Gets the child [InactivePageTable] at the given index.…",23,[[["self"],["usize"]],["pagestate",["smarthierarchicaltable"]]]],[11,"create_child_table","","Creates a child [InactivePageTable] at the given index,…",23,[[["self"],["usize"]],["smarthierarchicaltable",["inactivepagetable"]]]],[11,"flush_whole_cache","kfs_kernel::paging::hierarchical_table","",125,[[]]],[11,"flush_whole_cache","kfs_kernel::paging::arch::i386::table","",127,[[]]],[11,"get_top_level_table","kfs_kernel::paging::process_memory","",4,[[["self"]],["smarthierarchicaltable"]]],[11,"map_to_from_iterator","","",4,[[["self"],["i"],["virtualaddress"],["mappingaccessrights"]]]],[11,"guard","","",4,[[["self"],["virtualaddress"],["usize"]]]],[11,"unmap","","",4,[[["self"],["virtualaddress"],["usize"],["c"]]]],[11,"for_every_entry","","",4,[[["self"],["virtualaddress"],["usize"],["c"]]]],[11,"find_available_virtual_space_aligned","","",4,[[["self"],["usize"],["virtualaddress"],["virtualaddress"],["usize"]],["option",["virtualaddress"]]]],[11,"get_top_level_table","kfs_kernel::paging::arch::i386::table","Gets the [ActivePageDirectory] through recursive mapping.",126,[[["self"]],["smarthierarchicaltable",["activepagedirectory"]]]],[11,"get_top_level_table","","Gets the [InactivePageDirectory] by temporarily mapping it.",24,[[["self"]],["smarthierarchicaltable",["inactivepagedirectory"]]]],[11,"new","","",24,[[],["self"]]],[11,"switch_to","","",24,[[["self"]]]],[11,"copy_active_kernel_space","","",24,[[["self"]]]],[11,"is_currently_active","","",24,[[["self"]],["bool"]]],[11,"from_currently_active","","",24,[[],["self"]]],[11,"is_signaled","kfs_kernel::event","",26,[[["self"]],["bool"]]],[11,"register","","",26,[[["self"]]]],[11,"register","kfs_kernel::devices::pit","",75,[[["self"]]]],[11,"is_signaled","","",75,[[["self"]],["bool"]]],[11,"is_signaled","kfs_kernel::ipc::session","",106,[[["self"]],["bool"]]],[11,"register","","",106,[[["self"]]]],[11,"is_signaled","kfs_kernel::ipc::port","",112,[[["self"]],["bool"]]],[11,"register","","",112,[[["self"]]]],[11,"allocate_region","kfs_kernel::frame_allocator","Allocates a single [PhysicalMemRegion]. Frames are…",128,[[["usize"]],["result",["physicalmemregion","kernelerror"]]]],[11,"allocate_frames_fragmented","","Allocates physical frames, possibly fragmented across…",128,[[["usize"]],["result",["vec","kernelerror"]]]],[11,"free_region","","Frees an allocated physical region.",128,[[["physicalmemregion"]]]],[11,"check_is_allocated","","Checks that a physical region is marked allocated.",128,[[["physicaladdress"],["usize"]],["bool"]]],[11,"check_is_reserved","","Checks that a physical region is marked reserved. This…",128,[[["physicaladdress"],["usize"]],["bool"]]],[11,"lock","kfs_kernel::sync","",84,[[["self"]],["spinlockguard"]]],[11,"lock","","",86,[[["self"]],["spinlockirqguard"]]],[11,"lock","","",81,[[["self"]],["rwlockreadguard"]]],[11,"lock","","",81,[[["self"]],["rwlockwriteguard"]]],[11,"split_at","kfs_kernel::paging::mapping","Splits a mapping at a given offset.",7,[[["self"],["usize"]],["result",["option","kernelerror"]]]],[11,"split_at","kfs_kernel::frame_allocator::physical_mem_region","Splits the given PhysicalMemRegion in two parts, at the…",60,[[["self"],["usize"]],["result",["option","kernelerror"]]]],[11,"PRESENT","kfs_kernel::paging::arch::i386::entry","",17,[[["self"]],["bool"]]],[11,"WRITABLE","","",17,[[["self"]],["bool"]]],[11,"USER_ACCESSIBLE","","",17,[[["self"]],["bool"]]],[11,"WRITE_THROUGH","","",17,[[["self"]],["bool"]]],[11,"NO_CACHE","","",17,[[["self"]],["bool"]]],[11,"ACCESSED","","",17,[[["self"]],["bool"]]],[11,"DIRTY","","",17,[[["self"]],["bool"]]],[11,"HUGE_PAGE","","",17,[[["self"]],["bool"]]],[11,"GLOBAL","","",17,[[["self"]],["bool"]]],[11,"GUARD_PAGE","","",17,[[["self"]],["bool"]]],[11,"USER_DEFINED_2","","",17,[[["self"]],["bool"]]],[11,"USER_DEFINED_3","","",17,[[["self"]],["bool"]]],[11,"PRESENT","","",17,[[],["u32"]]],[11,"WRITABLE","","",17,[[],["u32"]]],[11,"USER_ACCESSIBLE","","",17,[[],["u32"]]],[11,"WRITE_THROUGH","","",17,[[],["u32"]]],[11,"NO_CACHE","","",17,[[],["u32"]]],[11,"ACCESSED","","",17,[[],["u32"]]],[11,"DIRTY","","",17,[[],["u32"]]],[11,"HUGE_PAGE","","",17,[[],["u32"]]],[11,"GLOBAL","","",17,[[],["u32"]]],[11,"GUARD_PAGE","","",17,[[],["u32"]]],[11,"USER_DEFINED_2","","",17,[[],["u32"]]],[11,"USER_DEFINED_3","","",17,[[],["u32"]]],[11,"READABLE","kfs_kernel::paging","",0,[[["self"]],["bool"]]],[11,"WRITABLE","","",0,[[["self"]],["bool"]]],[11,"EXECUTABLE","","",0,[[["self"]],["bool"]]],[11,"USER_ACCESSIBLE","","",0,[[["self"]],["bool"]]],[11,"READABLE","","",0,[[],["u32"]]],[11,"WRITABLE","","",0,[[],["u32"]]],[11,"EXECUTABLE","","",0,[[],["u32"]]],[11,"USER_ACCESSIBLE","","",0,[[],["u32"]]],[11,"ID","kfs_kernel::i386::registers::eflags","",40,[[["self"]],["bool"]]],[11,"VIRTUAL_INTERRUPT_PENDING","","",40,[[["self"]],["bool"]]],[11,"VIRTUAL_INTERRUPT","","",40,[[["self"]],["bool"]]],[11,"ALIGNMENT_CHECK","","",40,[[["self"]],["bool"]]],[11,"VIRTUAL_8086_MODE","","",40,[[["self"]],["bool"]]],[11,"RESUME_FLAG","","",40,[[["self"]],["bool"]]],[11,"NESTED_TASK","","",40,[[["self"]],["bool"]]],[11,"IOPL_HIGH","","",40,[[["self"]],["bool"]]],[11,"IOPL_LOW","","",40,[[["self"]],["bool"]]],[11,"OVERFLOW_FLAG","","",40,[[["self"]],["bool"]]],[11,"DIRECTION_FLAG","","",40,[[["self"]],["bool"]]],[11,"INTERRUPT_FLAG","","",40,[[["self"]],["bool"]]],[11,"TRAP_FLAG","","",40,[[["self"]],["bool"]]],[11,"SIGN_FLAG","","",40,[[["self"]],["bool"]]],[11,"ZERO_FLAG","","",40,[[["self"]],["bool"]]],[11,"AUXILIARY_CARRY_FLAG","","",40,[[["self"]],["bool"]]],[11,"PARITY_FLAG","","",40,[[["self"]],["bool"]]],[11,"CARRY_FLAG","","",40,[[["self"]],["bool"]]],[11,"ID","","",40,[[],["u32"]]],[11,"VIRTUAL_INTERRUPT_PENDING","","",40,[[],["u32"]]],[11,"VIRTUAL_INTERRUPT","","",40,[[],["u32"]]],[11,"ALIGNMENT_CHECK","","",40,[[],["u32"]]],[11,"VIRTUAL_8086_MODE","","",40,[[],["u32"]]],[11,"RESUME_FLAG","","",40,[[],["u32"]]],[11,"NESTED_TASK","","",40,[[],["u32"]]],[11,"IOPL_HIGH","","",40,[[],["u32"]]],[11,"IOPL_LOW","","",40,[[],["u32"]]],[11,"OVERFLOW_FLAG","","",40,[[],["u32"]]],[11,"DIRECTION_FLAG","","",40,[[],["u32"]]],[11,"INTERRUPT_FLAG","","",40,[[],["u32"]]],[11,"TRAP_FLAG","","",40,[[],["u32"]]],[11,"SIGN_FLAG","","",40,[[],["u32"]]],[11,"ZERO_FLAG","","",40,[[],["u32"]]],[11,"AUXILIARY_CARRY_FLAG","","",40,[[],["u32"]]],[11,"PARITY_FLAG","","",40,[[],["u32"]]],[11,"CARRY_FLAG","","",40,[[],["u32"]]],[11,"PROTECTION_VIOLATION","kfs_kernel::i386::structures::idt","",48,[[["self"]],["bool"]]],[11,"CAUSED_BY_WRITE","","",48,[[["self"]],["bool"]]],[11,"USER_MODE","","",48,[[["self"]],["bool"]]],[11,"MALFORMED_TABLE","","",48,[[["self"]],["bool"]]],[11,"INSTRUCTION_FETCH","","",48,[[["self"]],["bool"]]],[11,"PROTECTION_VIOLATION","","",48,[[],["u32"]]],[11,"CAUSED_BY_WRITE","","",48,[[],["u32"]]],[11,"USER_MODE","","",48,[[],["u32"]]],[11,"MALFORMED_TABLE","","",48,[[],["u32"]]],[11,"INSTRUCTION_FETCH","","",48,[[],["u32"]]],[11,"SPKR_CONTROL","kfs_kernel::devices::pit","",72,[[["self"]],["bool"]]],[11,"OUT2_STATUS","","",72,[[["self"]],["bool"]]],[11,"GATE_2","","",72,[[["self"]],["bool"]]],[11,"OUT1_STATUS","","",72,[[["self"]],["bool"]]],[11,"OTHER_2","","",72,[[["self"]],["bool"]]],[11,"OTHER_3","","",72,[[["self"]],["bool"]]],[11,"OTHER_6","","",72,[[["self"]],["bool"]]],[11,"OTHER_7","","",72,[[["self"]],["bool"]]],[11,"SPKR_CONTROL","","",72,[[],["u8"]]],[11,"OUT2_STATUS","","",72,[[],["u8"]]],[11,"GATE_2","","",72,[[],["u8"]]],[11,"OUT1_STATUS","","",72,[[],["u8"]]],[11,"OTHER_2","","",72,[[],["u8"]]],[11,"OTHER_3","","",72,[[],["u8"]]],[11,"OTHER_6","","",72,[[],["u8"]]],[11,"OTHER_7","","",72,[[],["u8"]]],[11,"ICW4","kfs_kernel::devices::pic","",77,[[["self"]],["bool"]]],[11,"SINGLE","","",77,[[["self"]],["bool"]]],[11,"INTERVAL4","","",77,[[["self"]],["bool"]]],[11,"LEVEL","","",77,[[["self"]],["bool"]]],[11,"INIT","","",77,[[["self"]],["bool"]]],[11,"ICW4","","",77,[[],["u8"]]],[11,"SINGLE","","",77,[[],["u8"]]],[11,"INTERVAL4","","",77,[[],["u8"]]],[11,"LEVEL","","",77,[[],["u8"]]],[11,"INIT","","",77,[[],["u8"]]],[11,"fmt","kfs_kernel::paging::error","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::error","",30,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",31,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::log_impl::filter::inner","",36,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::devices::rs232","",67,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","kfs_kernel::mem","",97,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",98,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","kfs_kernel::paging::process_memory","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging::kernel_memory","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging::lands","",122,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",123,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",124,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging::mapping","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging::cross_process","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging::error","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging::arch::i386::entry","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","kfs_kernel::paging::arch::i386::table","",19,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",21,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",126,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",22,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",23,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",24,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging::bookkeeping","",25,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging::process_memory","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::event","",26,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",27,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::error","",30,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",31,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::log_impl::filter::inner","",36,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::log_impl::filter","",35,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",33,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",34,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::registers::eflags","",40,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::stack","",41,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",42,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::structures::gdt","",43,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::structures::idt","",44,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",45,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",49,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",46,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",47,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",48,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::process_switch","",50,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::gdt","",53,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",55,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",54,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","kfs_kernel::i386::instructions::tables","",57,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386","",39,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",37,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",38,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::interrupts::syscalls","",59,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::frame_allocator::physical_mem_region","",61,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",60,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","kfs_kernel::frame_allocator","",128,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::devices::rs232","",66,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",69,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",67,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",70,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::devices::pit","",76,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",72,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",75,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::devices::pic","",77,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",78,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",79,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::sync","",86,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",87,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::process::capabilities","",96,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::process","",89,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",90,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",91,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",94,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",92,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",95,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",93,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::mem","",97,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",98,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",99,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",100,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",101,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::ipc::session","",103,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",104,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",105,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",106,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",107,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",108,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",109,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::ipc::port","",110,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",111,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",112,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",113,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::elf_loader","",114,[[["self"],["formatter"]],["result"]]],[11,"eq","kfs_kernel::paging::arch::i386::entry","",17,[[["self"],["i386entryflags"]],["bool"]]],[11,"ne","","",17,[[["self"],["i386entryflags"]],["bool"]]],[11,"eq","kfs_kernel::paging","",0,[[["self"],["mappingaccessrights"]],["bool"]]],[11,"ne","","",0,[[["self"],["mappingaccessrights"]],["bool"]]],[11,"eq","kfs_kernel::i386::registers::eflags","",40,[[["self"],["eflags"]],["bool"]]],[11,"ne","","",40,[[["self"],["eflags"]],["bool"]]],[11,"eq","kfs_kernel::i386::structures::idt","",49,[[["self"],["gatetype"]],["bool"]]],[11,"eq","","",48,[[["self"],["pagefaulterrorcode"]],["bool"]]],[11,"ne","","",48,[[["self"],["pagefaulterrorcode"]],["bool"]]],[11,"eq","kfs_kernel::i386","",39,[[["self"],["privilegelevel"]],["bool"]]],[11,"eq","kfs_kernel::devices::pit","",72,[[["self"],["port61flags"]],["bool"]]],[11,"ne","","",72,[[["self"],["port61flags"]],["bool"]]],[11,"eq","kfs_kernel::devices::pic","",77,[[["self"],["icw1"]],["bool"]]],[11,"ne","","",77,[[["self"],["icw1"]],["bool"]]],[11,"eq","kfs_kernel::process","",95,[[["self"],["threadstate"]],["bool"]]],[11,"eq","kfs_kernel::mem","",97,[[["self"],["physicaladdress"]],["bool"]]],[11,"ne","","",97,[[["self"],["physicaladdress"]],["bool"]]],[11,"eq","","",98,[[["self"],["virtualaddress"]],["bool"]]],[11,"ne","","",98,[[["self"],["virtualaddress"]],["bool"]]],[11,"assert_receiver_is_total_eq","kfs_kernel::paging::arch::i386::entry","",17,N],[11,"assert_receiver_is_total_eq","kfs_kernel::paging","",0,N],[11,"assert_receiver_is_total_eq","kfs_kernel::i386::registers::eflags","",40,N],[11,"assert_receiver_is_total_eq","kfs_kernel::i386::structures::idt","",49,N],[11,"assert_receiver_is_total_eq","","",48,N],[11,"assert_receiver_is_total_eq","kfs_kernel::i386","",39,N],[11,"assert_receiver_is_total_eq","kfs_kernel::devices::pit","",72,N],[11,"assert_receiver_is_total_eq","kfs_kernel::devices::pic","",77,N],[11,"assert_receiver_is_total_eq","kfs_kernel::process","",95,N],[11,"assert_receiver_is_total_eq","kfs_kernel::mem","",97,N],[11,"assert_receiver_is_total_eq","","",98,N],[11,"cmp","kfs_kernel::paging::arch::i386::entry","",17,[[["self"],["i386entryflags"]],["ordering"]]],[11,"cmp","kfs_kernel::paging","",0,[[["self"],["mappingaccessrights"]],["ordering"]]],[11,"cmp","kfs_kernel::i386::registers::eflags","",40,[[["self"],["eflags"]],["ordering"]]],[11,"cmp","kfs_kernel::i386::structures::idt","",48,[[["self"],["pagefaulterrorcode"]],["ordering"]]],[11,"cmp","kfs_kernel::devices::pit","",72,[[["self"],["port61flags"]],["ordering"]]],[11,"cmp","kfs_kernel::devices::pic","",77,[[["self"],["icw1"]],["ordering"]]],[11,"cmp","kfs_kernel::mem","",97,[[["self"],["physicaladdress"]],["ordering"]]],[11,"cmp","","",98,[[["self"],["virtualaddress"]],["ordering"]]],[11,"partial_cmp","kfs_kernel::paging::arch::i386::entry","",17,[[["self"],["i386entryflags"]],["option",["ordering"]]]],[11,"lt","","",17,[[["self"],["i386entryflags"]],["bool"]]],[11,"le","","",17,[[["self"],["i386entryflags"]],["bool"]]],[11,"gt","","",17,[[["self"],["i386entryflags"]],["bool"]]],[11,"ge","","",17,[[["self"],["i386entryflags"]],["bool"]]],[11,"partial_cmp","kfs_kernel::paging","",0,[[["self"],["mappingaccessrights"]],["option",["ordering"]]]],[11,"lt","","",0,[[["self"],["mappingaccessrights"]],["bool"]]],[11,"le","","",0,[[["self"],["mappingaccessrights"]],["bool"]]],[11,"gt","","",0,[[["self"],["mappingaccessrights"]],["bool"]]],[11,"ge","","",0,[[["self"],["mappingaccessrights"]],["bool"]]],[11,"partial_cmp","kfs_kernel::i386::registers::eflags","",40,[[["self"],["eflags"]],["option",["ordering"]]]],[11,"lt","","",40,[[["self"],["eflags"]],["bool"]]],[11,"le","","",40,[[["self"],["eflags"]],["bool"]]],[11,"gt","","",40,[[["self"],["eflags"]],["bool"]]],[11,"ge","","",40,[[["self"],["eflags"]],["bool"]]],[11,"partial_cmp","kfs_kernel::i386::structures::idt","",48,[[["self"],["pagefaulterrorcode"]],["option",["ordering"]]]],[11,"lt","","",48,[[["self"],["pagefaulterrorcode"]],["bool"]]],[11,"le","","",48,[[["self"],["pagefaulterrorcode"]],["bool"]]],[11,"gt","","",48,[[["self"],["pagefaulterrorcode"]],["bool"]]],[11,"ge","","",48,[[["self"],["pagefaulterrorcode"]],["bool"]]],[11,"partial_cmp","kfs_kernel::devices::pit","",72,[[["self"],["port61flags"]],["option",["ordering"]]]],[11,"lt","","",72,[[["self"],["port61flags"]],["bool"]]],[11,"le","","",72,[[["self"],["port61flags"]],["bool"]]],[11,"gt","","",72,[[["self"],["port61flags"]],["bool"]]],[11,"ge","","",72,[[["self"],["port61flags"]],["bool"]]],[11,"partial_cmp","kfs_kernel::devices::pic","",77,[[["self"],["icw1"]],["option",["ordering"]]]],[11,"lt","","",77,[[["self"],["icw1"]],["bool"]]],[11,"le","","",77,[[["self"],["icw1"]],["bool"]]],[11,"gt","","",77,[[["self"],["icw1"]],["bool"]]],[11,"ge","","",77,[[["self"],["icw1"]],["bool"]]],[11,"partial_cmp","kfs_kernel::mem","",97,[[["self"],["physicaladdress"]],["option",["ordering"]]]],[11,"lt","","",97,[[["self"],["physicaladdress"]],["bool"]]],[11,"le","","",97,[[["self"],["physicaladdress"]],["bool"]]],[11,"gt","","",97,[[["self"],["physicaladdress"]],["bool"]]],[11,"ge","","",97,[[["self"],["physicaladdress"]],["bool"]]],[11,"partial_cmp","","",98,[[["self"],["virtualaddress"]],["option",["ordering"]]]],[11,"lt","","",98,[[["self"],["virtualaddress"]],["bool"]]],[11,"le","","",98,[[["self"],["virtualaddress"]],["bool"]]],[11,"gt","","",98,[[["self"],["virtualaddress"]],["bool"]]],[11,"ge","","",98,[[["self"],["virtualaddress"]],["bool"]]],[11,"hash","kfs_kernel::paging::arch::i386::entry","",17,N],[11,"hash","kfs_kernel::paging","",0,N],[11,"hash","kfs_kernel::i386::registers::eflags","",40,N],[11,"hash","kfs_kernel::i386::structures::idt","",48,N],[11,"hash","kfs_kernel::devices::pit","",72,N],[11,"hash","kfs_kernel::devices::pic","",77,N],[11,"hash","kfs_kernel::mem","",97,N],[11,"hash","","",98,N],[11,"add","","Adding a length to an address gives another address",98,[[["self"],["usize"]],["virtualaddress"]]],[11,"add","","Adding a length to an address gives another address",97,[[["self"],["usize"]],["physicaladdress"]]],[11,"sub","kfs_kernel::paging::arch::i386::entry","Returns the set difference of the two sets of flags.",17,[[["self"],["i386entryflags"]],["i386entryflags"]]],[11,"sub","kfs_kernel::paging","Returns the set difference of the two sets of flags.",0,[[["self"],["mappingaccessrights"]],["mappingaccessrights"]]],[11,"sub","kfs_kernel::i386::registers::eflags","Returns the set difference of the two sets of flags.",40,[[["self"],["eflags"]],["eflags"]]],[11,"sub","kfs_kernel::i386::structures::idt","Returns the set difference of the two sets of flags.",48,[[["self"],["pagefaulterrorcode"]],["pagefaulterrorcode"]]],[11,"sub","kfs_kernel::devices::pit","Returns the set difference of the two sets of flags.",72,[[["self"],["port61flags"]],["port61flags"]]],[11,"sub","kfs_kernel::devices::pic","Returns the set difference of the two sets of flags.",77,[[["self"],["icw1"]],["icw1"]]],[11,"sub","kfs_kernel::mem","Subtracting a length from an address gives another address",98,[[["self"],["usize"]],["virtualaddress"]]],[11,"sub","","Subtracting a length from an address gives another address",97,[[["self"],["usize"]],["physicaladdress"]]],[11,"sub","","Subtracting two address gives their distance",98,[[["self"],["virtualaddress"]],["usize"]]],[11,"sub","","Subtracting two address gives their distance",97,[[["self"],["physicaladdress"]],["usize"]]],[11,"add_assign","","Adding a length to an address gives another address",98,[[["self"],["usize"]]]],[11,"add_assign","","Adding a length to an address gives another address",97,[[["self"],["usize"]]]],[11,"sub_assign","kfs_kernel::paging::arch::i386::entry","Disables all flags enabled in the set.",17,[[["self"],["i386entryflags"]]]],[11,"sub_assign","kfs_kernel::paging","Disables all flags enabled in the set.",0,[[["self"],["mappingaccessrights"]]]],[11,"sub_assign","kfs_kernel::i386::registers::eflags","Disables all flags enabled in the set.",40,[[["self"],["eflags"]]]],[11,"sub_assign","kfs_kernel::i386::structures::idt","Disables all flags enabled in the set.",48,[[["self"],["pagefaulterrorcode"]]]],[11,"sub_assign","kfs_kernel::devices::pit","Disables all flags enabled in the set.",72,[[["self"],["port61flags"]]]],[11,"sub_assign","kfs_kernel::devices::pic","Disables all flags enabled in the set.",77,[[["self"],["icw1"]]]],[11,"sub_assign","kfs_kernel::mem","Subtracting a length from an address gives another address",98,[[["self"],["usize"]]]],[11,"sub_assign","","Subtracting a length from an address gives another address",97,[[["self"],["usize"]]]],[11,"not","kfs_kernel::paging::arch::i386::entry","Returns the complement of this set of flags.",17,[[["self"]],["i386entryflags"]]],[11,"not","kfs_kernel::paging","Returns the complement of this set of flags.",0,[[["self"]],["mappingaccessrights"]]],[11,"not","kfs_kernel::i386::registers::eflags","Returns the complement of this set of flags.",40,[[["self"]],["eflags"]]],[11,"not","kfs_kernel::i386::structures::idt","Returns the complement of this set of flags.",48,[[["self"]],["pagefaulterrorcode"]]],[11,"not","kfs_kernel::devices::pit","Returns the complement of this set of flags.",72,[[["self"]],["port61flags"]]],[11,"not","kfs_kernel::devices::pic","Returns the complement of this set of flags.",77,[[["self"]],["icw1"]]],[11,"bitand","kfs_kernel::paging::arch::i386::entry","Returns the intersection between the two sets of flags.",17,[[["self"],["i386entryflags"]],["i386entryflags"]]],[11,"bitand","kfs_kernel::paging","Returns the intersection between the two sets of flags.",0,[[["self"],["mappingaccessrights"]],["mappingaccessrights"]]],[11,"bitand","kfs_kernel::i386::registers::eflags","Returns the intersection between the two sets of flags.",40,[[["self"],["eflags"]],["eflags"]]],[11,"bitand","kfs_kernel::i386::structures::idt","Returns the intersection between the two sets of flags.",48,[[["self"],["pagefaulterrorcode"]],["pagefaulterrorcode"]]],[11,"bitand","kfs_kernel::devices::pit","Returns the intersection between the two sets of flags.",72,[[["self"],["port61flags"]],["port61flags"]]],[11,"bitand","kfs_kernel::devices::pic","Returns the intersection between the two sets of flags.",77,[[["self"],["icw1"]],["icw1"]]],[11,"bitor","kfs_kernel::paging::arch::i386::entry","Returns the union of the two sets of flags.",17,[[["self"],["i386entryflags"]],["i386entryflags"]]],[11,"bitor","kfs_kernel::paging","Returns the union of the two sets of flags.",0,[[["self"],["mappingaccessrights"]],["mappingaccessrights"]]],[11,"bitor","kfs_kernel::i386::registers::eflags","Returns the union of the two sets of flags.",40,[[["self"],["eflags"]],["eflags"]]],[11,"bitor","kfs_kernel::i386::structures::idt","Returns the union of the two sets of flags.",48,[[["self"],["pagefaulterrorcode"]],["pagefaulterrorcode"]]],[11,"bitor","kfs_kernel::devices::pit","Returns the union of the two sets of flags.",72,[[["self"],["port61flags"]],["port61flags"]]],[11,"bitor","kfs_kernel::devices::pic","Returns the union of the two sets of flags.",77,[[["self"],["icw1"]],["icw1"]]],[11,"bitxor","kfs_kernel::paging::arch::i386::entry","Returns the left flags, but with all the right flags…",17,[[["self"],["i386entryflags"]],["i386entryflags"]]],[11,"bitxor","kfs_kernel::paging","Returns the left flags, but with all the right flags…",0,[[["self"],["mappingaccessrights"]],["mappingaccessrights"]]],[11,"bitxor","kfs_kernel::i386::registers::eflags","Returns the left flags, but with all the right flags…",40,[[["self"],["eflags"]],["eflags"]]],[11,"bitxor","kfs_kernel::i386::structures::idt","Returns the left flags, but with all the right flags…",48,[[["self"],["pagefaulterrorcode"]],["pagefaulterrorcode"]]],[11,"bitxor","kfs_kernel::devices::pit","Returns the left flags, but with all the right flags…",72,[[["self"],["port61flags"]],["port61flags"]]],[11,"bitxor","kfs_kernel::devices::pic","Returns the left flags, but with all the right flags…",77,[[["self"],["icw1"]],["icw1"]]],[11,"bitand_assign","kfs_kernel::paging::arch::i386::entry","Disables all flags disabled in the set.",17,[[["self"],["i386entryflags"]]]],[11,"bitand_assign","kfs_kernel::paging","Disables all flags disabled in the set.",0,[[["self"],["mappingaccessrights"]]]],[11,"bitand_assign","kfs_kernel::i386::registers::eflags","Disables all flags disabled in the set.",40,[[["self"],["eflags"]]]],[11,"bitand_assign","kfs_kernel::i386::structures::idt","Disables all flags disabled in the set.",48,[[["self"],["pagefaulterrorcode"]]]],[11,"bitand_assign","kfs_kernel::devices::pit","Disables all flags disabled in the set.",72,[[["self"],["port61flags"]]]],[11,"bitand_assign","kfs_kernel::devices::pic","Disables all flags disabled in the set.",77,[[["self"],["icw1"]]]],[11,"bitor_assign","kfs_kernel::paging::arch::i386::entry","Adds the set of flags.",17,[[["self"],["i386entryflags"]]]],[11,"bitor_assign","kfs_kernel::paging","Adds the set of flags.",0,[[["self"],["mappingaccessrights"]]]],[11,"bitor_assign","kfs_kernel::i386::registers::eflags","Adds the set of flags.",40,[[["self"],["eflags"]]]],[11,"bitor_assign","kfs_kernel::i386::structures::idt","Adds the set of flags.",48,[[["self"],["pagefaulterrorcode"]]]],[11,"bitor_assign","kfs_kernel::devices::pit","Adds the set of flags.",72,[[["self"],["port61flags"]]]],[11,"bitor_assign","kfs_kernel::devices::pic","Adds the set of flags.",77,[[["self"],["icw1"]]]],[11,"bitxor_assign","kfs_kernel::paging::arch::i386::entry","Toggles the set of flags.",17,[[["self"],["i386entryflags"]]]],[11,"bitxor_assign","kfs_kernel::paging","Toggles the set of flags.",0,[[["self"],["mappingaccessrights"]]]],[11,"bitxor_assign","kfs_kernel::i386::registers::eflags","Toggles the set of flags.",40,[[["self"],["eflags"]]]],[11,"bitxor_assign","kfs_kernel::i386::structures::idt","Toggles the set of flags.",48,[[["self"],["pagefaulterrorcode"]]]],[11,"bitxor_assign","kfs_kernel::devices::pit","Toggles the set of flags.",72,[[["self"],["port61flags"]]]],[11,"bitxor_assign","kfs_kernel::devices::pic","Toggles the set of flags.",77,[[["self"],["icw1"]]]],[11,"deref","kfs_kernel::paging::hierarchical_table","",11,[[["self"]],["t"]]],[11,"deref","kfs_kernel::i386::gdt","",51,[[["self"]],["descriptortable"]]],[11,"deref","","",52,[[["self"]],["virtualaddress"]]],[11,"deref","kfs_kernel::i386","",38,[[["self"]],["tssstruct"]]],[11,"deref","kfs_kernel::interrupts","",58,[[["self"]],["spinlock"]]],[11,"deref","kfs_kernel::heap_allocator","",65,[[["self"]],["spinlock"]]],[11,"deref","kfs_kernel::devices::pit","",71,[[["self"]],["spinlock"]]],[11,"deref","kfs_kernel::sync","",87,[[["self"]],["t"]]],[11,"deref","kfs_kernel::mem","",99,[[["self"]],["t"]]],[11,"deref","","",100,[[["self"]],["t"]]],[11,"deref","kfs_kernel::ipc","",102,[[["self"]],["rwlock"]]],[11,"deref_mut","kfs_kernel::paging::hierarchical_table","",11,[[["self"]],["t"]]],[11,"deref_mut","kfs_kernel::i386::gdt","",51,[[["self"]],["descriptortable"]]],[11,"deref_mut","kfs_kernel::i386","",38,[[["self"]],["tssstruct"]]],[11,"deref_mut","kfs_kernel::sync","",87,[[["self"]],["t"]]],[11,"deref_mut","kfs_kernel::mem","",100,[[["self"]],["t"]]],[11,"drop","kfs_kernel::paging::cross_process","Unmaps itself from KernelLand when dropped.",9,[[["self"]]]],[11,"drop","kfs_kernel::paging::hierarchical_table","",11,[[["self"]]]],[11,"drop","kfs_kernel::paging::arch::i386::table","When the temporary inactive directory is drop, we unmap it.",23,[[["self"]]]],[11,"drop","","When the temporary inactive table is drop, we unmap it.",22,[[["self"]]]],[11,"drop","kfs_kernel::i386::stack","We deallocate the stack when it is dropped",41,[[["self"]]]],[11,"drop","kfs_kernel::frame_allocator::physical_mem_region","Dropping a `PhysicalMemRegion` may free its frames.",60,[[["self"]]]],[11,"drop","kfs_kernel::sync","",87,[[["self"]]]],[11,"drop","kfs_kernel::process","",90,[[["self"]]]],[11,"drop","","",91,[[["self"]]]],[11,"drop","kfs_kernel::ipc::session","",106,[[["self"]]]],[11,"drop","kfs_kernel::ipc::port","",112,[[["self"]]]],[11,"drop","kfs_kernel::elf_loader","Unmap the module, but do not deallocate physical memory",114,[[["self"]]]],[11,"index","kfs_kernel::i386::structures::idt","",44,N],[11,"index_mut","","",44,N],[11,"from_iter","kfs_kernel::paging::arch::i386::entry","",17,[[["t"]],["i386entryflags"]]],[11,"from_iter","kfs_kernel::paging","",0,[[["t"]],["mappingaccessrights"]]],[11,"from_iter","kfs_kernel::i386::registers::eflags","",40,[[["t"]],["eflags"]]],[11,"from_iter","kfs_kernel::i386::structures::idt","",48,[[["t"]],["pagefaulterrorcode"]]],[11,"from_iter","kfs_kernel::devices::pit","",72,[[["t"]],["port61flags"]]],[11,"from_iter","kfs_kernel::devices::pic","",77,[[["t"]],["icw1"]]],[11,"steps_between","kfs_kernel::mem","",97,[[["self"],["self"]],["option",["usize"]]]],[11,"replace_one","","",97,[[["self"]],["self"]]],[11,"replace_zero","","",97,[[["self"]],["self"]]],[11,"add_one","","",97,[[["self"]],["self"]]],[11,"sub_one","","",97,[[["self"]],["self"]]],[11,"add_usize","","",97,[[["self"],["usize"]],["option"]]],[11,"steps_between","","",98,[[["self"],["self"]],["option",["usize"]]]],[11,"replace_one","","",98,[[["self"]],["self"]]],[11,"replace_zero","","",98,[[["self"]],["self"]]],[11,"add_one","","",98,[[["self"]],["self"]]],[11,"sub_one","","",98,[[["self"]],["self"]]],[11,"add_usize","","",98,[[["self"],["usize"]],["option"]]],[11,"next","kfs_kernel::frame_allocator::physical_mem_region","",61,[[["self"]],["option",["physicaladdress"]]]],[11,"extend","kfs_kernel::paging::arch::i386::entry","",17,[[["self"],["t"]]]],[11,"extend","kfs_kernel::paging","",0,[[["self"],["t"]]]],[11,"extend","kfs_kernel::i386::registers::eflags","",40,[[["self"],["t"]]]],[11,"extend","kfs_kernel::i386::structures::idt","",48,[[["self"],["t"]]]],[11,"extend","kfs_kernel::devices::pit","",72,[[["self"],["t"]]]],[11,"extend","kfs_kernel::devices::pic","",77,[[["self"],["t"]]]],[11,"from","kfs_kernel::error","",29,[[["mmerror"]],["self"]]],[11,"from","kfs_kernel::paging::arch::i386::entry","",17,[[["mappingaccessrights"]],["i386entryflags"]]],[11,"from","kfs_kernel::paging","",0,[[["memorypermissions"]],["self"]]],[11,"from","kfs_kernel::error","",29,[[["kernelerror"]],["userspaceerror"]]],[11,"from","kfs_kernel::i386::structures::idt","",49,[[["u8"]],["gatetype"]]],[11,"from","kfs_kernel::i386","",39,[[["u8"]],["privilegelevel"]]],[11,"write_str","kfs_kernel::devices::rs232","Writes a string to COM1.",70,[[["self"],["str"]],["result",["error"]]]],[11,"fmt","kfs_kernel::paging::arch::i386::entry","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::registers::eflags","",40,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::structures::idt","",48,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::devices::pit","",72,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::devices::pic","",77,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging::arch::i386::entry","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::registers::eflags","",40,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::structures::idt","",48,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::devices::pit","",72,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::devices::pic","",77,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging::arch::i386::entry","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::registers::eflags","",40,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::structures::idt","",48,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::devices::pit","",72,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::devices::pic","",77,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::mem","",97,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",98,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","kfs_kernel::paging::arch::i386::entry","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::paging","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::registers::eflags","",40,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::i386::structures::idt","",48,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::devices::pit","",72,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_kernel::devices::pic","",77,[[["self"],["formatter"]],["result"]]],[11,"clone","kfs_kernel::paging::arch::i386::entry","",17,[[["self"]],["i386entryflags"]]],[11,"clone","","",18,[[["self"]],["i386entry"]]],[11,"clone","kfs_kernel::paging","",0,[[["self"]],["mappingaccessrights"]]],[11,"clone","kfs_kernel::error","",30,[[["self"]],["arithmeticoperation"]]],[11,"clone","kfs_kernel::i386::registers::eflags","",40,[[["self"]],["eflags"]]],[11,"clone","kfs_kernel::i386::structures::gdt","",43,[[["self"]],["segmentselector"]]],[11,"clone","kfs_kernel::i386::structures::idt","",45,[[["self"]],["idtentry"]]],[11,"clone","","",49,[[["self"]],["gatetype"]]],[11,"clone","","",46,[[["self"]],["entryoptions"]]],[11,"clone","","",48,[[["self"]],["pagefaulterrorcode"]]],[11,"clone","kfs_kernel::i386::gdt","",53,[[["self"]],["descriptortable"]]],[11,"clone","","",55,[[["self"]],["systemdescriptortypes"]]],[11,"clone","","",54,[[["self"]],["descriptortableentry"]]],[11,"clone","kfs_kernel::i386::instructions::tables","",57,[[["self"]],["descriptortablepointer"]]],[11,"clone","kfs_kernel::i386","",39,[[["self"]],["privilegelevel"]]],[11,"clone","","",37,[[["self"]],["tssstruct"]]],[11,"clone","kfs_kernel::frame_allocator::physical_mem_region","",61,[[["self"]],["physicalmemregioniter"]]],[11,"clone","kfs_kernel::devices::rs232","",66,[[["self"]],["comport"]]],[11,"clone","","",69,[[["self"]],["serialcolor"]]],[11,"clone","","",67,[[["self"]],["serialattributes"]]],[11,"clone","kfs_kernel::devices::pit","",76,[[["self"]],["channelselector"]]],[11,"clone","","",72,[[["self"]],["port61flags"]]],[11,"clone","kfs_kernel::devices::pic","",77,[[["self"]],["icw1"]]],[11,"clone","kfs_kernel::process","",95,[[["self"]],["threadstate"]]],[11,"clone","kfs_kernel::mem","",97,[[["self"]],["physicaladdress"]]],[11,"clone","","",98,[[["self"]],["virtualaddress"]]],[11,"clone","","",99,[[["self"]],["userspaceptr"]]],[11,"clone","","",100,[[["self"]],["userspaceptrmut"]]],[11,"clone","kfs_kernel::ipc::session","",105,[[["self"]],["clientsession"]]],[11,"clone","","",106,[[["self"]],["self"]]],[11,"clone","kfs_kernel::ipc::port","",111,[[["self"]],["clientport"]]],[11,"clone","","",112,[[["self"]],["self"]]],[11,"into","kfs_kernel::mem","",100,[[["self"]],["userspaceptr"]]],[11,"default","kfs_kernel::paging::process_memory","Creates a ProcessMemory, allocating the…",2,[[],["self"]]],[11,"default","kfs_kernel::log_impl::filter","",34,[[],["self"]]],[11,"default","kfs_kernel::i386::process_switch","Creates an empty ThreadHardwareContext.",50,[[],["self"]]],[11,"default","kfs_kernel::i386","",37,[[],["tssstruct"]]],[11,"default","kfs_kernel::process","",89,[[],["self"]]],[11,"default","","Creates an empty handle table. Note that an empty handle…",92,[[],["self"]]],[11,"alloc","kfs_kernel::heap_allocator","",65,N],[11,"dealloc","","",65,N],[11,"initialize","kfs_kernel::i386::gdt","",52,[[["self"]]]],[11,"initialize","kfs_kernel::interrupts","",58,[[["self"]]]],[11,"initialize","kfs_kernel::devices::pit","",71,[[["self"]]]],[11,"initialize","kfs_kernel::ipc","",102,[[["self"]]]],[11,"enabled","kfs_kernel::log_impl","",32,[[["self"],["metadata"]],["bool"]]],[11,"log","","",32,[[["self"],["record"]]]],[11,"flush","","",32,[[["self"]]]],[11,"name","kfs_kernel::paging::error","",10,[[["self"]],["option",["str"]]]],[11,"cause","","",10,[[["self"]],["option",["fail"]]]],[11,"backtrace","","",10,[[["self"]],["option",["backtrace"]]]],[11,"name","kfs_kernel::error","",31,[[["self"]],["option",["str"]]]],[11,"cause","","",31,[[["self"]],["option",["fail"]]]],[11,"backtrace","","",31,[[["self"]],["option",["backtrace"]]]],[11,"bit_range","kfs_kernel::i386::structures::idt","",46,[[["self"],["usize"],["usize"]],["t"]]],[11,"set_bit_range","","",46,[[["self"],["usize"],["usize"],["t"]]]],[11,"bit_range","kfs_kernel::ipc::session","",107,[[["self"],["usize"],["usize"]],["t"]]],[11,"set_bit_range","","",107,[[["self"],["usize"],["usize"],["t"]]]],[11,"bit_range","","",108,[[["self"],["usize"],["usize"]],["t"]]],[11,"set_bit_range","","",108,[[["self"],["usize"],["usize"],["t"]]]],[11,"make_ret","kfs_kernel::error","Transforms a KernelError into the encoding acceptable for…",29,[[["self"]],["usize"]]],[11,"from_syscall_ret","","Turns a syscall return value into a Kernel Error.",29,[[["u32"]],["kernelerror"]]],[11,"from_description","","Turns a kernel error description into a KernelError.",29,[[["u32"]],["kernelerror"]]],[11,"description","","Gets the underlying KernelError description.",29,[[["self"]],["u32"]]],[18,"InvalidKernelCaps","","Kernel capabilities are invalid.",29,N],[18,"NotImplemented","","This function is not implemented.",29,N],[18,"InvalidSize","","The size argument is invalid.",29,N],[18,"InvalidAddress","","The passed address is invalid.",29,N],[18,"MemoryFull","","The virtual address space was exhausted.",29,N],[18,"HandleTableFull","","The process' handle table is full.",29,N],[18,"InvalidMemPerms","","The memory permissions passed are wrong.",29,N],[18,"InvalidHandle","","Passed handle is invalid.",29,N],[18,"CopyFromUserFailed","","Attempt to copy the userspace address failed.",29,N],[18,"InvalidCombination","","The combination of argument is invalid.",29,N],[18,"Timeout","","A timeout was reached.",29,N],[18,"Canceled","","The syscall was cancelled through cancel_synchronization.",29,N],[18,"ExceedingMaximum","","A size or address was given exceeding the maximum allowed…",29,N],[18,"NoSuchEntry","","The given entry does not exist.",29,N],[18,"PortRemoteDead","","The remote part of the session was closed.",29,N],[18,"ProcessAlreadyStarted","","Attempted to start a process that was already started.",29,N],[18,"ReservedValue","","Attempted to use an unknown value, reserved for future use.",29,N],[11,"new","kfs_kernel::utils::io","Create a PIO from a given port",56,[[["u16"]],["pio"]]],[18,"INIT","kfs_kernel::sync","Initialization constant of `Once`.",80,N],[11,"new","","Creates a new `Once` value.",80,[[],["once"]]],[11,"call_once","","Performs an initialization routine once and only once. The…",80,[[["self"],["f"]],["t"]]],[11,"try","","Returns a pointer iff the `Once` was previously initialized",80,[[["self"]],["option"]]],[11,"wait","","Like try, but will spin if the `Once` is in the process of…",80,[[["self"]],["option"]]],[11,"new","","Creates a new spinlock wrapping the supplied data.",81,[[["t"]],["rwlock"]]],[11,"into_inner","","Consumes this `RwLock`, returning the underlying data.",81,[[["self"]],["t"]]],[11,"read","","Locks this rwlock with shared read access, blocking the…",81,[[["self"]],["rwlockreadguard"]]],[11,"try_read","","Attempt to acquire this lock with shared read access.",81,[[["self"]],["option",["rwlockreadguard"]]]],[11,"force_read_decrement","","Force decrement the reader count.",81,N],[11,"force_write_unlock","","Force unlock exclusive write access.",81,N],[11,"write","","Lock this rwlock with exclusive write access, blocking the…",81,[[["self"]],["rwlockwriteguard"]]],[11,"try_write","","Attempt to lock this rwlock with exclusive write access.",81,[[["self"]],["option",["rwlockwriteguard"]]]],[11,"new","","Creates a new spinlock wrapping the supplied data.",84,[[["t"]],["mutex"]]],[11,"into_inner","","Consumes this mutex, returning the underlying data.",84,[[["self"]],["t"]]],[11,"lock","","Locks the spinlock and returns a guard.",84,[[["self"]],["mutexguard"]]],[11,"force_unlock","","Force unlock the spinlock.",84,N],[11,"try_lock","","Tries to lock the mutex. If it is already locked, it will…",84,[[["self"]],["option",["mutexguard"]]]],[11,"new","kfs_kernel::utils::io","Create a read-only wrapper around the IO device address.",116,[[["i"]],["readonly"]]],[11,"read","","Reads from this Io.",116,N],[11,"readf","","Read from this Io, and mask the value with `flags`.",116,N],[11,"new","","Creates a WriteOnly Io.",117,[[["i"]],["writeonly"]]],[11,"write","","Writes `value` to this Io.",117,N],[11,"new","kfs_kernel::utils","Creates a new cursor wrapping the provided underlying…",119,N],[11,"pos","","Returns the current position of this cursor.",119,[[["self"]],["usize"]]],[11,"skip_write","","Skip the given amount of bytes, returning a mutable slice…",119,N],[11,"write_u8","","Writes an u8 in the given byte ordering.",119,N],[11,"write_u16","","Writes a u16 in the given byte ordering.",119,N],[11,"write_u32","","Writes a u32 in the given byte ordering.",119,N],[11,"write_u64","","Writes a u64 in the given byte ordering.",119,N],[11,"write","","Writes the given byte slice entirely.",119,N],[11,"write_raw","","Writes the given structure.",119,N],[11,"new","","Creates a new cursor wrapping the provided underlying…",120,N],[11,"pos","","Returns the current position of this cursor.",120,[[["self"]],["usize"]]],[11,"read_u8","","Reads an u8 in the given byteorder.",120,[[["self"]],["u8"]]],[11,"read_u16","","Reads an u16 in the given byteorder.",120,[[["self"]],["u16"]]],[11,"read_u32","","Reads an u32 in the given byteorder.",120,[[["self"]],["u32"]]],[11,"read_u64","","Reads an u64 in the given byteorder.",120,[[["self"]],["u64"]]],[11,"assert","","Reads `v.len()` bytes from the stream, and asserts that it…",120,N],[11,"skip_read","","Skips `bytelen` bytes, returning a slice to them for…",120,N],[11,"read_raw","","Reads the given structure from the bytestream.",120,[[["self"]],["t"]]]],"paths":[[3,"MappingAccessRights"],[4,"PageState"],[3,"ProcessMemory"],[4,"QueryMemory"],[4,"DynamicHierarchy"],[3,"KernelMemory"],[8,"VirtualSpaceLand"],[3,"Mapping"],[4,"MappingType"],[3,"CrossProcessMapping"],[4,"MmError"],[3,"SmartHierarchicalTable"],[8,"HierarchicalEntry"],[8,"HierarchicalTable"],[8,"PagingCacheFlusher"],[8,"TableHierarchy"],[8,"InactiveHierarchyTrait"],[3,"I386EntryFlags"],[3,"I386Entry"],[3,"Table"],[3,"ActivePageTable"],[3,"ActivePageDirectory"],[3,"InactivePageTable"],[3,"InactivePageDirectory"],[3,"InactiveHierarchy"],[3,"UserspaceBookkeeping"],[3,"IRQEvent"],[3,"IRQState"],[8,"Waitable"],[3,"UserspaceError"],[4,"ArithmeticOperation"],[4,"KernelError"],[3,"Logger"],[3,"Filter"],[3,"Builder"],[3,"Directive"],[3,"Filter"],[3,"TssStruct"],[3,"AlignedTssStruct"],[4,"PrivilegeLevel"],[3,"EFlags"],[3,"KernelStack"],[3,"StackDumpSource"],[3,"SegmentSelector"],[3,"Idt"],[3,"IdtEntry"],[3,"EntryOptions"],[3,"ExceptionStackFrame"],[3,"PageFaultErrorCode"],[4,"GateType"],[3,"ThreadHardwareContext"],[3,"GdtManager"],[3,"MAIN_TASK"],[3,"DescriptorTable"],[3,"DescriptorTableEntry"],[4,"SystemDescriptorTypes"],[3,"Pio"],[3,"DescriptorTablePointer"],[3,"IDT"],[3,"Registers"],[3,"PhysicalMemRegion"],[3,"PhysicalMemRegionIter"],[3,"FrameAllocatori386"],[8,"FrameAllocatorTraitPrivate"],[8,"FrameAllocatorTrait"],[3,"Allocator"],[3,"ComPort"],[3,"SerialAttributes"],[3,"SerialInternal"],[4,"SerialColor"],[3,"SerialLogger"],[3,"PIT_PORTS"],[3,"Port61Flags"],[3,"PITPorts"],[3,"PITChannel2"],[3,"WaitFor"],[4,"ChannelSelector"],[3,"ICW1"],[3,"InternalPic"],[3,"Pic"],[3,"Once"],[3,"RwLock"],[3,"RwLockReadGuard"],[3,"RwLockWriteGuard"],[3,"SpinLock"],[3,"SpinLockGuard"],[3,"SpinLockIRQ"],[3,"SpinLockIRQGuard"],[8,"Lock"],[3,"ProcessCapabilities"],[3,"ProcessStruct"],[3,"ThreadStruct"],[3,"HandleTable"],[3,"ThreadStateAtomic"],[4,"Handle"],[4,"ThreadState"],[3,"MaskPrinter"],[3,"PhysicalAddress"],[3,"VirtualAddress"],[3,"UserSpacePtr"],[3,"UserSpacePtrMut"],[3,"FatPtr"],[3,"NAMED_PORTS"],[3,"SessionRequests"],[3,"Session"],[3,"ClientSession"],[3,"ServerSession"],[3,"MsgPackedHdr"],[3,"HandleDescriptorHeader"],[3,"Request"],[3,"Port"],[3,"ClientPort"],[3,"ServerPort"],[3,"IncomingConnection"],[3,"MappedGrubModule"],[8,"Io"],[3,"ReadOnly"],[3,"WriteOnly"],[8,"BitArrayExt"],[3,"CursorWrite"],[3,"CursorRead"],[8,"Splittable"],[3,"KernelLand"],[3,"UserLand"],[3,"RecursiveTablesLand"],[3,"NoFlush"],[3,"ActiveHierarchy"],[3,"TlbFlush"],[3,"FrameAllocator"]]};
searchIndex["kfs_libkern"]={"doc":"Types shared by user and kernel","items":[[3,"MemoryType","kfs_libkern","The type of this memory area.",N,N],[12,"0","","",0,N],[3,"MemoryAttributes","","Low-level attributes of a memory mapping.",N,N],[12,"bits","","",1,N],[3,"MemoryPermissions","","Memory permissions of a memory area.",N,N],[12,"bits","","",2,N],[3,"MemoryInfo","","The structure returned by the `query_memory` syscall.",N,N],[12,"baseaddr","","The base address of this memory region.",3,N],[12,"size","","The size of this memory region, from the base address.",3,N],[12,"memtype","","The type of this mapping.",3,N],[12,"memattr","","The attributes of this mapping.",3,N],[12,"perms","","The permissions of this mapping.",3,N],[12,"ipc_ref_count","","Counts how many IPC service requests have an IPC buffer in…",3,N],[12,"device_ref_count","","Unknown.",3,N],[3,"SYSCALL_NAMES","","A table associating a syscall name string for every…",N,N],[12,"__private_field","","",4,N],[0,"error","","Kernel errors",N,N],[3,"KernelError","kfs_libkern::error","Kernel syscall error codes.",N,N],[12,"0","","",5,N],[18,"InvalidKernelCaps","","Kernel capabilities are invalid.",5,N],[18,"NotImplemented","","This function is not implemented.",5,N],[18,"InvalidSize","","The size argument is invalid.",5,N],[18,"InvalidAddress","","The passed address is invalid.",5,N],[18,"MemoryFull","","The virtual address space was exhausted.",5,N],[18,"HandleTableFull","","The process' handle table is full.",5,N],[18,"InvalidMemPerms","","The memory permissions passed are wrong.",5,N],[18,"InvalidHandle","","Passed handle is invalid.",5,N],[18,"CopyFromUserFailed","","Attempt to copy the userspace address failed.",5,N],[18,"InvalidCombination","","The combination of argument is invalid.",5,N],[18,"Timeout","","A timeout was reached.",5,N],[18,"Canceled","","The syscall was cancelled through cancel_synchronization.",5,N],[18,"ExceedingMaximum","","A size or address was given exceeding the maximum allowed…",5,N],[18,"NoSuchEntry","","The given entry does not exist.",5,N],[18,"PortRemoteDead","","The remote part of the session was closed.",5,N],[18,"ProcessAlreadyStarted","","Attempted to start a process that was already started.",5,N],[18,"ReservedValue","","Attempted to use an unknown value, reserved for future use.",5,N],[11,"make_ret","","Transforms a KernelError into the encoding acceptable for…",5,[[["self"]],["usize"]]],[11,"from_syscall_ret","","Turns a syscall return value into a Kernel Error.",5,[[["u32"]],["kernelerror"]]],[11,"from_description","","Turns a kernel error description into a KernelError.",5,[[["u32"]],["kernelerror"]]],[11,"description","","Gets the underlying KernelError description.",5,[[["self"]],["u32"]]],[0,"nr","kfs_libkern","Syscall numbers",N,N],[17,"SetHeapSize","kfs_libkern::nr","",N,N],[17,"SetMemoryPermission","","",N,N],[17,"SetMemoryAttribute","","",N,N],[17,"MapMemory","","",N,N],[17,"UnmapMemory","","",N,N],[17,"QueryMemory","","",N,N],[17,"ExitProcess","","",N,N],[17,"CreateThread","","",N,N],[17,"StartThread","","",N,N],[17,"ExitThread","","",N,N],[17,"SleepThread","","",N,N],[17,"GetThreadPriority","","",N,N],[17,"SetThreadPriority","","",N,N],[17,"GetThreadCoreMask","","",N,N],[17,"SetThreadCoreMask","","",N,N],[17,"GetCurrentProcessorNumber","","",N,N],[17,"SignalEvent","","",N,N],[17,"ClearEvent","","",N,N],[17,"MapSharedMemory","","",N,N],[17,"UnmapSharedMemory","","",N,N],[17,"CreateTransferMemory","","",N,N],[17,"CloseHandle","","",N,N],[17,"ResetSignal","","",N,N],[17,"WaitSynchronization","","",N,N],[17,"CancelSynchronization","","",N,N],[17,"ArbitrateLock","","",N,N],[17,"ArbitrateUnlock","","",N,N],[17,"WaitProcessWideKeyAtomic","","",N,N],[17,"SignalProcessWideKey","","",N,N],[17,"GetSystemTick","","",N,N],[17,"ConnectToNamedPort","","",N,N],[17,"SendSyncRequestLight","","",N,N],[17,"SendSyncRequest","","",N,N],[17,"SendSyncRequestWithUserBuffer","","",N,N],[17,"SendAsyncRequestWithUserBuffer","","",N,N],[17,"GetProcessId","","",N,N],[17,"GetThreadId","","",N,N],[17,"Break","","",N,N],[17,"OutputDebugString","","",N,N],[17,"ReturnFromException","","",N,N],[17,"GetInfo","","",N,N],[17,"FlushEntireDataCache","","",N,N],[17,"FlushDataCache","","",N,N],[17,"MapPhysicalMemory","","",N,N],[17,"UnmapPhysicalMemory","","",N,N],[17,"GetFutureThreadInfo","","",N,N],[17,"GetLastThreadInfo","","",N,N],[17,"GetResourceLimitLimitValue","","",N,N],[17,"GetResourceLimitCurrentValue","","",N,N],[17,"SetThreadActivity","","",N,N],[17,"GetThreadContext3","","",N,N],[17,"WaitForAddress","","",N,N],[17,"SignalToAddress","","",N,N],[17,"DumpInfo","","",N,N],[17,"DumpInfoNew","","",N,N],[17,"CreateSession","","",N,N],[17,"AcceptSession","","",N,N],[17,"ReplyAndReceiveLight","","",N,N],[17,"ReplyAndReceive","","",N,N],[17,"ReplyAndReceiveWithUserBuffer","","",N,N],[17,"CreateEvent","","",N,N],[17,"MapPhysicalMemoryUnsafe","","",N,N],[17,"UnmapPhysicalMemoryUnsafe","","",N,N],[17,"SetUnsafeLimit","","",N,N],[17,"CreateCodeMemory","","",N,N],[17,"ControlCodeMemory","","",N,N],[17,"SleepSystem","","",N,N],[17,"ReadWriteRegister","","",N,N],[17,"SetProcessActivity","","",N,N],[17,"CreateSharedMemory","","",N,N],[17,"MapTransferMemory","","",N,N],[17,"UnmapTransferMemory","","",N,N],[17,"CreateInterruptEvent","","",N,N],[17,"QueryPhysicalAddress","","",N,N],[17,"QueryIoMapping","","",N,N],[17,"CreateDeviceAddressSpace","","",N,N],[17,"AttachDeviceAddressSpace","","",N,N],[17,"DetachDeviceAddressSpace","","",N,N],[17,"MapDeviceAddressSpaceByForce","","",N,N],[17,"MapDeviceAddressSpaceAligned","","",N,N],[17,"MapDeviceAddressSpace","","",N,N],[17,"UnmapDeviceAddressSpace","","",N,N],[17,"InvalidateProcessDataCache","","",N,N],[17,"StoreProcessDataCache","","",N,N],[17,"FlushProcessDataCache","","",N,N],[17,"DebugActiveProcess","","",N,N],[17,"BreakDebugProcess","","",N,N],[17,"TerminateDebugProcess","","",N,N],[17,"GetDebugEvent","","",N,N],[17,"ContinueDebugEvent","","",N,N],[17,"GetProcessList","","",N,N],[17,"GetThreadList","","",N,N],[17,"GetDebugThreadContext","","",N,N],[17,"SetDebugThreadContext","","",N,N],[17,"QueryDebugProcessMemory","","",N,N],[17,"ReadDebugProcessMemory","","",N,N],[17,"WriteDebugProcessMemory","","",N,N],[17,"SetHardwareBreakPoint","","",N,N],[17,"GetDebugThreadParam","","",N,N],[17,"GetSystemInfo","","",N,N],[17,"CreatePort","","",N,N],[17,"ManageNamedPort","","",N,N],[17,"ConnectToPort","","",N,N],[17,"SetProcessMemoryPermission","","",N,N],[17,"MapProcessMemory","","",N,N],[17,"UnmapProcessMemory","","",N,N],[17,"QueryProcessMemory","","",N,N],[17,"MapProcessCodeMemory","","",N,N],[17,"UnmapProcessCodeMemory","","",N,N],[17,"CreateProcess","","",N,N],[17,"StartProcess","","",N,N],[17,"TerminateProcess","","",N,N],[17,"GetProcessInfo","","",N,N],[17,"CreateResourceLimit","","",N,N],[17,"SetResourceLimitLimitValue","","",N,N],[17,"CallSecureMonitor","","",N,N],[17,"MapFramebuffer","","",N,N],[17,"StartProcessEntrypoint","","",N,N],[17,"MaxSvc","","",N,N],[7,"SYSCALL_NAMES","kfs_libkern","",N,N],[18,"Unmapped","","An unmapped memory region. Reading will lead to a data…",0,N],[18,"Io","","Mapped by kernel capability parsing in `create_process`…",0,N],[18,"Normal","","Mapped by kernel capability parsing in `create_process`…",0,N],[18,"CodeStatic","","Mapped during create_process",0,N],[18,"CodeMutable","","Transition from MemoryType::CodeStatic performed by…",0,N],[18,"Heap","","Mapped using `set_heap_size` syscall.",0,N],[18,"SharedMemory","","Mapped using `map_shared_memory` syscall.",0,N],[18,"Alias","","Mapped using `map_memory` syscall.",0,N],[18,"ModuleCodeStatic","","Mapped using `map_process_code_memory` syscall.",0,N],[18,"ModuleCodeMutable","","Transition from MemoryType::ModuleCodeStatic by…",0,N],[18,"IpcBuffer0","","IPC buffers with descriptor flags=0.",0,N],[18,"Stack","","Mapped using `map_memory` syscall.",0,N],[18,"ThreadLocal","","Mapped during `create_thread` syscall.",0,N],[18,"TransferMemoryIsolated","","Mapped using `map_transfer_memory` syscall when the owning…",0,N],[18,"TransferMemory","","Mapped using `map_transfer_memory` syscall when the owning…",0,N],[18,"ProcessMemory","","Mapped using `map_process_memory` syscall.",0,N],[18,"Reserved","","Reserved memory area, used internally by kernel, should…",0,N],[18,"IpcBuffer1","","IPC buffers with descriptor flags=1.",0,N],[18,"IpcBuffer3","","IPC buffers with descriptor flags=3.",0,N],[18,"KernelStack","","Mapped in kernel during `create_thread`. Should not be…",0,N],[18,"CodeReadOnly","","Mapped using `control_code_memory` syscall.",0,N],[18,"CodeWritable","","Mapped using `control_code_memory` syscall.",0,N],[18,"BORROWED","","Is mapped in more than one area.",1,N],[18,"IPC_MAPPED","","Is mapped through an IPC request.",1,N],[18,"DEVICE_MAPPED","","Is a device mapping.",1,N],[18,"UNCACHED","","Is caching disabled in the MMU.",1,N],[11,"empty","","Returns an empty set of flags.",1,[[],["memoryattributes"]]],[11,"all","","Returns the set containing all flags.",1,[[],["memoryattributes"]]],[11,"bits","","Returns the raw value of the flags currently stored.",1,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",1,[[["u32"]],["option",["memoryattributes"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",1,[[["u32"]],["memoryattributes"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",1,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",1,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",1,[[["self"],["memoryattributes"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",1,[[["self"],["memoryattributes"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",1,[[["self"],["memoryattributes"]]]],[11,"remove","","Removes the specified flags in-place.",1,[[["self"],["memoryattributes"]]]],[11,"toggle","","Toggles the specified flags in-place.",1,[[["self"],["memoryattributes"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",1,[[["self"],["memoryattributes"],["bool"]]]],[18,"READABLE","","The area is readable.",2,N],[18,"WRITABLE","","The area is writable.",2,N],[18,"EXECUTABLE","","The area is executable.",2,N],[11,"empty","","Returns an empty set of flags.",2,[[],["memorypermissions"]]],[11,"all","","Returns the set containing all flags.",2,[[],["memorypermissions"]]],[11,"bits","","Returns the raw value of the flags currently stored.",2,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",2,[[["u32"]],["option",["memorypermissions"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",2,[[["u32"]],["memorypermissions"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",2,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",2,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",2,[[["self"],["memorypermissions"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",2,[[["self"],["memorypermissions"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",2,[[["self"],["memorypermissions"]]]],[11,"remove","","Removes the specified flags in-place.",2,[[["self"],["memorypermissions"]]]],[11,"toggle","","Toggles the specified flags in-place.",2,[[["self"],["memorypermissions"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",2,[[["self"],["memorypermissions"],["bool"]]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"from","kfs_libkern::error","",5,[[["t"]],["t"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"BORROWED","kfs_libkern","",1,[[["self"]],["bool"]]],[11,"IPC_MAPPED","","",1,[[["self"]],["bool"]]],[11,"DEVICE_MAPPED","","",1,[[["self"]],["bool"]]],[11,"UNCACHED","","",1,[[["self"]],["bool"]]],[11,"BORROWED","","",1,[[],["u32"]]],[11,"IPC_MAPPED","","",1,[[],["u32"]]],[11,"DEVICE_MAPPED","","",1,[[],["u32"]]],[11,"UNCACHED","","",1,[[],["u32"]]],[11,"READABLE","","",2,[[["self"]],["bool"]]],[11,"WRITABLE","","",2,[[["self"]],["bool"]]],[11,"EXECUTABLE","","",2,[[["self"]],["bool"]]],[11,"READABLE","","",2,[[],["u32"]]],[11,"WRITABLE","","",2,[[],["u32"]]],[11,"EXECUTABLE","","",2,[[],["u32"]]],[11,"fmt","kfs_libkern::error","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_libkern","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"eq","kfs_libkern::error","",5,[[["self"],["kernelerror"]],["bool"]]],[11,"ne","","",5,[[["self"],["kernelerror"]],["bool"]]],[11,"eq","kfs_libkern","",0,[[["self"],["memorytype"]],["bool"]]],[11,"ne","","",0,[[["self"],["memorytype"]],["bool"]]],[11,"eq","","",1,[[["self"],["memoryattributes"]],["bool"]]],[11,"ne","","",1,[[["self"],["memoryattributes"]],["bool"]]],[11,"eq","","",2,[[["self"],["memorypermissions"]],["bool"]]],[11,"ne","","",2,[[["self"],["memorypermissions"]],["bool"]]],[11,"assert_receiver_is_total_eq","kfs_libkern::error","",5,N],[11,"assert_receiver_is_total_eq","kfs_libkern","",0,N],[11,"assert_receiver_is_total_eq","","",1,N],[11,"assert_receiver_is_total_eq","","",2,N],[11,"cmp","","",1,[[["self"],["memoryattributes"]],["ordering"]]],[11,"cmp","","",2,[[["self"],["memorypermissions"]],["ordering"]]],[11,"partial_cmp","","",1,[[["self"],["memoryattributes"]],["option",["ordering"]]]],[11,"lt","","",1,[[["self"],["memoryattributes"]],["bool"]]],[11,"le","","",1,[[["self"],["memoryattributes"]],["bool"]]],[11,"gt","","",1,[[["self"],["memoryattributes"]],["bool"]]],[11,"ge","","",1,[[["self"],["memoryattributes"]],["bool"]]],[11,"partial_cmp","","",2,[[["self"],["memorypermissions"]],["option",["ordering"]]]],[11,"lt","","",2,[[["self"],["memorypermissions"]],["bool"]]],[11,"le","","",2,[[["self"],["memorypermissions"]],["bool"]]],[11,"gt","","",2,[[["self"],["memorypermissions"]],["bool"]]],[11,"ge","","",2,[[["self"],["memorypermissions"]],["bool"]]],[11,"hash","","",1,N],[11,"hash","","",2,N],[11,"sub","","Returns the set difference of the two sets of flags.",1,[[["self"],["memoryattributes"]],["memoryattributes"]]],[11,"sub","","Returns the set difference of the two sets of flags.",2,[[["self"],["memorypermissions"]],["memorypermissions"]]],[11,"sub_assign","","Disables all flags enabled in the set.",1,[[["self"],["memoryattributes"]]]],[11,"sub_assign","","Disables all flags enabled in the set.",2,[[["self"],["memorypermissions"]]]],[11,"not","","Returns the complement of this set of flags.",1,[[["self"]],["memoryattributes"]]],[11,"not","","Returns the complement of this set of flags.",2,[[["self"]],["memorypermissions"]]],[11,"bitand","","Returns the intersection between the two sets of flags.",1,[[["self"],["memoryattributes"]],["memoryattributes"]]],[11,"bitand","","Returns the intersection between the two sets of flags.",2,[[["self"],["memorypermissions"]],["memorypermissions"]]],[11,"bitor","","Returns the union of the two sets of flags.",1,[[["self"],["memoryattributes"]],["memoryattributes"]]],[11,"bitor","","Returns the union of the two sets of flags.",2,[[["self"],["memorypermissions"]],["memorypermissions"]]],[11,"bitxor","","Returns the left flags, but with all the right flags…",1,[[["self"],["memoryattributes"]],["memoryattributes"]]],[11,"bitxor","","Returns the left flags, but with all the right flags…",2,[[["self"],["memorypermissions"]],["memorypermissions"]]],[11,"bitand_assign","","Disables all flags disabled in the set.",1,[[["self"],["memoryattributes"]]]],[11,"bitand_assign","","Disables all flags disabled in the set.",2,[[["self"],["memorypermissions"]]]],[11,"bitor_assign","","Adds the set of flags.",1,[[["self"],["memoryattributes"]]]],[11,"bitor_assign","","Adds the set of flags.",2,[[["self"],["memorypermissions"]]]],[11,"bitxor_assign","","Toggles the set of flags.",1,[[["self"],["memoryattributes"]]]],[11,"bitxor_assign","","Toggles the set of flags.",2,[[["self"],["memorypermissions"]]]],[11,"deref","","",4,N],[11,"from_iter","","",1,[[["t"]],["memoryattributes"]]],[11,"from_iter","","",2,[[["t"]],["memorypermissions"]]],[11,"extend","","",1,[[["self"],["t"]]]],[11,"extend","","",2,[[["self"],["t"]]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"clone","kfs_libkern::error","",5,[[["self"]],["kernelerror"]]],[11,"clone","kfs_libkern","",0,[[["self"]],["memorytype"]]],[11,"clone","","",1,[[["self"]],["memoryattributes"]]],[11,"clone","","",2,[[["self"]],["memorypermissions"]]],[11,"default","","",0,[[],["memorytype"]]],[11,"default","","",1,[[],["memoryattributes"]]],[11,"default","","",2,[[],["memorypermissions"]]],[11,"default","","",3,[[],["memoryinfo"]]],[11,"initialize","","",4,[[["self"]]]]],"paths":[[3,"MemoryType"],[3,"MemoryAttributes"],[3,"MemoryPermissions"],[3,"MemoryInfo"],[3,"SYSCALL_NAMES"],[3,"KernelError"]]};
searchIndex["kfs_libuser"]={"doc":"Userspace library","items":[[0,"io","kfs_libuser","The IO interface",N,N],[8,"Io","kfs_libuser::io","The Io trait allows for accessing device IO in a generic…",N,N],[16,"Value","","The width of the IO access. Should be a primitive type…",0,N],[10,"read","","Reads from this Io.",0,N],[10,"write","","Writes `value` to this Io.",0,N],[11,"readf","","Read from this Io, and mask the value with `flags`.",0,N],[11,"writef","","Mask `value` with `flags`, and write it to this device…",0,N],[3,"ReadOnly","","A read-only wrapper around an IO device.",N,N],[12,"inner","","",1,N],[3,"WriteOnly","","An Io that we can only write to.",N,N],[12,"inner","","",2,N],[3,"Pio","","Port IO accessor.",N,N],[12,"port","","IO-space address this Pio reads from.",3,N],[12,"value","","The word size of this pointer. Should be u8, u16 or u32.",3,N],[5,"find_free_address","kfs_libuser","Finds a free memory zone of the given size and alignment…",N,[[["usize"],["usize"]],["result",["usize","error"]]]],[5,"eh_personality","","The exception handling personality function for use in the…",N,[[]]],[5,"panic_fmt","","Function called on `panic!` invocation. Prints the panic…",N,N],[5,"rust_oom","","OOM handler. Causes a panic.",N,N],[5,"start","","Executable entrypoint. Zeroes out the BSS, calls main, and…",N,N],[5,"main","","",N,N],[0,"caps","","Kernel Capabilities declaration",N,N],[5,"kernel_flags","kfs_libuser::caps","Create a kernel flag capability. Specifies the…",N,[[["u32"],["u32"],["u8"],["u8"]],["u32"]]],[5,"map_normal_page","","Maps the given physical memory page at a random address on…",N,[[["u32"]],["u32"]]],[5,"ioport","","Allows the process to use the given IO Ports directly…",N,[[["u16"]],["u32"]]],[5,"irq_pair","","Allows the process to create an IRQEvent for those IRQs.…",N,[[["u16"],["u16"]],["u32"]]],[5,"application_type","","Declare the type of the application. 0 is a sysmodule, 1…",N,[[["u32"]],["u32"]]],[5,"kernel_release_version","","The minimum kernel version this process expects.",N,[[["u32"]],["u32"]]],[5,"handle_table_size","","Declare the maximum number of live handles this process is…",N,[[["u32"]],["u32"]]],[5,"debug_flags","","Declares whether this application can be debugged (e.g. it…",N,[[["bool"],["bool"]],["u32"]]],[0,"syscalls","kfs_libuser","Syscall Wrappers",N,N],[0,"nr","kfs_libuser::syscalls","Syscall numbers",N,N],[17,"SetHeapSize","kfs_libuser::syscalls::nr","",N,N],[17,"SetMemoryPermission","","",N,N],[17,"SetMemoryAttribute","","",N,N],[17,"MapMemory","","",N,N],[17,"UnmapMemory","","",N,N],[17,"QueryMemory","","",N,N],[17,"ExitProcess","","",N,N],[17,"CreateThread","","",N,N],[17,"StartThread","","",N,N],[17,"ExitThread","","",N,N],[17,"SleepThread","","",N,N],[17,"GetThreadPriority","","",N,N],[17,"SetThreadPriority","","",N,N],[17,"GetThreadCoreMask","","",N,N],[17,"SetThreadCoreMask","","",N,N],[17,"GetCurrentProcessorNumber","","",N,N],[17,"SignalEvent","","",N,N],[17,"ClearEvent","","",N,N],[17,"MapSharedMemory","","",N,N],[17,"UnmapSharedMemory","","",N,N],[17,"CreateTransferMemory","","",N,N],[17,"CloseHandle","","",N,N],[17,"ResetSignal","","",N,N],[17,"WaitSynchronization","","",N,N],[17,"CancelSynchronization","","",N,N],[17,"ArbitrateLock","","",N,N],[17,"ArbitrateUnlock","","",N,N],[17,"WaitProcessWideKeyAtomic","","",N,N],[17,"SignalProcessWideKey","","",N,N],[17,"GetSystemTick","","",N,N],[17,"ConnectToNamedPort","","",N,N],[17,"SendSyncRequestLight","","",N,N],[17,"SendSyncRequest","","",N,N],[17,"SendSyncRequestWithUserBuffer","","",N,N],[17,"SendAsyncRequestWithUserBuffer","","",N,N],[17,"GetProcessId","","",N,N],[17,"GetThreadId","","",N,N],[17,"Break","","",N,N],[17,"OutputDebugString","","",N,N],[17,"ReturnFromException","","",N,N],[17,"GetInfo","","",N,N],[17,"FlushEntireDataCache","","",N,N],[17,"FlushDataCache","","",N,N],[17,"MapPhysicalMemory","","",N,N],[17,"UnmapPhysicalMemory","","",N,N],[17,"GetFutureThreadInfo","","",N,N],[17,"GetLastThreadInfo","","",N,N],[17,"GetResourceLimitLimitValue","","",N,N],[17,"GetResourceLimitCurrentValue","","",N,N],[17,"SetThreadActivity","","",N,N],[17,"GetThreadContext3","","",N,N],[17,"WaitForAddress","","",N,N],[17,"SignalToAddress","","",N,N],[17,"DumpInfo","","",N,N],[17,"DumpInfoNew","","",N,N],[17,"CreateSession","","",N,N],[17,"AcceptSession","","",N,N],[17,"ReplyAndReceiveLight","","",N,N],[17,"ReplyAndReceive","","",N,N],[17,"ReplyAndReceiveWithUserBuffer","","",N,N],[17,"CreateEvent","","",N,N],[17,"MapPhysicalMemoryUnsafe","","",N,N],[17,"UnmapPhysicalMemoryUnsafe","","",N,N],[17,"SetUnsafeLimit","","",N,N],[17,"CreateCodeMemory","","",N,N],[17,"ControlCodeMemory","","",N,N],[17,"SleepSystem","","",N,N],[17,"ReadWriteRegister","","",N,N],[17,"SetProcessActivity","","",N,N],[17,"CreateSharedMemory","","",N,N],[17,"MapTransferMemory","","",N,N],[17,"UnmapTransferMemory","","",N,N],[17,"CreateInterruptEvent","","",N,N],[17,"QueryPhysicalAddress","","",N,N],[17,"QueryIoMapping","","",N,N],[17,"CreateDeviceAddressSpace","","",N,N],[17,"AttachDeviceAddressSpace","","",N,N],[17,"DetachDeviceAddressSpace","","",N,N],[17,"MapDeviceAddressSpaceByForce","","",N,N],[17,"MapDeviceAddressSpaceAligned","","",N,N],[17,"MapDeviceAddressSpace","","",N,N],[17,"UnmapDeviceAddressSpace","","",N,N],[17,"InvalidateProcessDataCache","","",N,N],[17,"StoreProcessDataCache","","",N,N],[17,"FlushProcessDataCache","","",N,N],[17,"DebugActiveProcess","","",N,N],[17,"BreakDebugProcess","","",N,N],[17,"TerminateDebugProcess","","",N,N],[17,"GetDebugEvent","","",N,N],[17,"ContinueDebugEvent","","",N,N],[17,"GetProcessList","","",N,N],[17,"GetThreadList","","",N,N],[17,"GetDebugThreadContext","","",N,N],[17,"SetDebugThreadContext","","",N,N],[17,"QueryDebugProcessMemory","","",N,N],[17,"ReadDebugProcessMemory","","",N,N],[17,"WriteDebugProcessMemory","","",N,N],[17,"SetHardwareBreakPoint","","",N,N],[17,"GetDebugThreadParam","","",N,N],[17,"GetSystemInfo","","",N,N],[17,"CreatePort","","",N,N],[17,"ManageNamedPort","","",N,N],[17,"ConnectToPort","","",N,N],[17,"SetProcessMemoryPermission","","",N,N],[17,"MapProcessMemory","","",N,N],[17,"UnmapProcessMemory","","",N,N],[17,"QueryProcessMemory","","",N,N],[17,"MapProcessCodeMemory","","",N,N],[17,"UnmapProcessCodeMemory","","",N,N],[17,"CreateProcess","","",N,N],[17,"StartProcess","","",N,N],[17,"TerminateProcess","","",N,N],[17,"GetProcessInfo","","",N,N],[17,"CreateResourceLimit","","",N,N],[17,"SetResourceLimitLimitValue","","",N,N],[17,"CallSecureMonitor","","",N,N],[17,"MapFramebuffer","","",N,N],[17,"StartProcessEntrypoint","","",N,N],[17,"MaxSvc","","",N,N],[3,"MemoryInfo","kfs_libuser::syscalls","The structure returned by the `query_memory` syscall.",N,N],[12,"baseaddr","","The base address of this memory region.",4,N],[12,"size","","The size of this memory region, from the base address.",4,N],[12,"memtype","","The type of this mapping.",4,N],[12,"memattr","","The attributes of this mapping.",4,N],[12,"perms","","The permissions of this mapping.",4,N],[12,"ipc_ref_count","","Counts how many IPC service requests have an IPC buffer in…",4,N],[12,"device_ref_count","","Unknown.",4,N],[3,"MemoryPermissions","","Memory permissions of a memory area.",N,N],[12,"bits","","",5,N],[3,"Registers","","Register backup structure. The syscall_inner will pop the…",N,N],[12,"eax","","",6,N],[12,"ebx","","",6,N],[12,"ecx","","",6,N],[12,"edx","","",6,N],[12,"esi","","",6,N],[12,"edi","","",6,N],[12,"ebp","","",6,N],[5,"syscall","","Generic syscall function.",N,[[["usize"],["usize"],["usize"],["usize"],["usize"],["usize"],["usize"]],["result",["kernelerror"]]]],[5,"set_heap_size","","Resize the heap of a process, just like a brk. It can both…",N,[[["usize"]],["result",["usize","kernelerror"]]]],[5,"query_memory","","Query information about an address. Will fetch the…",N,[[["usize"]],["result",["kernelerror"]]]],[5,"exit_process","","Exits the process, killing all threads.",N,N],[5,"create_thread","","Creates a thread in the current process.",N,N],[5,"start_thread","","Starts the thread for the provided handle.",N,[[["thread"]],["result",["kernelerror"]]]],[5,"exit_thread","","Exits the current thread.",N,N],[5,"sleep_thread","","Sleeps for a specified amount of time, or yield thread.",N,[[["usize"]],["result",["kernelerror"]]]],[5,"create_shared_memory","","Creates a shared memory handle.",N,[[["usize"],["memorypermissions"],["memorypermissions"]],["result",["sharedmemory","kernelerror"]]]],[5,"map_shared_memory","","Maps a shared memory.",N,[[["sharedmemory"],["usize"],["usize"],["memorypermissions"]],["result",["kernelerror"]]]],[5,"unmap_shared_memory","","Unmaps a shared memory.",N,[[["sharedmemory"],["usize"],["usize"]],["result",["kernelerror"]]]],[5,"close_handle","","Close the given handle.",N,[[["u32"]],["result",["kernelerror"]]]],[5,"wait_synchronization","","Wait for an event on the given handles.",N,N],[5,"connect_to_named_port","","Creates a session to the given named port.",N,[[["str"]],["result",["clientsession","kernelerror"]]]],[5,"send_sync_request_with_user_buffer","","Send an IPC request through the given pipe.",N,N],[5,"output_debug_string","","Print the given string to the kernel's debug output.",N,[[["str"]],["result",["kernelerror"]]]],[5,"create_session","","Create an anonymous session.",N,[[["bool"],["usize"]],["result",["kernelerror"]]]],[5,"accept_session","","Accept a connection on the given port.",N,[[["serverport"]],["result",["serversession","kernelerror"]]]],[5,"reply_and_receive_with_user_buffer","","Reply and Receive IPC requests on the given handles.",N,N],[5,"create_interrupt_event","","Create a waitable object for the given IRQ number.",N,[[["usize"],["u32"]],["result",["readableevent","kernelerror"]]]],[5,"create_port","","Creates an anonymous port.",N,[[["u32"],["bool"],["str"]],["result",["kernelerror"]]]],[5,"manage_named_port","","Creates a named port.",N,[[["str"],["u32"]],["result",["serverport","kernelerror"]]]],[5,"connect_to_port","","Connects to the given named port.",N,[[["clientport"]],["result",["clientsession","kernelerror"]]]],[5,"map_framebuffer","","Maps the framebuffer to a kernel-chosen address.",N,[[],["result",["kernelerror"]]]],[5,"syscall_inner","","",N,N],[0,"syscall_inner","","",N,N],[0,"types","kfs_libuser","Core kernel types.",N,N],[3,"Handle","kfs_libuser::types","A Handle is a sort of reference to a Kernel Object. Its…",N,N],[12,"0","","",7,N],[3,"HandleRef","","A fake reference to a Handle. Has the same representation…",N,N],[12,"inner","","The underlying handle number.",8,N],[12,"lifetime","","The real handle this reference is tied to.",8,N],[3,"ReadableEvent","","An awaitable event handle, such as an IRQ event.",N,N],[12,"0","","",9,N],[3,"ClientSession","","The client side of an IPC session.",N,N],[12,"0","","",10,N],[3,"ServerSession","","The server side of an IPC session.",N,N],[12,"0","","",11,N],[3,"ClientPort","","The client side of an IPC Port. Allows connecting to an…",N,N],[12,"0","","",12,N],[3,"ServerPort","","The server side of an IPC Port. Allows listening for…",N,N],[12,"0","","",13,N],[3,"Thread","","A Thread. Created with the [create_thread syscall].",N,N],[12,"0","","",14,N],[3,"SharedMemory","","A handle to memory that may be mapped in multiple…",N,N],[12,"0","","",15,N],[3,"MappedSharedMemory","","A mapping to a shared memory region.",N,N],[12,"handle","","",16,N],[12,"addr","","",16,N],[12,"size","","",16,N],[3,"Pid","","Process ID, as returned by IPC.",N,N],[12,"0","","",17,N],[11,"new","","Creates a new handle from the given number. This number…",7,[[["u32"]],["handle"]]],[11,"as_ref","","Creates a new reference to this handle. See the…",7,[[["self"]],["handleref"]]],[11,"send_sync_request_with_user_buffer","","Send an IPC request to the handle, and wait for a…",10,N],[11,"into_handle","","Consumes the session, returning the underlying handle.…",10,[[["self"]],["handle"]]],[11,"receive","","Receives an IPC request from the session, waiting if none…",11,N],[11,"reply","","Replies to an IPC request on the given session. If the…",11,N],[11,"connect","","Connects to a port, returning a session on which to send…",12,[[["self"]],["result",["clientsession","error"]]]],[11,"accept","","Accepts a connection to the port, returning a server…",13,[[["self"]],["result",["serversession","error"]]]],[11,"start","","Start the thread.",14,[[["self"]],["result",["error"]]]],[11,"new","","Creates a new Shared Memory handle. The physical memory…",15,[[["usize"],["memorypermissions"],["memorypermissions"]],["result",["sharedmemory","error"]]]],[11,"map","","Maps the current shared memory at the given address,…",15,[[["self"],["usize"],["usize"],["memorypermissions"]],["result",["mappedsharedmemory","error"]]]],[11,"get","","Get the underlying shared memory as a byte slice.",16,N],[11,"get_mut","","Get the underlying shared memory as a mutable byte slice.",16,N],[11,"as_ptr","","Gets a raw pointer to the underlying shared memory.",16,N],[11,"as_mut_ptr","","Gets a mutable raw pointer to the underlying shared memory.",16,N],[11,"len","","Gets the byte length of the mapped shared memory.",16,[[["self"]],["usize"]]],[11,"as_shared_mem","","Return a reference to the underlying shared memory. Useful…",16,[[["self"]],["sharedmemory"]]],[0,"ipc","kfs_libuser","Core IPC Routines",N,N],[3,"MsgPackedHdr","kfs_libuser::ipc","Represenens the header of an HIPC command.",N,N],[12,"0","","",18,N],[3,"HandleDescriptorHeader","","Part of an HIPC command. Sent only when…",N,N],[12,"0","","",19,N],[3,"IPCBuffer","","An IPC Buffer represents a section of memory to send to…",N,N],[12,"addr","","Address to the value",20,N],[12,"size","","Size of the value",20,N],[12,"ty","","Buffer type",20,N],[12,"phantom","","Tie the buffer's lifetime to the value's ! This is very…",20,N],[3,"Message","","A generic IPC message, representing either an IPC Request…",N,N],[12,"ty","","Type of the message. This is derived from [MessageTy] and…",21,N],[12,"pid","","Optional PID included in the message. For outgoing…",21,N],[12,"buffers","","Array of IPC Buffers included in the message.",21,N],[12,"copy_handles","","Array of copy handles included in the message. Copy…",21,N],[12,"move_handles","","Array of move handles included in the message. Move…",21,N],[12,"is_request","","Whether this message contains an IPC request or an IPC…",21,N],[12,"cmdid_error","","Contains either the cmdid (if this message is a request)…",21,N],[12,"token","","Optional tracking token. This is used to track the origin…",21,N],[12,"raw","","The raw arguments included in this message.",21,N],[4,"IPCBufferType","","Type of an IPC Buffer. Depending on the type, the kernel…",N,N],[13,"A","","Send Buffer.",22,N],[12,"flags","kfs_libuser::ipc::IPCBufferType","Determines what MemoryState to use with the mapped memory…",22,N],[13,"B","kfs_libuser::ipc","Receive Buffer.",22,N],[12,"flags","kfs_libuser::ipc::IPCBufferType","Determines what MemoryState to use with the mapped memory…",22,N],[13,"X","kfs_libuser::ipc","Pointer.",22,N],[12,"counter","kfs_libuser::ipc::IPCBufferType","The index of the C buffer to copy this pointer into.",22,N],[13,"C","kfs_libuser::ipc","Receive List.",22,N],[12,"has_u16_size","kfs_libuser::ipc::IPCBufferType","If true, the size of the receive list should be written in…",22,N],[4,"MessageTy","kfs_libuser::ipc","Type of an IPC message.",N,N],[13,"Close","","Requests the other end to close the handle and any…",23,N],[13,"Request","","A normal request.",23,N],[13,"Control","","A request handled by the server handler. See [switchbrew]…",23,N],[5,"find_ty_cmdid","","Quickly find the type and cmdid of an IPC message for the…",N,N],[0,"macros","","IPC Macros",N,N],[0,"server","","IPC Server primitives",N,N],[3,"WaitableManager","kfs_libuser::ipc::server","The event loop manager. Waits on the waitable objects…",N,N],[12,"to_add_waitables","","Vector of items to add to the waitable list on the next…",24,N],[3,"Align16","","Wrapper struct that forces the alignment to 0x10. Somewhat…",N,N],[12,"0","","",25,N],[3,"SessionWrapper","","A wrapper around an Object backed by an IPC Session that…",N,N],[12,"handle","","Kernel Handle backing this object.",26,N],[12,"object","","Object instance.",26,N],[12,"buf","","Command buffer for this session. Ensure 16 bytes of…",26,N],[3,"PortHandler","","A wrapper around a Server Port that implements the…",N,N],[12,"handle","","The kernel object backing this Port Handler.",27,N],[12,"phantom","","Type of the Object this port creates.",27,N],[5,"encode_bytes","","Encode an 8-character service string into an u64",N,[[["str"]],["u64"]]],[8,"IWaitable","","A handle to a waitable object.",N,N],[10,"get_handle","","Gets the handleref for use in the `wait_synchronization`…",28,[[["self"]],["handleref"]]],[10,"handle_signaled","","Function the manager calls when this object gets signaled.",28,[[["self"],["waitablemanager"]],["result",["bool","error"]]]],[8,"Object","","An IPC object.",N,N],[10,"dispatch","","Handle a request with the given cmdid.",29,N],[11,"new","","Creates an empty waitable manager.",24,[[],["waitablemanager"]]],[11,"add_waitable","","Add a new handle for the waitable manager to wait on.",24,[[["self"],["box",["iwaitable"]]]]],[11,"run","","Run the event loop. This will call wait_synchronization on…",24,N],[11,"new","","Create a new SessionWrapper from an open ServerSession and…",26,[[["serversession"],["t"]],["sessionwrapper"]]],[11,"new","","Registers a new PortHandler of the given name to the sm:…",27,[[["str"]],["result",["porthandler","error"]]]],[11,"new_managed","","Registers a new PortHandler of the given name to the…",27,[[["str"]],["result",["porthandler","error"]]]],[11,"ty","kfs_libuser::ipc","",18,[[["self"]],["u16"]]],[11,"set_ty","","",18,[[["self"],["u16"]]]],[11,"num_x_descriptors","","",18,[[["self"]],["u8"]]],[11,"set_num_x_descriptors","","",18,[[["self"],["u8"]]]],[11,"num_a_descriptors","","",18,[[["self"]],["u8"]]],[11,"set_num_a_descriptors","","",18,[[["self"],["u8"]]]],[11,"num_b_descriptors","","",18,[[["self"]],["u8"]]],[11,"set_num_b_descriptors","","",18,[[["self"],["u8"]]]],[11,"num_w_descriptors","","",18,[[["self"]],["u8"]]],[11,"set_num_w_descriptors","","",18,[[["self"],["u8"]]]],[11,"raw_section_size","","",18,[[["self"]],["u16"]]],[11,"set_raw_section_size","","",18,[[["self"],["u16"]]]],[11,"c_descriptor_flags","","",18,[[["self"]],["u8"]]],[11,"set_c_descriptor_flags","","",18,[[["self"],["u8"]]]],[11,"enable_handle_descriptor","","",18,[[["self"]],["bool"]]],[11,"set_enable_handle_descriptor","","",18,[[["self"],["bool"]]]],[11,"send_pid","","",19,[[["self"]],["bool"]]],[11,"set_send_pid","","",19,[[["self"],["bool"]]]],[11,"num_copy_handles","","",19,[[["self"]],["u8"]]],[11,"set_num_copy_handles","","",19,[[["self"],["u8"]]]],[11,"num_move_handles","","",19,[[["self"]],["u8"]]],[11,"set_num_move_handles","","",19,[[["self"],["u8"]]]],[11,"is_type_a","","Checks if this buffer is a Send Buffer.",22,[[["self"]],["bool"]]],[11,"is_type_b","","Checks if this buffer is a Receive Buffer.",22,[[["self"]],["bool"]]],[11,"from_mut_ref","","Creates an IPC buffer from a mutable reference and a type.…",20,[[["t"],["ipcbuffertype"]],["ipcbuffer"]]],[11,"from_ref","","Creates an IPC buffer from a reference and a type. The…",20,[[["t"],["ipcbuffertype"]],["ipcbuffer"]]],[11,"from_slice","","Creates an IPC buffer from a mutable slice and a type. The…",20,N],[11,"from_mut_slice","","Creates an IPC buffer from a slice and a type. The type…",20,N],[11,"from_ptr_len","","Creates an IPC buffer from a raw pointer, a len and a…",20,N],[11,"from_mut_ptr_len","","Creates an IPC buffer from a raw mut pointer, a len and a…",20,N],[11,"buftype","","Gets the [IPCBufferType] of this buffer. The buffer type…",20,[[["self"]],["ipcbuffertype"]]],[11,"new_request","","Create a new request for the given cmdid. If a token is…",21,[[["option",["u32"]],["u32"]],["message"]]],[11,"new_response","","Create a new empty reply. If the request this reply is…",21,[[["option",["u32"]]],["message"]]],[11,"set_ty","","Sets the message type.",21,[[["self"],["messagety"]],["self"]]],[11,"set_error","","Set the error code from a reply.",21,[[["self"],["u32"]],["self"]]],[11,"error","","Get the error code from a reply.",21,[[["self"]],["result",["error"]]]],[11,"push_raw","","Sets the raw data of the message.",21,[[["self"],["raw"]],["self"]]],[11,"raw","","Gets the raw data of the message.",21,[[["self"]],["raw"]]],[11,"token","","Gets the token of a message. This token is used to track…",21,[[["self"]],["option",["u32"]]]],[11,"push_handle_move","","Move a handle over IPC. Once the message is sent, the…",21,[[["self"],["handle"]],["self"]]],[11,"push_handle_copy","","Copy a handle over IPC. The remote process will have a…",21,[[["self"],["handleref"]],["self"]]],[11,"pop_handle_move","","Retrieve a moved handle from this IPC message. Those are…",21,[[["self"]],["result",["handle","error"]]]],[11,"pop_handle_copy","","Retrieve a copied handle from this IPC message. Those are…",21,[[["self"]],["result",["handle","error"]]]],[11,"pop_pid","","Retrieve the PID of the remote process (if sent at all).…",21,[[["self"]],["result",["pid","error"]]]],[11,"pack","","Packs this IPC Message to an IPC buffer.",21,N],[11,"unpack","","Parse the passed buffer into an IPC Message.",21,N],[0,"sm","kfs_libuser","Service Manager",N,N],[3,"IUserInterface","kfs_libuser::sm","Main interface of the service manager. Allows registering…",N,N],[12,"0","","",30,N],[11,"raw_new","","Connects to the Service Manager.",30,[[],["result",["iuserinterface","error"]]]],[11,"get_service","","Retrieves a service registered in the service manager.",30,[[["self"],["u64"]],["result",["clientsession","error"]]]],[11,"register_service","","Registers a service registered in the service manager.",30,[[["self"],["u64"],["bool"],["u32"]],["result",["serverport","error"]]]],[0,"vi","kfs_libuser","Vi Compositor service",N,N],[3,"ViInterface","kfs_libuser::vi","Main compositor interface.",N,N],[12,"0","","",31,N],[3,"IBuffer","","A handle to a window. Created through the create_buffer…",N,N],[12,"0","","",32,N],[11,"raw_new","","Connects to the vi service.",31,[[],["result",["viinterface","error"]]]],[11,"create_buffer","","Create a new window of the given size at the given…",31,[[["self"],["sharedmemory"],["i32"],["i32"],["u32"],["u32"]],["result",["ibuffer","error"]]]],[11,"draw","","Ask the compositor to redraw the window. This will cause…",32,[[["self"]],["result",["error"]]]],[0,"error","kfs_libuser","Error handling",N,N],[3,"KernelError","kfs_libuser::error","Kernel syscall error codes.",N,N],[12,"0","","",33,N],[3,"Module","","",N,N],[12,"0","","",34,N],[3,"LibuserError","","Internal libuser errors.",N,N],[12,"0","","",35,N],[3,"SmError","","Service Manager errors.",N,N],[12,"0","","",36,N],[4,"Error","","The global error type. Every error defined here can be…",N,N],[13,"Kernel","","A Kernel Error. Usually returned by syscalls.",37,N],[13,"Sm","","Service Manager error.",37,N],[13,"Libuser","","Internal Libuser error.",37,N],[13,"Unknown","","An unknown error type. Either someone returned a custom…",37,N],[17,"_DERIVE_failure_Fail_FOR_Error","","",N,N],[11,"from_code","","Create an Error from a packed error code, creating a…",37,[[["u32"]],["error"]]],[11,"as_code","","Pack this error into an error code. Note that the returned…",37,[[["self"]],["u32"]]],[18,"Kernel","","",34,N],[18,"Sm","","",34,N],[18,"Vi","","",34,N],[18,"Libuser","","",34,N],[18,"AddressSpaceExhausted","","An attempt to find available space failed.",35,N],[18,"InvalidMoveHandleCount","","Too many move handles were passed to an IPC message.",35,N],[18,"InvalidCopyHandleCount","","Too many copy handles were passed to an IPC message.",35,N],[18,"PidMissing","","Attempted to read PID from an IPC message containing none.",35,N],[18,"OutOfProcesses","","Too many processes spawned.",36,N],[18,"NotInitialized","","Attempted to use the service manager without initializing…",36,N],[18,"MaxSessions","","This service already reached the maximum amount of…",36,N],[18,"ServiceAlreadyRegistered","","Attempted to register a service that already exists.",36,N],[18,"OutOfServices","","Too many services have been created.",36,N],[18,"InvalidName","","The name is too long. Make sure it's only 7 characters and…",36,N],[18,"ServiceNotRegistered","","Attempted to unregister a service that was not previously…",36,N],[18,"PermissionDenied","","Process SACs do not allow accessing or hosting this service.",36,N],[18,"ServiceAccessControlTooBig","","The provided SACs are too big.",36,N],[0,"allocator","kfs_libuser","Heap allocator.",N,N],[3,"Allocator","kfs_libuser::allocator","The libuser heap allocator.",N,N],[12,"0","","",38,N],[11,"expand","","Safely expands the heap if possible.",38,[[["mutexguard"],["usize"]],["result",["kernelerror"]]]],[11,"new","","Creates an empty heap.",38,[[],["allocator"]]],[0,"terminal","kfs_libuser","Terminal rendering APIs",N,N],[3,"Pos","kfs_libuser::terminal","Just an x and a y",N,N],[12,"x","","",39,N],[12,"y","","",39,N],[3,"Terminal","","A struct for logging text to the window. Renders…",N,N],[12,"framebuffer","","Rendering target for this terminal.",40,N],[12,"cursor_pos","","Cursor pos, in pixels. Does not account for bpp.…",40,N],[12,"font","","The font in use for this terminal.",40,N],[12,"cached_glyphs","","We cache ascii glyphs to avoid rendering them every time.",40,N],[12,"advance_width","","Expected to be the same for every glyph since it should be…",40,N],[12,"linespace","","The distance between two baselines.",40,N],[12,"ascent","","The maximum ascent in the font.",40,N],[12,"descent","","The maximum descent in the font.",40,N],[4,"WindowSize","","Window creation requested size.",N,N],[13,"Fullscreen","","Takes the full screen.",41,N],[13,"FontLines","","Takes a given amount of lines.",41,N],[13,"Manual","","Manually position the window at the given x/y, with a…",41,N],[7,"FONT","","The font we choose to render in",N,N],[17,"FONT_SIZE","","The size we choose to render in",N,N],[11,"new","","Creates a new Window of the requested size for terminal…",40,[[["windowsize"]],["result",["error"]]]],[11,"draw","","Ask the compositor to redraw the window.",40,[[["self"]],["result",["error"]]]],[11,"carriage_return","","Move the cursor to the beginning of the current line.",40,[[["self"]]]],[11,"line_feed","","Move the cursor to the beginning of the next line,…",40,[[["self"]]]],[11,"advance_pos","","Move the cursor to the next position for drawing a…",40,[[["self"]]]],[11,"move_pos_back","","Move the cursor back to the previous position. If we are…",40,[[["self"]]]],[11,"scroll_screen","","scrolls the whole screen by one line. self.pos must be on…",40,[[["self"]]]],[11,"clear","","Clears the whole screen and reset cursor",40,[[["self"]]]],[11,"print_attr","","Prints a string to the screen with attributes",40,[[["self"],["str"],["color"],["color"]]]],[11,"display_glyph_in_box","","Copies a rendered character to the screen, displaying it…",40,[[["glyphbitmap"],["window"],["usize"],["usize"],["usize"],["color"],["color"],["pos"]]]],[0,"window","kfs_libuser","Window creation and drawing APIs",N,N],[3,"Color","kfs_libuser::window","A rgb color",N,N],[12,"b","","Blue component",42,N],[12,"g","","Green component",42,N],[12,"r","","Red component",42,N],[12,"a","","Alpha component",42,N],[3,"Window","","A managed window.",N,N],[12,"buf","","The framebuffer memory shared with Vi. Drawing to this…",43,N],[12,"handle","","Vi handle for this window.",43,N],[12,"width","","Width of the window.",43,N],[12,"height","","Height of the window.",43,N],[12,"bpp","","Bits per pixel for the framebuffer.",43,N],[11,"rgb","","Creates a color from the r/g/b components. Alpha will be…",42,[[["u8"],["u8"],["u8"]],["color"]]],[11,"new","","Creates a window in the vi compositor.",43,[[["i32"],["i32"],["u32"],["u32"]],["result",["window","error"]]]],[11,"draw","","Ask the compositor to redraw the window.",43,[[["self"]],["result",["error"]]]],[11,"width","","window width in pixels. Does not account for bpp",43,[[["self"]],["usize"]]],[11,"height","","window height in pixels. Does not account for bpp",43,[[["self"]],["usize"]]],[11,"bpp","","The number of bits that forms a pixel. Used to compute…",43,[[["self"]],["usize"]]],[11,"get_px_offset","","Gets the offset in memory of a pixel based on an x and y.",43,[[["self"],["usize"],["usize"]],["usize"]]],[11,"write_px","","Writes a pixel in the window respecting the bgr pattern",43,[[["self"],["usize"],["color"]]]],[11,"write_px_at","","Writes a pixel in the window respecting the bgr pattern…",43,[[["self"],["usize"],["usize"],["color"]]]],[11,"get_buffer","","Gets the underlying framebuffer",43,N],[11,"clear","","Clears the whole window, making it black.",43,[[["self"]]]],[0,"log_impl","kfs_libuser","Implementation for the log crate",N,N],[3,"SVC_LOG_BUFFER","kfs_libuser::log_impl","Buffer where pending writes are stored. The buffer is only…",N,N],[12,"__private_field","","",44,N],[3,"Logger","","Log implementation structure.",N,N],[5,"init","","Initializes the global logger with the svc logger.",N,[[]]],[7,"SVC_LOG_BUFFER","","",N,N],[0,"__rg_allocator_abi","kfs_libuser","",N,N],[5,"__rg_alloc","kfs_libuser::__rg_allocator_abi","",N,N],[5,"__rg_dealloc","","",N,N],[5,"__rg_realloc","","",N,N],[5,"__rg_alloc_zeroed","","",N,N],[7,"ALLOCATOR","kfs_libuser","Global allocator. Every implicit allocation in the rust…",N,N],[8,"Termination","","A trait for implementing arbitrary return types in the…",N,N],[10,"report","","Is called to get the representation of the value as status…",45,[[["self"]],["i32"]]],[14,"capabilities","","Define the capabilities array in the .kernel_caps section.…",N,N],[14,"object","","Auto derive Object.",N,N],[11,"from","kfs_libuser::io","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"from","kfs_libuser::syscalls","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"from","","",6,[[["t"]],["t"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"from","kfs_libuser::types","",7,[[["t"]],["t"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"from","","",8,[[["t"]],["t"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"from","","",9,[[["t"]],["t"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"from","","",10,[[["t"]],["t"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"from","","",11,[[["t"]],["t"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"from","","",12,[[["t"]],["t"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"from","","",13,[[["t"]],["t"]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"into","","",13,[[["self"]],["u"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"from","","",14,[[["t"]],["t"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"try_into","","",14,[[["self"]],["result"]]],[11,"into","","",14,[[["self"]],["u"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"get_type_id","","",14,[[["self"]],["typeid"]]],[11,"from","","",15,[[["t"]],["t"]]],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"try_into","","",15,[[["self"]],["result"]]],[11,"into","","",15,[[["self"]],["u"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"get_type_id","","",15,[[["self"]],["typeid"]]],[11,"from","","",16,[[["t"]],["t"]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"into","","",16,[[["self"]],["u"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"from","","",17,[[["t"]],["t"]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"into","","",17,[[["self"]],["u"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"get_type_id","","",17,[[["self"]],["typeid"]]],[11,"to_owned","","",17,[[["self"]],["t"]]],[11,"clone_into","","",17,N],[11,"from","kfs_libuser::ipc","",18,[[["t"]],["t"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"into","","",18,[[["self"]],["u"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"get_type_id","","",18,[[["self"]],["typeid"]]],[11,"bit","","",18,[[["self"],["usize"]],["bool"]]],[11,"set_bit","","",18,N],[11,"from","","",19,[[["t"]],["t"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"try_into","","",19,[[["self"]],["result"]]],[11,"into","","",19,[[["self"]],["u"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"get_type_id","","",19,[[["self"]],["typeid"]]],[11,"bit","","",19,[[["self"],["usize"]],["bool"]]],[11,"set_bit","","",19,N],[11,"from","","",20,[[["t"]],["t"]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"try_into","","",20,[[["self"]],["result"]]],[11,"into","","",20,[[["self"]],["u"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"get_type_id","","",20,[[["self"]],["typeid"]]],[11,"to_owned","","",20,[[["self"]],["t"]]],[11,"clone_into","","",20,N],[11,"from","","",21,[[["t"]],["t"]]],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"try_into","","",21,[[["self"]],["result"]]],[11,"into","","",21,[[["self"]],["u"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"get_type_id","","",21,[[["self"]],["typeid"]]],[11,"from","","",22,[[["t"]],["t"]]],[11,"try_from","","",22,[[["u"]],["result"]]],[11,"try_into","","",22,[[["self"]],["result"]]],[11,"into","","",22,[[["self"]],["u"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"get_type_id","","",22,[[["self"]],["typeid"]]],[11,"to_owned","","",22,[[["self"]],["t"]]],[11,"clone_into","","",22,N],[11,"from","","",23,[[["t"]],["t"]]],[11,"try_from","","",23,[[["u"]],["result"]]],[11,"try_into","","",23,[[["self"]],["result"]]],[11,"into","","",23,[[["self"]],["u"]]],[11,"borrow","","",23,[[["self"]],["t"]]],[11,"borrow_mut","","",23,[[["self"]],["t"]]],[11,"get_type_id","","",23,[[["self"]],["typeid"]]],[11,"from","kfs_libuser::ipc::server","",24,[[["t"]],["t"]]],[11,"try_from","","",24,[[["u"]],["result"]]],[11,"try_into","","",24,[[["self"]],["result"]]],[11,"into","","",24,[[["self"]],["u"]]],[11,"borrow","","",24,[[["self"]],["t"]]],[11,"borrow_mut","","",24,[[["self"]],["t"]]],[11,"get_type_id","","",24,[[["self"]],["typeid"]]],[11,"from","","",25,[[["t"]],["t"]]],[11,"try_from","","",25,[[["u"]],["result"]]],[11,"try_into","","",25,[[["self"]],["result"]]],[11,"into","","",25,[[["self"]],["u"]]],[11,"borrow","","",25,[[["self"]],["t"]]],[11,"borrow_mut","","",25,[[["self"]],["t"]]],[11,"get_type_id","","",25,[[["self"]],["typeid"]]],[11,"from","","",26,[[["t"]],["t"]]],[11,"try_from","","",26,[[["u"]],["result"]]],[11,"try_into","","",26,[[["self"]],["result"]]],[11,"into","","",26,[[["self"]],["u"]]],[11,"borrow","","",26,[[["self"]],["t"]]],[11,"borrow_mut","","",26,[[["self"]],["t"]]],[11,"get_type_id","","",26,[[["self"]],["typeid"]]],[11,"from","","",27,[[["t"]],["t"]]],[11,"try_from","","",27,[[["u"]],["result"]]],[11,"try_into","","",27,[[["self"]],["result"]]],[11,"into","","",27,[[["self"]],["u"]]],[11,"borrow","","",27,[[["self"]],["t"]]],[11,"borrow_mut","","",27,[[["self"]],["t"]]],[11,"get_type_id","","",27,[[["self"]],["typeid"]]],[11,"from","kfs_libuser::sm","",30,[[["t"]],["t"]]],[11,"try_from","","",30,[[["u"]],["result"]]],[11,"try_into","","",30,[[["self"]],["result"]]],[11,"into","","",30,[[["self"]],["u"]]],[11,"borrow","","",30,[[["self"]],["t"]]],[11,"borrow_mut","","",30,[[["self"]],["t"]]],[11,"get_type_id","","",30,[[["self"]],["typeid"]]],[11,"from","kfs_libuser::vi","",31,[[["t"]],["t"]]],[11,"try_from","","",31,[[["u"]],["result"]]],[11,"try_into","","",31,[[["self"]],["result"]]],[11,"into","","",31,[[["self"]],["u"]]],[11,"borrow","","",31,[[["self"]],["t"]]],[11,"borrow_mut","","",31,[[["self"]],["t"]]],[11,"get_type_id","","",31,[[["self"]],["typeid"]]],[11,"from","","",32,[[["t"]],["t"]]],[11,"try_from","","",32,[[["u"]],["result"]]],[11,"try_into","","",32,[[["self"]],["result"]]],[11,"into","","",32,[[["self"]],["u"]]],[11,"borrow","","",32,[[["self"]],["t"]]],[11,"borrow_mut","","",32,[[["self"]],["t"]]],[11,"get_type_id","","",32,[[["self"]],["typeid"]]],[11,"from","kfs_libuser::error","",33,[[["t"]],["t"]]],[11,"try_from","","",33,[[["u"]],["result"]]],[11,"try_into","","",33,[[["self"]],["result"]]],[11,"into","","",33,[[["self"]],["u"]]],[11,"borrow","","",33,[[["self"]],["t"]]],[11,"borrow_mut","","",33,[[["self"]],["t"]]],[11,"get_type_id","","",33,[[["self"]],["typeid"]]],[11,"to_owned","","",33,[[["self"]],["t"]]],[11,"clone_into","","",33,N],[11,"to_string","","",33,[[["self"]],["string"]]],[11,"from","","",34,[[["t"]],["t"]]],[11,"try_from","","",34,[[["u"]],["result"]]],[11,"try_into","","",34,[[["self"]],["result"]]],[11,"into","","",34,[[["self"]],["u"]]],[11,"borrow","","",34,[[["self"]],["t"]]],[11,"borrow_mut","","",34,[[["self"]],["t"]]],[11,"get_type_id","","",34,[[["self"]],["typeid"]]],[11,"to_owned","","",34,[[["self"]],["t"]]],[11,"clone_into","","",34,N],[11,"from","","",35,[[["t"]],["t"]]],[11,"try_from","","",35,[[["u"]],["result"]]],[11,"try_into","","",35,[[["self"]],["result"]]],[11,"into","","",35,[[["self"]],["u"]]],[11,"borrow","","",35,[[["self"]],["t"]]],[11,"borrow_mut","","",35,[[["self"]],["t"]]],[11,"get_type_id","","",35,[[["self"]],["typeid"]]],[11,"to_owned","","",35,[[["self"]],["t"]]],[11,"clone_into","","",35,N],[11,"from","","",36,[[["t"]],["t"]]],[11,"try_from","","",36,[[["u"]],["result"]]],[11,"try_into","","",36,[[["self"]],["result"]]],[11,"into","","",36,[[["self"]],["u"]]],[11,"borrow","","",36,[[["self"]],["t"]]],[11,"borrow_mut","","",36,[[["self"]],["t"]]],[11,"get_type_id","","",36,[[["self"]],["typeid"]]],[11,"to_owned","","",36,[[["self"]],["t"]]],[11,"clone_into","","",36,N],[11,"from","","",37,[[["t"]],["t"]]],[11,"try_from","","",37,[[["u"]],["result"]]],[11,"try_into","","",37,[[["self"]],["result"]]],[11,"into","","",37,[[["self"]],["u"]]],[11,"borrow","","",37,[[["self"]],["t"]]],[11,"borrow_mut","","",37,[[["self"]],["t"]]],[11,"get_type_id","","",37,[[["self"]],["typeid"]]],[11,"to_string","","",37,[[["self"]],["string"]]],[11,"as_fail","","",37,[[["self"]],["fail"]]],[11,"from","kfs_libuser::allocator","",38,[[["t"]],["t"]]],[11,"try_from","","",38,[[["u"]],["result"]]],[11,"try_into","","",38,[[["self"]],["result"]]],[11,"into","","",38,[[["self"]],["u"]]],[11,"borrow","","",38,[[["self"]],["t"]]],[11,"borrow_mut","","",38,[[["self"]],["t"]]],[11,"get_type_id","","",38,[[["self"]],["typeid"]]],[11,"from","kfs_libuser::terminal","",39,[[["t"]],["t"]]],[11,"try_from","","",39,[[["u"]],["result"]]],[11,"try_into","","",39,[[["self"]],["result"]]],[11,"into","","",39,[[["self"]],["u"]]],[11,"borrow","","",39,[[["self"]],["t"]]],[11,"borrow_mut","","",39,[[["self"]],["t"]]],[11,"get_type_id","","",39,[[["self"]],["typeid"]]],[11,"to_owned","","",39,[[["self"]],["t"]]],[11,"clone_into","","",39,N],[11,"from","","",40,[[["t"]],["t"]]],[11,"try_from","","",40,[[["u"]],["result"]]],[11,"try_into","","",40,[[["self"]],["result"]]],[11,"into","","",40,[[["self"]],["u"]]],[11,"borrow","","",40,[[["self"]],["t"]]],[11,"borrow_mut","","",40,[[["self"]],["t"]]],[11,"get_type_id","","",40,[[["self"]],["typeid"]]],[11,"from","","",41,[[["t"]],["t"]]],[11,"try_from","","",41,[[["u"]],["result"]]],[11,"try_into","","",41,[[["self"]],["result"]]],[11,"into","","",41,[[["self"]],["u"]]],[11,"borrow","","",41,[[["self"]],["t"]]],[11,"borrow_mut","","",41,[[["self"]],["t"]]],[11,"get_type_id","","",41,[[["self"]],["typeid"]]],[11,"to_owned","","",41,[[["self"]],["t"]]],[11,"clone_into","","",41,N],[11,"from","kfs_libuser::window","",42,[[["t"]],["t"]]],[11,"try_from","","",42,[[["u"]],["result"]]],[11,"try_into","","",42,[[["self"]],["result"]]],[11,"into","","",42,[[["self"]],["u"]]],[11,"borrow","","",42,[[["self"]],["t"]]],[11,"borrow_mut","","",42,[[["self"]],["t"]]],[11,"get_type_id","","",42,[[["self"]],["typeid"]]],[11,"to_owned","","",42,[[["self"]],["t"]]],[11,"clone_into","","",42,N],[11,"from","","",43,[[["t"]],["t"]]],[11,"try_from","","",43,[[["u"]],["result"]]],[11,"try_into","","",43,[[["self"]],["result"]]],[11,"into","","",43,[[["self"]],["u"]]],[11,"borrow","","",43,[[["self"]],["t"]]],[11,"borrow_mut","","",43,[[["self"]],["t"]]],[11,"get_type_id","","",43,[[["self"]],["typeid"]]],[11,"from","kfs_libuser::log_impl","",44,[[["t"]],["t"]]],[11,"try_from","","",44,[[["u"]],["result"]]],[11,"try_into","","",44,[[["self"]],["result"]]],[11,"into","","",44,[[["self"]],["u"]]],[11,"borrow","","",44,[[["self"]],["t"]]],[11,"borrow_mut","","",44,[[["self"]],["t"]]],[11,"get_type_id","","",44,[[["self"]],["typeid"]]],[11,"from","","",46,[[["t"]],["t"]]],[11,"try_from","","",46,[[["u"]],["result"]]],[11,"try_into","","",46,[[["self"]],["result"]]],[11,"into","","",46,[[["self"]],["u"]]],[11,"borrow","","",46,[[["self"]],["t"]]],[11,"borrow_mut","","",46,[[["self"]],["t"]]],[11,"get_type_id","","",46,[[["self"]],["typeid"]]],[11,"fmt","kfs_libuser::io","",3,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result",["error"]]]],[11,"clone","","",3,[[["self"]],["pio"]]],[11,"read","","Read",3,[[["self"]],["u32"]]],[11,"write","","Write",3,N],[11,"read","","Read",3,[[["self"]],["u8"]]],[11,"write","","Write",3,N],[11,"read","","Read",3,[[["self"]],["u16"]]],[11,"write","","Write",3,N],[11,"not","kfs_libuser::syscalls","Returns the complement of this set of flags.",5,[[["self"]],["memorypermissions"]]],[11,"bitxor_assign","","Toggles the set of flags.",5,N],[11,"sub_assign","","Disables all flags enabled in the set.",5,N],[11,"fmt","kfs_libuser::error","",33,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","kfs_libuser::syscalls","",5,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result",["error"]]]],[11,"hash","","",5,N],[11,"bitand_assign","","Disables all flags disabled in the set.",5,N],[11,"clone","","",5,[[["self"]],["memorypermissions"]]],[11,"clone","kfs_libuser::error","",33,[[["self"]],["kernelerror"]]],[11,"bitxor","kfs_libuser::syscalls","Returns the left flags, but with all the right flags…",5,[[["self"],["memorypermissions"]],["memorypermissions"]]],[11,"eq","","",5,[[["self"],["memorypermissions"]],["bool"]]],[11,"ne","","",5,[[["self"],["memorypermissions"]],["bool"]]],[11,"eq","kfs_libuser::error","",33,[[["self"],["kernelerror"]],["bool"]]],[11,"ne","","",33,[[["self"],["kernelerror"]],["bool"]]],[11,"bitor","kfs_libuser::syscalls","Returns the union of the two sets of flags.",5,[[["self"],["memorypermissions"]],["memorypermissions"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","kfs_libuser::error","",33,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","kfs_libuser::syscalls","",5,[[["self"],["formatter"]],["result",["error"]]]],[11,"from_iter","","",5,[[["t"]],["memorypermissions"]]],[11,"partial_cmp","","",5,[[["self"],["memorypermissions"]],["option",["ordering"]]]],[11,"lt","","",5,[[["self"],["memorypermissions"]],["bool"]]],[11,"le","","",5,[[["self"],["memorypermissions"]],["bool"]]],[11,"gt","","",5,[[["self"],["memorypermissions"]],["bool"]]],[11,"ge","","",5,[[["self"],["memorypermissions"]],["bool"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result",["error"]]]],[11,"bitor_assign","","Adds the set of flags.",5,N],[11,"fmt","","",5,[[["self"],["formatter"]],["result",["error"]]]],[11,"extend","","",5,N],[11,"sub","","Returns the set difference of the two sets of flags.",5,[[["self"],["memorypermissions"]],["memorypermissions"]]],[11,"assert_receiver_is_total_eq","","",5,N],[11,"assert_receiver_is_total_eq","kfs_libuser::error","",33,N],[11,"bitand","kfs_libuser::syscalls","Returns the intersection between the two sets of flags.",5,[[["self"],["memorypermissions"]],["memorypermissions"]]],[11,"default","","",4,[[],["memoryinfo"]]],[11,"default","","",5,[[],["memorypermissions"]]],[11,"cmp","","",5,[[["self"],["memorypermissions"]],["ordering"]]],[11,"get_handle","kfs_libuser::ipc::server","",26,[[["self"]],["handleref"]]],[11,"handle_signaled","","",26,[[["self"],["waitablemanager"]],["result",["bool","error"]]]],[11,"get_handle","","",27,[[["self"]],["handleref"]]],[11,"handle_signaled","","",27,[[["self"],["waitablemanager"]],["result",["bool","error"]]]],[11,"fmt","kfs_libuser::error","",37,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_libuser::types","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",14,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_libuser::ipc::server","",24,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",25,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",26,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",27,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_libuser::ipc","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",22,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",23,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",21,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_libuser::sm","",30,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_libuser::vi","",31,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",32,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_libuser::error","",37,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",34,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",35,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",36,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_libuser::terminal","",39,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",41,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_libuser::window","",42,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",43,[[["self"],["formatter"]],["result"]]],[11,"eq","kfs_libuser::types","",17,[[["self"],["pid"]],["bool"]]],[11,"ne","","",17,[[["self"],["pid"]],["bool"]]],[11,"eq","kfs_libuser::error","",34,[[["self"],["module"]],["bool"]]],[11,"ne","","",34,[[["self"],["module"]],["bool"]]],[11,"eq","","",35,[[["self"],["libusererror"]],["bool"]]],[11,"ne","","",35,[[["self"],["libusererror"]],["bool"]]],[11,"eq","","",36,[[["self"],["smerror"]],["bool"]]],[11,"ne","","",36,[[["self"],["smerror"]],["bool"]]],[11,"assert_receiver_is_total_eq","kfs_libuser::types","",17,N],[11,"assert_receiver_is_total_eq","kfs_libuser::error","",34,N],[11,"assert_receiver_is_total_eq","","",35,N],[11,"assert_receiver_is_total_eq","","",36,N],[11,"deref","kfs_libuser::ipc::server","",25,[[["self"]],["t"]]],[11,"deref","kfs_libuser::log_impl","",44,[[["self"]],["mutex"]]],[11,"deref_mut","kfs_libuser::ipc::server","",25,[[["self"]],["t"]]],[11,"drop","kfs_libuser::types","",7,[[["self"]]]],[11,"drop","","",10,[[["self"]]]],[11,"drop","","",16,[[["self"]]]],[11,"index","kfs_libuser::ipc::server","",25,N],[11,"from","kfs_libuser::error","",37,[[["kernelerror"]],["self"]]],[11,"from","","",37,[[["libusererror"]],["self"]]],[11,"from","","",37,[[["smerror"]],["self"]]],[11,"write_str","kfs_libuser::terminal","",40,[[["self"],["str"]],["result",["error"]]]],[11,"write_str","kfs_libuser::log_impl","",46,[[["self"],["str"]],["result"]]],[11,"clone","kfs_libuser::types","",17,[[["self"]],["pid"]]],[11,"clone","kfs_libuser::ipc","",22,[[["self"]],["ipcbuffertype"]]],[11,"clone","","",20,[[["self"]],["ipcbuffer"]]],[11,"clone","kfs_libuser::error","",34,[[["self"]],["module"]]],[11,"clone","","",35,[[["self"]],["libusererror"]]],[11,"clone","","",36,[[["self"]],["smerror"]]],[11,"clone","kfs_libuser::terminal","",39,[[["self"]],["pos"]]],[11,"clone","","",41,[[["self"]],["windowsize"]]],[11,"clone","kfs_libuser::window","",42,[[["self"]],["color"]]],[11,"default","kfs_libuser::ipc::server","",24,[[],["waitablemanager"]]],[11,"alloc","kfs_libuser::allocator","",38,N],[11,"dealloc","","",38,N],[11,"bit_range","kfs_libuser::ipc","",18,[[["self"],["usize"],["usize"]],["t"]]],[11,"set_bit_range","","",18,[[["self"],["usize"],["usize"],["t"]]]],[11,"bit_range","","",19,[[["self"],["usize"],["usize"]],["t"]]],[11,"set_bit_range","","",19,[[["self"],["usize"],["usize"],["t"]]]],[11,"name","kfs_libuser::error","",37,[[["self"]],["option",["str"]]]],[11,"cause","","",37,[[["self"]],["option",["fail"]]]],[11,"backtrace","","",37,[[["self"]],["option",["backtrace"]]]],[11,"enabled","kfs_libuser::log_impl","",46,[[["self"],["metadata"]],["bool"]]],[11,"log","","",46,[[["self"],["record"]]]],[11,"flush","","",46,[[["self"]]]],[11,"initialize","","",44,[[["self"]]]],[11,"new","kfs_libuser::io","Create a read-only wrapper around the IO device address.",1,[[["i"]],["readonly"]]],[11,"read","","Reads from this Io.",1,N],[11,"readf","","Read from this Io, and mask the value with `flags`.",1,N],[11,"new","","Creates a WriteOnly Io.",2,[[["i"]],["writeonly"]]],[11,"write","","Writes `value` to this Io.",2,N],[11,"new","","Create a PIO from a given port",3,[[["u16"]],["pio"]]],[18,"READABLE","kfs_libuser::syscalls","The area is readable.",5,N],[18,"WRITABLE","","The area is writable.",5,N],[18,"EXECUTABLE","","The area is executable.",5,N],[11,"empty","","Returns an empty set of flags.",5,[[],["memorypermissions"]]],[11,"all","","Returns the set containing all flags.",5,[[],["memorypermissions"]]],[11,"bits","","Returns the raw value of the flags currently stored.",5,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",5,[[["u32"]],["option",["memorypermissions"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",5,[[["u32"]],["memorypermissions"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",5,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",5,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",5,[[["self"],["memorypermissions"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",5,[[["self"],["memorypermissions"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",5,N],[11,"remove","","Removes the specified flags in-place.",5,N],[11,"toggle","","Toggles the specified flags in-place.",5,N],[11,"set","","Inserts or removes the specified flags depending on the…",5,N],[11,"make_ret","kfs_libuser::error","Transforms a KernelError into the encoding acceptable for…",33,[[["self"]],["usize"]]],[11,"from_syscall_ret","","Turns a syscall return value into a Kernel Error.",33,[[["u32"]],["kernelerror"]]],[11,"from_description","","Turns a kernel error description into a KernelError.",33,[[["u32"]],["kernelerror"]]],[11,"description","","Gets the underlying KernelError description.",33,[[["self"]],["u32"]]],[18,"InvalidKernelCaps","","Kernel capabilities are invalid.",33,N],[18,"NotImplemented","","This function is not implemented.",33,N],[18,"InvalidSize","","The size argument is invalid.",33,N],[18,"InvalidAddress","","The passed address is invalid.",33,N],[18,"MemoryFull","","The virtual address space was exhausted.",33,N],[18,"HandleTableFull","","The process' handle table is full.",33,N],[18,"InvalidMemPerms","","The memory permissions passed are wrong.",33,N],[18,"InvalidHandle","","Passed handle is invalid.",33,N],[18,"CopyFromUserFailed","","Attempt to copy the userspace address failed.",33,N],[18,"InvalidCombination","","The combination of argument is invalid.",33,N],[18,"Timeout","","A timeout was reached.",33,N],[18,"Canceled","","The syscall was cancelled through cancel_synchronization.",33,N],[18,"ExceedingMaximum","","A size or address was given exceeding the maximum allowed…",33,N],[18,"NoSuchEntry","","The given entry does not exist.",33,N],[18,"PortRemoteDead","","The remote part of the session was closed.",33,N],[18,"ProcessAlreadyStarted","","Attempted to start a process that was already started.",33,N],[18,"ReservedValue","","Attempted to use an unknown value, reserved for future use.",33,N]],"paths":[[8,"Io"],[3,"ReadOnly"],[3,"WriteOnly"],[3,"Pio"],[3,"MemoryInfo"],[3,"MemoryPermissions"],[3,"Registers"],[3,"Handle"],[3,"HandleRef"],[3,"ReadableEvent"],[3,"ClientSession"],[3,"ServerSession"],[3,"ClientPort"],[3,"ServerPort"],[3,"Thread"],[3,"SharedMemory"],[3,"MappedSharedMemory"],[3,"Pid"],[3,"MsgPackedHdr"],[3,"HandleDescriptorHeader"],[3,"IPCBuffer"],[3,"Message"],[4,"IPCBufferType"],[4,"MessageTy"],[3,"WaitableManager"],[3,"Align16"],[3,"SessionWrapper"],[3,"PortHandler"],[8,"IWaitable"],[8,"Object"],[3,"IUserInterface"],[3,"ViInterface"],[3,"IBuffer"],[3,"KernelError"],[3,"Module"],[3,"LibuserError"],[3,"SmError"],[4,"Error"],[3,"Allocator"],[3,"Pos"],[3,"Terminal"],[4,"WindowSize"],[3,"Color"],[3,"Window"],[3,"SVC_LOG_BUFFER"],[8,"Termination"],[3,"Logger"]]};
searchIndex["kfs_libutils"]={"doc":"A messy crate with various utilities shared between the…","items":[[3,"CursorWrite","kfs_libutils","A minimal Cursor for writing, for use in libcore.",N,N],[12,"data","","Data backing this cursor.",0,N],[12,"pos","","Position of the cursor in the data.",0,N],[3,"CursorRead","","A minimal Cursor for writing, for use in libcore.",N,N],[12,"data","","Data backing this cursor.",1,N],[12,"pos","","Position of the cursor in the data.",1,N],[5,"align_up","","Align the address to the next alignment.",N,[[["t"],["t"]],["t"]]],[5,"align_down","","Align the address to the previous alignment.",N,[[["t"],["t"]],["t"]]],[5,"align_up_checked","","align_up, but checks if addr overflows",N,[[["usize"],["usize"]],["option",["usize"]]]],[5,"div_ceil","","Counts the numbers of `b` in `a`, rounding the result up.",N,[[["t"],["t"]],["t"]]],[5,"print_hexdump","","Displays memory as hexdump",N,N],[5,"print_hexdump_as_if_at_addr","","Makes a hexdump of a slice, but display different…",N,N],[5,"bit_array_first_zero","","Returns the index of the first 0 in a bit array.",N,N],[5,"bit_array_first_one","","Returns the index of the first 1 in a bit array.",N,N],[5,"bit_array_first_count_one","","Returns the index of the first instance of count…",N,N],[0,"io","","The IO interface",N,N],[3,"ReadOnly","kfs_libutils::io","A read-only wrapper around an IO device.",N,N],[12,"inner","","",2,N],[3,"WriteOnly","","An Io that we can only write to.",N,N],[12,"inner","","",3,N],[3,"Pio","","Port IO accessor.",N,N],[12,"port","","IO-space address this Pio reads from.",4,N],[12,"value","","The word size of this pointer. Should be u8, u16 or u32.",4,N],[8,"Io","","The Io trait allows for accessing device IO in a generic…",N,N],[16,"Value","","The width of the IO access. Should be a primitive type…",5,N],[10,"read","","Reads from this Io.",5,N],[10,"write","","Writes `value` to this Io.",5,N],[11,"readf","","Read from this Io, and mask the value with `flags`.",5,N],[11,"writef","","Mask `value` with `flags`, and write it to this device…",5,N],[11,"new","","Create a read-only wrapper around the IO device address.",2,[[["i"]],["readonly"]]],[11,"read","","Reads from this Io.",2,N],[11,"readf","","Read from this Io, and mask the value with `flags`.",2,N],[11,"new","","Creates a WriteOnly Io.",3,[[["i"]],["writeonly"]]],[11,"write","","Writes `value` to this Io.",3,N],[11,"new","","Create a PIO from a given port",4,[[["u16"]],["self"]]],[0,"cursor","kfs_libutils","Simple cursor",N,N],[3,"CursorWrite","kfs_libutils::cursor","A minimal Cursor for writing, for use in libcore.",N,N],[12,"data","","Data backing this cursor.",0,N],[12,"pos","","Position of the cursor in the data.",0,N],[3,"CursorRead","","A minimal Cursor for writing, for use in libcore.",N,N],[12,"data","","Data backing this cursor.",1,N],[12,"pos","","Position of the cursor in the data.",1,N],[11,"new","kfs_libutils","Creates a new cursor wrapping the provided underlying…",0,N],[11,"pos","","Returns the current position of this cursor.",0,[[["self"]],["usize"]]],[11,"skip_write","","Skip the given amount of bytes, returning a mutable slice…",0,N],[11,"write_u8","","Writes an u8 in the given byte ordering.",0,[[["self"],["u8"]]]],[11,"write_u16","","Writes a u16 in the given byte ordering.",0,[[["self"],["u16"]]]],[11,"write_u32","","Writes a u32 in the given byte ordering.",0,[[["self"],["u32"]]]],[11,"write_u64","","Writes a u64 in the given byte ordering.",0,[[["self"],["u64"]]]],[11,"write","","Writes the given byte slice entirely.",0,N],[11,"write_raw","","Writes the given structure.",0,[[["self"],["t"]]]],[11,"new","","Creates a new cursor wrapping the provided underlying…",1,N],[11,"pos","","Returns the current position of this cursor.",1,[[["self"]],["usize"]]],[11,"read_u8","","Reads an u8 in the given byteorder.",1,[[["self"]],["u8"]]],[11,"read_u16","","Reads an u16 in the given byteorder.",1,[[["self"]],["u16"]]],[11,"read_u32","","Reads an u32 in the given byteorder.",1,[[["self"]],["u32"]]],[11,"read_u64","","Reads an u64 in the given byteorder.",1,[[["self"]],["u64"]]],[11,"assert","","Reads `v.len()` bytes from the stream, and asserts that it…",1,N],[11,"skip_read","","Skips `bytelen` bytes, returning a slice to them for…",1,N],[11,"read_raw","","Reads the given structure from the bytestream.",1,[[["self"]],["t"]]],[8,"BitArrayExt","","Extension of the [BitField] trait, that adds the…",N,N],[11,"set_bits_area","","Sets a range of bits to `value` in the BitField.",6,[[["self"],["range",["usize"]],["bool"]]]],[14,"enum_with_val","","Creates a fake C-like enum, where all bit values are…",N,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"from","kfs_libutils::io","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"read","","Read",4,[[["self"]],["u8"]]],[11,"write","","Write",4,[[["self"],["u8"]]]],[11,"read","","Read",4,[[["self"]],["u16"]]],[11,"write","","Write",4,[[["self"],["u16"]]]],[11,"read","","Read",4,[[["self"]],["u32"]]],[11,"write","","Write",4,[[["self"],["u32"]]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_libutils","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"clone","kfs_libutils::io","",4,[[["self"]],["pio"]]]],"paths":[[3,"CursorWrite"],[3,"CursorRead"],[3,"ReadOnly"],[3,"WriteOnly"],[3,"Pio"],[8,"Io"],[8,"BitArrayExt"]]};
searchIndex["kfs_shell"]={"doc":"Shell","items":[[5,"main","kfs_shell","",N,[[]]],[5,"show_gif","","Shows a GIF in a new window, blocking the caller. When a…",N,N],[5,"test_threads","","Test function ensuring threads are working properly.",N,[[["terminal"]],["terminal"]]],[5,"test_divide_by_zero","","Test function ensuring divide by zero interruption kills…",N,[[]]],[5,"test_page_fault","","Test function ensuring pagefaults kills only the current…",N,[[]]],[0,"ps2","","PS/2 Keyboard Driver",N,N],[3,"PS2","kfs_shell::ps2","PS2 keyboard state.",N,N],[12,"status_port","","Status Register address",0,N],[12,"data_port","","Data Register address",0,N],[12,"event","","IRQEvent for the PS/2 keyboard. Triggered each time the…",0,N],[12,"is_capslocked","","Flips when the user has toggled the caps lock key. When…",0,N],[12,"is_shift","","Set to true if the user is currently holding the shift…",0,N],[3,"LetterKey","","A non-control key (lowercase_ascii, uppercase_ascii)",N,N],[12,"lower_case","","",1,N],[12,"upper_case","","",1,N],[3,"ControlKey","","A control key (ctrl, shift, alt, arrows, end, ...)",N,N],[12,"0","","",2,N],[3,"KeyEvent","","A KeyEvent is the combination of a key and its state",N,N],[12,"key","","",3,N],[12,"state","","",3,N],[3,"PRIMARY_PS2","","Primary PS2 controller instance on a classical IBM/PC…",N,N],[12,"__private_field","","",4,N],[4,"Key","","A key is either a letter key, a control key, or not…",N,N],[13,"Letter","","",5,N],[13,"Control","","",5,N],[13,"Empty","","",5,N],[4,"State","","State of a key on the keyboard.",N,N],[13,"Pressed","","",6,N],[13,"Released","","",6,N],[5,"read_key","","Waits for a single key press, and return its unicode…",N,[[],["char"]]],[5,"try_read_key","","If a key press is pending, return its unicode…",N,[[],["option",["char"]]]],[5,"get_next_line","","Read key presses until a \\n is detected, and return the…",N,[[["terminal"]],["string"]]],[5,"get_waitable","","Get a ReadableEvent for the PS2 IRQ. Waiting on this event…",N,[[],["readableevent"]]],[7,"PRIMARY_PS2","","",N,N],[11,"ctrl","","Create a control key with the given human-readable name.",5,[[["str"]],["key"]]],[11,"letter","","Create a unicode key with the given lowercase and…",5,[[["char"],["char"]],["key"]]],[11,"read_key_event","","Reads one or more bytes from the port until it matches a…",3,[[["pio",["u8"]]],["keyevent"]]],[11,"handle_control_key","","Handle a control key scancode",0,[[["self"],["controlkey"],["state"]]]],[11,"key_to_letter","","Gets the letter from the key, accounting for shift and…",0,[[["self"],["letterkey"]],["char"]]],[11,"read_key","","Waits for a single key press, and return its unicode…",0,[[["self"]],["char"]]],[11,"try_read_key","","If a key press is pending, return its unicode…",0,[[["self"]],["option",["char"]]]],[11,"event_irq","","Get a ReadableEvent for the PS2 IRQ. Waiting on this event…",0,[[["self"]],["readableevent"]]],[7,"LOUIS3","kfs_shell","Meme for KFS3",N,N],[7,"LOUIS4","","Meme for KFS4",N,N],[7,"CAPABILITIES","","",N,N],[11,"from","kfs_shell::ps2","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"from","","",6,[[["t"]],["t"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"deref","","",4,[[["self"]],["ps2"]]],[11,"clone","","",1,[[["self"]],["letterkey"]]],[11,"clone","","",2,[[["self"]],["controlkey"]]],[11,"clone","","",5,[[["self"]],["key"]]],[11,"initialize","","",4,[[["self"]]]]],"paths":[[3,"PS2"],[3,"LetterKey"],[3,"ControlKey"],[3,"KeyEvent"],[3,"PRIMARY_PS2"],[4,"Key"],[4,"State"]]};
searchIndex["kfs_sm"]={"doc":"Service Manager","items":[[3,"UserInterface","kfs_sm","`sm:` service interface. The main interface to the Service…",N,N],[3,"SERVICES","","Global mapping of Service Name -> ClientPort.",N,N],[12,"__private_field","","",0,N],[5,"get_service_length","","Get the length of a service encoded as an u64.",N,[[["u64"]],["usize"]]],[5,"get_service_str","","Casts an &u64 into an &str.",N,[[["u64"]],["str"]]],[5,"main","","",N,[[]]],[7,"SERVICES","","",N,N],[7,"CAPABILITIES","","",N,N],[11,"initialize","","Initialize the UserInterface, acquiring the Pid of the…",1,[[["self"],["pid"]],["result",["error"]]]],[11,"get_service","","Get a ClientSession to this service.",1,[[["self"],["u64"]],["result",["error"]]]],[11,"register_service","","Register a new service, returning a ServerPort to the…",1,[[["self"],["u64"],["u8"],["u32"]],["result",["error"]]]],[11,"unregister_service","","Unregister a service.",1,[[["self"],["u64"]],["result",["error"]]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"deref","","",0,[[["self"]],["mutex"]]],[11,"default","","",1,[[],["userinterface"]]],[11,"dispatch","","",1,N],[11,"initialize","","",0,[[["self"]]]]],"paths":[[3,"SERVICES"],[3,"UserInterface"]]};
searchIndex["kfs_vi"]={"doc":"Visual Compositor","items":[[3,"ViInterface","kfs_vi","Entry point interface.",N,N],[3,"Buffer","","Internal representation of a window.",N,N],[12,"top","","",0,N],[12,"left","","",0,N],[12,"width","","",0,N],[12,"height","","",0,N],[12,"mem","","",0,N],[3,"IBuffer","","IPC Window object",N,N],[12,"buffer","","The Buffer linked with this window object instance.",1,N],[5,"get_intersect","","Gets the intersection between two rectangles.",N,N],[5,"draw","","Draw a portion of a buffer onto the framebuffer.",N,[[["buffer"],["framebuffer"],["u32"],["u32"],["u32"],["u32"]]]],[5,"get_real_bounds","","See [Buffer::get_real_bounds].",N,N],[5,"main","","",N,[[]]],[0,"vbe","","VESA Bios Extensions Framebuffer",N,N],[3,"VBEColor","kfs_vi::vbe","A rgb color",N,N],[12,"b","","",2,N],[12,"g","","",2,N],[12,"r","","",2,N],[12,"a","","",2,N],[3,"Framebuffer","","A wrapper around a linear framebuffer. The framebuffer is…",N,N],[12,"buf","","",3,N],[12,"width","","",3,N],[12,"height","","",3,N],[12,"bpp","","Bits-per-pixel. Usually 8.",3,N],[3,"FRAMEBUFFER","","",N,N],[12,"__private_field","","",4,N],[7,"FRAMEBUFFER","","",N,N],[11,"rgb","","Creates a VBEColor from the given red/green/blue…",2,[[["u8"],["u8"],["u8"]],["vbecolor"]]],[11,"new","","Creates an instance of the linear framebuffer.",3,[[],["result",["framebuffer","error"]]]],[11,"new_buffer","","Creates a backbuffer backed by an in-memory array.",3,N],[11,"width","","framebuffer width in pixels. Does not account for bpp",3,[[["self"]],["usize"]]],[11,"height","","framebuffer height in pixels. Does not account for bpp",3,[[["self"]],["usize"]]],[11,"bpp","","The number of bits that forms a pixel. Used to compute…",3,[[["self"]],["usize"]]],[11,"get_px_offset","","Gets the offset in memory of a pixel based on an x and y.",3,[[["self"],["usize"],["usize"]],["usize"]]],[11,"write_px","","Writes a pixel in the framebuffer respecting the bgr pattern",3,[[["self"],["usize"],["vbecolor"]]]],[11,"write_px_at","","Writes a pixel in the framebuffer respecting the bgr…",3,[[["self"],["usize"],["usize"],["vbecolor"]]]],[11,"get_fb","","Gets the underlying framebuffer",3,N],[11,"clear","","Clears the whole screen",3,[[["self"]]]],[11,"clear_at","","Clears a segment of the screen.",3,[[["self"],["usize"],["usize"],["usize"],["usize"]]]],[7,"BUFFERS","kfs_vi","A list of the buffers currently alive.",N,N],[7,"BACKBUFFER_ARR","","The backbuffer to draw into.",N,N],[7,"CAPABILITIES","","",N,N],[11,"create_buffer","","Create a window.",5,[[["self"],["waitablemanager"],["handle"],["i32"],["i32"],["u32"],["u32"]],["result",["error"]]]],[11,"get_resolution","","Gets the screen resolution.",5,[[["self"]],["result",["error"]]]],[11,"get_real_bounds","","Returns the buffer's bounds within the given width/height,…",0,N],[11,"draw","","Blit the buffer to the framebuffer.",1,[[["self"]],["result",["error"]]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"from","kfs_vi::vbe","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","kfs_vi","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"deref","kfs_vi::vbe","",4,[[["self"]],["mutex"]]],[11,"drop","kfs_vi","Redraw the zone where the buffer was when dropping it, to…",1,[[["self"]]]],[11,"clone","kfs_vi::vbe","",2,[[["self"]],["vbecolor"]]],[11,"default","kfs_vi","",5,[[],["viinterface"]]],[11,"dispatch","","",5,N],[11,"dispatch","","",1,N],[11,"initialize","kfs_vi::vbe","",4,[[["self"]]]]],"paths":[[3,"Buffer"],[3,"IBuffer"],[3,"VBEColor"],[3,"Framebuffer"],[3,"FRAMEBUFFER"],[3,"ViInterface"]]};
initSearch(searchIndex);addSearchOptions(searchIndex);
